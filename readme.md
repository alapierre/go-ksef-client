[![Sonarcloud Status](https://sonarcloud.io/api/project_badges/measure?project=alapierre_go-ksef-client&metric=alert_status)](https://sonarcloud.io/dashboard?id=alapierre_go-ksef-client)
[![Renovate enabled](https://img.shields.io/badge/renovate-enabled-brightgreen.svg)](https://renovatebot.com/)

# GO KSeF 2.0 API client library

API structure generated by `ogen-go` with AuthFacade, EncryptionService and in memory TokenProvider.

Very early project status - not ready for production use.

## Design assumptions

### Context-bound NIP

- The client reads the taxpayer identifier (NIP) from context.Context.
- Rationale:
  - Consistency: a single, implicit source of truth for the current processing scope.
  - Propagation: NIP travels with the request lifetime across layers without changing function signatures.
  - Safety: avoids accidental mix-ups when multiple NIPs may be processed concurrently.

How it works

Set NIP into context once, near the request boundary:

````go
ctx := ksef.Context(ctx, nipString)
````

Components that require NIP retrieve it from context:

````go
nip, ok := ksef.NipFromContext(ctx)
````

Authorization flows (e.g., AuthWithToken) expect NIP to be present in the provided context. If missing, an error is returned.

Guidelines

- Always derive child contexts from the NIP-bearing parent (use the same ctx for subsequent calls).
- Do not pass NIP as a separate function parameter; rely on context for clarity and consistency.
- Validate NIP before injecting it into context if your application requires strict input checks.
- When spawning goroutines or timeouts, carry the same context forward (e.g., context.WithTimeout(ctx, ...)) so NIP remains available.

Example

At startup or per request:

````go
ctx := context.Background()
ctx = ksef.Context(ctx, "")
````

Use ctx for all API calls that require NIP

## TokenProvider Multi-NIP token cache

TokenProvider is a simple in-memory cache for KSeF tokens. It is thread-safe and can be used concurrently from multiple goroutines.
In the next implementation, locks will be contextual — currently, the mutex is locked regardless of the NIP

## EncryptionService

EncryptionService is responsible for:
- fetching and caching KSeF public certificates,
- encryption for two distinct usages:
  - KsefTokenEncryption (auth token + timestamp),
  - SymmetricKeyEncryption (encrypting the AES key used for invoices),
- optional initialization without contacting the API (when you already have certificates/keys).

Keys are cached separately for each usage and automatically refreshed before expiration using a safety margin (refreshSkew).

Key points:
- Two independent caches: tokenPub (KsefTokenEncryption) and symKeyPub (SymmetricKeyEncryption).
- Automatic on-demand fetch from the API only when a key is missing or close to expiration.
- ForceRefresh() refreshes both caches (does not return keys).
- Optional preload of certificates/keys in the constructor to avoid API calls.

### Initialization

Standard (keys fetched on demand from the API):

````go
// Go
env := ksef.Test
httpClient := &http.Client{ Timeout: 15 * time.Second }

enc, err := cipher.NewEncryptionService(env, httpClient)
if err != nil {
    // handle error
}
````

No API calls — preload with existing certs or keys

````go
// Go
enc, err := cipher.NewEncryptionService(
    env,
    httpClient,
    cipher.WithPreloadedKeys(cipher.PreloadedKeys{
        // Option A: certificates in DER Base64 form
        TokenCertBase64:     "<base64-der-token>",
        SymmetricCertBase64: "<base64-der-symmetric>",

        // Option B: ready *rsa.PublicKey instances
        // TokenRSAPub:     tokenPub,
        // SymmetricRSAPub: symPub,

        // Optional validity dates (if omitted, they’ll be read from certs)
        // TokenValidTo:     time.Time{},
        // SymmetricValidTo: time.Time{},
    }),
)
if err != nil {
    // handle error
}
````

Encryption

Encrypt KSeF token (token + timestamp in ms), RSA-OAEP(SHA-256)

````go
encryptedTokenBytes, err := enc.EncryptKsefToken(ctx, token, challenge.Timestamp)
if err != nil {
    // handle error
}
````

Encrypt the invoice symmetric key (Usage=SymmetricKeyEncryption)

````go
encryptedSymKey, err := enc.EncryptSymmetricKey(ctx, aesKey)
````

If a required key is missing or expired, EncryptionService will fetch/refresh the proper certificate and update its cache automatically.

````go
if err := enc.ForceRefresh(ctx); err != nil {
    // handle error
}
````

After ForceRefresh, use the regular methods (EncryptKsefToken, EncryptSymmetricKey, or GetPublicKeyFor). ForceRefresh itself does not return keys.

### Implementation notes

- RSA-OAEP with SHA-256 is used for all RSA encryptions.
- Each key usage has its own key and validity tracked independently.
- refreshSkew is a safety margin checked on-demand: when a key is requested and its ValidTo − now ≤ refreshSkew (default 2 minutes), the service refreshes it; there is no periodic timer.
- GetPublicKeyFor(ctx, usage) returns the current key for the given usage and will fetch/cache it if needed.

## Authentication with KSeF Token 

Sample usage:

````go
package main

import (
	"context"
	"fmt"
	"net/http"
	"time"

	"github.com/alapierre/go-ksef-client/ksef"
	"github.com/alapierre/go-ksef-client/ksef/api"
	"github.com/alapierre/go-ksef-client/ksef/auth"
	"github.com/alapierre/go-ksef-client/ksef/cipher"
	"github.com/alapierre/go-ksef-client/ksef/util"
)

func main() {

	nip := util.GetEnvOrFailed("KSEF_NIP")
	token := util.GetEnvOrFailed("KSEF_TOKEN")

	httpClient := &http.Client{
		Timeout: 15 * time.Second,
	}

	env := ksef.Test
	authFacade, err := auth.NewFacade(env, httpClient)
	if err != nil {
		panic(err)
	}

	encryptor, err := cipher.NewEncryptionService(env, httpClient)
	if err != nil {
		panic(err)
	}

	ctx := context.Background()
	ctx = ksef.Context(ctx, nip)
	tokens, err := initTokens(ctx, authFacade, encryptor, token)

	if err != nil {
		panic(err)
	}

	fmt.Println(tokens.AccessToken.Token)
	fmt.Println(tokens.RefreshToken.Token)

	refreshToken, err := authFacade.RefreshToken(ctx, tokens.RefreshToken.Token)
	if err != nil {
		panic(err)
	}

	fmt.Println(refreshToken.GetToken())
	fmt.Println("Refreshed")
}

func initTokens(ctx context.Context, authFacade *auth.Facade, encryptor *cipher.EncryptionService, token string) (*api.AuthenticationTokensResponse, error) {

	challenge, err := authFacade.GetChallenge(ctx)
	if err != nil {
		return nil, err
	}

	encryptedToken, err := encryptor.EncryptKsefToken(ctx, token, challenge.Timestamp)
	if err != nil {
		return nil, err
	}

	initResp, err := authFacade.AuthWithToken(ctx, challenge.Challenge, encryptedToken)
	if err != nil {
		return nil, err
	}

	ctx, cancel := context.WithTimeout(context.Background(), 60*time.Second)
	defer cancel()

	return authFacade.AuthWaitAndRedeem(ctx, initResp, 1*time.Second)
}
````