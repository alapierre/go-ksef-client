// Code generated by ogen, DO NOT EDIT.

package api

import (
	"math/bits"
	"net/url"
	"strconv"
	"time"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"
	"github.com/ogen-go/ogen/json"
	"github.com/ogen-go/ogen/validate"
)

// Encode encodes APIV2SecurityPublicKeyCertificatesGetOKApplicationJSON as json.
func (s APIV2SecurityPublicKeyCertificatesGetOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []PublicKeyCertificate(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes APIV2SecurityPublicKeyCertificatesGetOKApplicationJSON from json.
func (s *APIV2SecurityPublicKeyCertificatesGetOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIV2SecurityPublicKeyCertificatesGetOKApplicationJSON to nil")
	}
	var unwrapped []PublicKeyCertificate
	if err := func() error {
		unwrapped = make([]PublicKeyCertificate, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem PublicKeyCertificate
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = APIV2SecurityPublicKeyCertificatesGetOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s APIV2SecurityPublicKeyCertificatesGetOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIV2SecurityPublicKeyCertificatesGetOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AllowedIps) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AllowedIps) encodeFields(e *jx.Encoder) {
	{
		if s.Ip4Addresses.Set {
			e.FieldStart("ip4Addresses")
			s.Ip4Addresses.Encode(e)
		}
	}
	{
		if s.Ip4Ranges.Set {
			e.FieldStart("ip4Ranges")
			s.Ip4Ranges.Encode(e)
		}
	}
	{
		if s.Ip4Masks.Set {
			e.FieldStart("ip4Masks")
			s.Ip4Masks.Encode(e)
		}
	}
}

var jsonFieldsNameOfAllowedIps = [3]string{
	0: "ip4Addresses",
	1: "ip4Ranges",
	2: "ip4Masks",
}

// Decode decodes AllowedIps from json.
func (s *AllowedIps) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AllowedIps to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ip4Addresses":
			if err := func() error {
				s.Ip4Addresses.Reset()
				if err := s.Ip4Addresses.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ip4Addresses\"")
			}
		case "ip4Ranges":
			if err := func() error {
				s.Ip4Ranges.Reset()
				if err := s.Ip4Ranges.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ip4Ranges\"")
			}
		case "ip4Masks":
			if err := func() error {
				s.Ip4Masks.Reset()
				if err := s.Ip4Masks.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ip4Masks\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AllowedIps")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AllowedIps) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AllowedIps) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AmountType as json.
func (s AmountType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AmountType from json.
func (s *AmountType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AmountType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AmountType(v) {
	case AmountTypeBrutto:
		*s = AmountTypeBrutto
	case AmountTypeNetto:
		*s = AmountTypeNetto
	case AmountTypeVat:
		*s = AmountTypeVat
	default:
		*s = AmountType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AmountType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AmountType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ApiRateLimitValuesOverride) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ApiRateLimitValuesOverride) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("perSecond")
		e.Int32(s.PerSecond)
	}
	{
		e.FieldStart("perMinute")
		e.Int32(s.PerMinute)
	}
	{
		e.FieldStart("perHour")
		e.Int32(s.PerHour)
	}
}

var jsonFieldsNameOfApiRateLimitValuesOverride = [3]string{
	0: "perSecond",
	1: "perMinute",
	2: "perHour",
}

// Decode decodes ApiRateLimitValuesOverride from json.
func (s *ApiRateLimitValuesOverride) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ApiRateLimitValuesOverride to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "perSecond":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.PerSecond = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"perSecond\"")
			}
		case "perMinute":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int32()
				s.PerMinute = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"perMinute\"")
			}
		case "perHour":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int32()
				s.PerHour = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"perHour\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ApiRateLimitValuesOverride")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfApiRateLimitValuesOverride) {
					name = jsonFieldsNameOfApiRateLimitValuesOverride[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ApiRateLimitValuesOverride) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ApiRateLimitValuesOverride) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ApiRateLimitsOverride) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ApiRateLimitsOverride) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("onlineSession")
		s.OnlineSession.Encode(e)
	}
	{
		e.FieldStart("batchSession")
		s.BatchSession.Encode(e)
	}
	{
		e.FieldStart("invoiceSend")
		s.InvoiceSend.Encode(e)
	}
	{
		e.FieldStart("invoiceStatus")
		s.InvoiceStatus.Encode(e)
	}
	{
		e.FieldStart("sessionList")
		s.SessionList.Encode(e)
	}
	{
		e.FieldStart("sessionInvoiceList")
		s.SessionInvoiceList.Encode(e)
	}
	{
		e.FieldStart("sessionMisc")
		s.SessionMisc.Encode(e)
	}
	{
		e.FieldStart("invoiceMetadata")
		s.InvoiceMetadata.Encode(e)
	}
	{
		e.FieldStart("invoiceExport")
		s.InvoiceExport.Encode(e)
	}
	{
		e.FieldStart("invoiceDownload")
		s.InvoiceDownload.Encode(e)
	}
	{
		e.FieldStart("other")
		s.Other.Encode(e)
	}
}

var jsonFieldsNameOfApiRateLimitsOverride = [11]string{
	0:  "onlineSession",
	1:  "batchSession",
	2:  "invoiceSend",
	3:  "invoiceStatus",
	4:  "sessionList",
	5:  "sessionInvoiceList",
	6:  "sessionMisc",
	7:  "invoiceMetadata",
	8:  "invoiceExport",
	9:  "invoiceDownload",
	10: "other",
}

// Decode decodes ApiRateLimitsOverride from json.
func (s *ApiRateLimitsOverride) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ApiRateLimitsOverride to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "onlineSession":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.OnlineSession.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"onlineSession\"")
			}
		case "batchSession":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.BatchSession.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"batchSession\"")
			}
		case "invoiceSend":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.InvoiceSend.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"invoiceSend\"")
			}
		case "invoiceStatus":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.InvoiceStatus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"invoiceStatus\"")
			}
		case "sessionList":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.SessionList.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sessionList\"")
			}
		case "sessionInvoiceList":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.SessionInvoiceList.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sessionInvoiceList\"")
			}
		case "sessionMisc":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.SessionMisc.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sessionMisc\"")
			}
		case "invoiceMetadata":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.InvoiceMetadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"invoiceMetadata\"")
			}
		case "invoiceExport":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.InvoiceExport.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"invoiceExport\"")
			}
		case "invoiceDownload":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.InvoiceDownload.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"invoiceDownload\"")
			}
		case "other":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				if err := s.Other.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"other\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ApiRateLimitsOverride")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfApiRateLimitsOverride) {
					name = jsonFieldsNameOfApiRateLimitsOverride[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ApiRateLimitsOverride) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ApiRateLimitsOverride) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AttachmentPermissionGrantRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AttachmentPermissionGrantRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("nip")
		s.Nip.Encode(e)
	}
}

var jsonFieldsNameOfAttachmentPermissionGrantRequest = [1]string{
	0: "nip",
}

// Decode decodes AttachmentPermissionGrantRequest from json.
func (s *AttachmentPermissionGrantRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AttachmentPermissionGrantRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "nip":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Nip.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nip\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AttachmentPermissionGrantRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAttachmentPermissionGrantRequest) {
					name = jsonFieldsNameOfAttachmentPermissionGrantRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AttachmentPermissionGrantRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AttachmentPermissionGrantRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AttachmentPermissionRevokeRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AttachmentPermissionRevokeRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("nip")
		s.Nip.Encode(e)
	}
}

var jsonFieldsNameOfAttachmentPermissionRevokeRequest = [1]string{
	0: "nip",
}

// Decode decodes AttachmentPermissionRevokeRequest from json.
func (s *AttachmentPermissionRevokeRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AttachmentPermissionRevokeRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "nip":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Nip.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nip\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AttachmentPermissionRevokeRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAttachmentPermissionRevokeRequest) {
					name = jsonFieldsNameOfAttachmentPermissionRevokeRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AttachmentPermissionRevokeRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AttachmentPermissionRevokeRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AuthenticationChallengeResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AuthenticationChallengeResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("challenge")
		s.Challenge.Encode(e)
	}
	{
		e.FieldStart("timestamp")
		json.EncodeDateTime(e, s.Timestamp)
	}
}

var jsonFieldsNameOfAuthenticationChallengeResponse = [2]string{
	0: "challenge",
	1: "timestamp",
}

// Decode decodes AuthenticationChallengeResponse from json.
func (s *AuthenticationChallengeResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AuthenticationChallengeResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "challenge":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Challenge.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"challenge\"")
			}
		case "timestamp":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.Timestamp = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AuthenticationChallengeResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAuthenticationChallengeResponse) {
					name = jsonFieldsNameOfAuthenticationChallengeResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AuthenticationChallengeResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AuthenticationChallengeResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AuthenticationContextIdentifier) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AuthenticationContextIdentifier) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("value")
		e.Str(s.Value)
	}
}

var jsonFieldsNameOfAuthenticationContextIdentifier = [2]string{
	0: "type",
	1: "value",
}

// Decode decodes AuthenticationContextIdentifier from json.
func (s *AuthenticationContextIdentifier) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AuthenticationContextIdentifier to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "value":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Value = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AuthenticationContextIdentifier")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAuthenticationContextIdentifier) {
					name = jsonFieldsNameOfAuthenticationContextIdentifier[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AuthenticationContextIdentifier) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AuthenticationContextIdentifier) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AuthenticationContextIdentifierType as json.
func (s AuthenticationContextIdentifierType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AuthenticationContextIdentifierType from json.
func (s *AuthenticationContextIdentifierType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AuthenticationContextIdentifierType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AuthenticationContextIdentifierType(v) {
	case AuthenticationContextIdentifierTypeNip:
		*s = AuthenticationContextIdentifierTypeNip
	case AuthenticationContextIdentifierTypeInternalId:
		*s = AuthenticationContextIdentifierTypeInternalId
	case AuthenticationContextIdentifierTypeNipVatUe:
		*s = AuthenticationContextIdentifierTypeNipVatUe
	case AuthenticationContextIdentifierTypePeppolId:
		*s = AuthenticationContextIdentifierTypePeppolId
	default:
		*s = AuthenticationContextIdentifierType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AuthenticationContextIdentifierType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AuthenticationContextIdentifierType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AuthenticationInitResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AuthenticationInitResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("referenceNumber")
		s.ReferenceNumber.Encode(e)
	}
	{
		e.FieldStart("authenticationToken")
		s.AuthenticationToken.Encode(e)
	}
}

var jsonFieldsNameOfAuthenticationInitResponse = [2]string{
	0: "referenceNumber",
	1: "authenticationToken",
}

// Decode decodes AuthenticationInitResponse from json.
func (s *AuthenticationInitResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AuthenticationInitResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "referenceNumber":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ReferenceNumber.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"referenceNumber\"")
			}
		case "authenticationToken":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.AuthenticationToken.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"authenticationToken\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AuthenticationInitResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAuthenticationInitResponse) {
					name = jsonFieldsNameOfAuthenticationInitResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AuthenticationInitResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AuthenticationInitResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AuthenticationListItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AuthenticationListItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("startDate")
		json.EncodeDateTime(e, s.StartDate)
	}
	{
		e.FieldStart("authenticationMethod")
		s.AuthenticationMethod.Encode(e)
	}
	{
		e.FieldStart("status")
		s.Status.Encode(e)
	}
	{
		if s.IsTokenRedeemed.Set {
			e.FieldStart("isTokenRedeemed")
			s.IsTokenRedeemed.Encode(e)
		}
	}
	{
		if s.LastTokenRefreshDate.Set {
			e.FieldStart("lastTokenRefreshDate")
			s.LastTokenRefreshDate.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.RefreshTokenValidUntil.Set {
			e.FieldStart("refreshTokenValidUntil")
			s.RefreshTokenValidUntil.Encode(e, json.EncodeDateTime)
		}
	}
	{
		e.FieldStart("referenceNumber")
		s.ReferenceNumber.Encode(e)
	}
	{
		if s.IsCurrent.Set {
			e.FieldStart("isCurrent")
			s.IsCurrent.Encode(e)
		}
	}
}

var jsonFieldsNameOfAuthenticationListItem = [8]string{
	0: "startDate",
	1: "authenticationMethod",
	2: "status",
	3: "isTokenRedeemed",
	4: "lastTokenRefreshDate",
	5: "refreshTokenValidUntil",
	6: "referenceNumber",
	7: "isCurrent",
}

// Decode decodes AuthenticationListItem from json.
func (s *AuthenticationListItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AuthenticationListItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "startDate":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.StartDate = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"startDate\"")
			}
		case "authenticationMethod":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.AuthenticationMethod.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"authenticationMethod\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "isTokenRedeemed":
			if err := func() error {
				s.IsTokenRedeemed.Reset()
				if err := s.IsTokenRedeemed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isTokenRedeemed\"")
			}
		case "lastTokenRefreshDate":
			if err := func() error {
				s.LastTokenRefreshDate.Reset()
				if err := s.LastTokenRefreshDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastTokenRefreshDate\"")
			}
		case "refreshTokenValidUntil":
			if err := func() error {
				s.RefreshTokenValidUntil.Reset()
				if err := s.RefreshTokenValidUntil.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"refreshTokenValidUntil\"")
			}
		case "referenceNumber":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.ReferenceNumber.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"referenceNumber\"")
			}
		case "isCurrent":
			if err := func() error {
				s.IsCurrent.Reset()
				if err := s.IsCurrent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isCurrent\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AuthenticationListItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAuthenticationListItem) {
					name = jsonFieldsNameOfAuthenticationListItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AuthenticationListItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AuthenticationListItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AuthenticationListResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AuthenticationListResponse) encodeFields(e *jx.Encoder) {
	{
		if s.ContinuationToken.Set {
			e.FieldStart("continuationToken")
			s.ContinuationToken.Encode(e)
		}
	}
	{
		e.FieldStart("items")
		e.ArrStart()
		for _, elem := range s.Items {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfAuthenticationListResponse = [2]string{
	0: "continuationToken",
	1: "items",
}

// Decode decodes AuthenticationListResponse from json.
func (s *AuthenticationListResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AuthenticationListResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "continuationToken":
			if err := func() error {
				s.ContinuationToken.Reset()
				if err := s.ContinuationToken.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"continuationToken\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Items = make([]AuthenticationListItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem AuthenticationListItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AuthenticationListResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAuthenticationListResponse) {
					name = jsonFieldsNameOfAuthenticationListResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AuthenticationListResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AuthenticationListResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AuthenticationMethod as json.
func (s AuthenticationMethod) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AuthenticationMethod from json.
func (s *AuthenticationMethod) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AuthenticationMethod to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AuthenticationMethod(v) {
	case AuthenticationMethodToken:
		*s = AuthenticationMethodToken
	case AuthenticationMethodTrustedProfile:
		*s = AuthenticationMethodTrustedProfile
	case AuthenticationMethodInternalCertificate:
		*s = AuthenticationMethodInternalCertificate
	case AuthenticationMethodQualifiedSignature:
		*s = AuthenticationMethodQualifiedSignature
	case AuthenticationMethodQualifiedSeal:
		*s = AuthenticationMethodQualifiedSeal
	case AuthenticationMethodPersonalSignature:
		*s = AuthenticationMethodPersonalSignature
	case AuthenticationMethodPeppolSignature:
		*s = AuthenticationMethodPeppolSignature
	default:
		*s = AuthenticationMethod(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AuthenticationMethod) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AuthenticationMethod) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AuthenticationOperationStatusResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AuthenticationOperationStatusResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("startDate")
		json.EncodeDateTime(e, s.StartDate)
	}
	{
		e.FieldStart("authenticationMethod")
		s.AuthenticationMethod.Encode(e)
	}
	{
		e.FieldStart("status")
		s.Status.Encode(e)
	}
	{
		if s.IsTokenRedeemed.Set {
			e.FieldStart("isTokenRedeemed")
			s.IsTokenRedeemed.Encode(e)
		}
	}
	{
		if s.LastTokenRefreshDate.Set {
			e.FieldStart("lastTokenRefreshDate")
			s.LastTokenRefreshDate.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.RefreshTokenValidUntil.Set {
			e.FieldStart("refreshTokenValidUntil")
			s.RefreshTokenValidUntil.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfAuthenticationOperationStatusResponse = [6]string{
	0: "startDate",
	1: "authenticationMethod",
	2: "status",
	3: "isTokenRedeemed",
	4: "lastTokenRefreshDate",
	5: "refreshTokenValidUntil",
}

// Decode decodes AuthenticationOperationStatusResponse from json.
func (s *AuthenticationOperationStatusResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AuthenticationOperationStatusResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "startDate":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.StartDate = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"startDate\"")
			}
		case "authenticationMethod":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.AuthenticationMethod.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"authenticationMethod\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "isTokenRedeemed":
			if err := func() error {
				s.IsTokenRedeemed.Reset()
				if err := s.IsTokenRedeemed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isTokenRedeemed\"")
			}
		case "lastTokenRefreshDate":
			if err := func() error {
				s.LastTokenRefreshDate.Reset()
				if err := s.LastTokenRefreshDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastTokenRefreshDate\"")
			}
		case "refreshTokenValidUntil":
			if err := func() error {
				s.RefreshTokenValidUntil.Reset()
				if err := s.RefreshTokenValidUntil.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"refreshTokenValidUntil\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AuthenticationOperationStatusResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAuthenticationOperationStatusResponse) {
					name = jsonFieldsNameOfAuthenticationOperationStatusResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AuthenticationOperationStatusResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AuthenticationOperationStatusResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AuthenticationTokenRefreshResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AuthenticationTokenRefreshResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("accessToken")
		s.AccessToken.Encode(e)
	}
}

var jsonFieldsNameOfAuthenticationTokenRefreshResponse = [1]string{
	0: "accessToken",
}

// Decode decodes AuthenticationTokenRefreshResponse from json.
func (s *AuthenticationTokenRefreshResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AuthenticationTokenRefreshResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "accessToken":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.AccessToken.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"accessToken\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AuthenticationTokenRefreshResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAuthenticationTokenRefreshResponse) {
					name = jsonFieldsNameOfAuthenticationTokenRefreshResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AuthenticationTokenRefreshResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AuthenticationTokenRefreshResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AuthenticationTokenStatus as json.
func (s AuthenticationTokenStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AuthenticationTokenStatus from json.
func (s *AuthenticationTokenStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AuthenticationTokenStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AuthenticationTokenStatus(v) {
	case AuthenticationTokenStatusPending:
		*s = AuthenticationTokenStatusPending
	case AuthenticationTokenStatusActive:
		*s = AuthenticationTokenStatusActive
	case AuthenticationTokenStatusRevoking:
		*s = AuthenticationTokenStatusRevoking
	case AuthenticationTokenStatusRevoked:
		*s = AuthenticationTokenStatusRevoked
	case AuthenticationTokenStatusFailed:
		*s = AuthenticationTokenStatusFailed
	default:
		*s = AuthenticationTokenStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AuthenticationTokenStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AuthenticationTokenStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AuthenticationTokensResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AuthenticationTokensResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("accessToken")
		s.AccessToken.Encode(e)
	}
	{
		e.FieldStart("refreshToken")
		s.RefreshToken.Encode(e)
	}
}

var jsonFieldsNameOfAuthenticationTokensResponse = [2]string{
	0: "accessToken",
	1: "refreshToken",
}

// Decode decodes AuthenticationTokensResponse from json.
func (s *AuthenticationTokensResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AuthenticationTokensResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "accessToken":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.AccessToken.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"accessToken\"")
			}
		case "refreshToken":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.RefreshToken.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"refreshToken\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AuthenticationTokensResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAuthenticationTokensResponse) {
					name = jsonFieldsNameOfAuthenticationTokensResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AuthenticationTokensResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AuthenticationTokensResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AuthorizationPolicy) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AuthorizationPolicy) encodeFields(e *jx.Encoder) {
	{
		if s.AllowedIps.Set {
			e.FieldStart("allowedIps")
			s.AllowedIps.Encode(e)
		}
	}
}

var jsonFieldsNameOfAuthorizationPolicy = [1]string{
	0: "allowedIps",
}

// Decode decodes AuthorizationPolicy from json.
func (s *AuthorizationPolicy) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AuthorizationPolicy to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "allowedIps":
			if err := func() error {
				s.AllowedIps.Reset()
				if err := s.AllowedIps.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allowedIps\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AuthorizationPolicy")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AuthorizationPolicy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AuthorizationPolicy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BatchFileInfo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BatchFileInfo) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("fileSize")
		e.Int64(s.FileSize)
	}
	{
		e.FieldStart("fileHash")
		s.FileHash.Encode(e)
	}
	{
		e.FieldStart("fileParts")
		e.ArrStart()
		for _, elem := range s.FileParts {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfBatchFileInfo = [3]string{
	0: "fileSize",
	1: "fileHash",
	2: "fileParts",
}

// Decode decodes BatchFileInfo from json.
func (s *BatchFileInfo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BatchFileInfo to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "fileSize":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int64()
				s.FileSize = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fileSize\"")
			}
		case "fileHash":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.FileHash.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fileHash\"")
			}
		case "fileParts":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.FileParts = make([]BatchFilePartInfo, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem BatchFilePartInfo
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.FileParts = append(s.FileParts, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fileParts\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BatchFileInfo")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBatchFileInfo) {
					name = jsonFieldsNameOfBatchFileInfo[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BatchFileInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BatchFileInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BatchFilePartInfo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BatchFilePartInfo) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("ordinalNumber")
		e.Int32(s.OrdinalNumber)
	}
	{
		if s.FileName.Set {
			e.FieldStart("fileName")
			s.FileName.Encode(e)
		}
	}
	{
		e.FieldStart("fileSize")
		e.Int64(s.FileSize)
	}
	{
		e.FieldStart("fileHash")
		s.FileHash.Encode(e)
	}
}

var jsonFieldsNameOfBatchFilePartInfo = [4]string{
	0: "ordinalNumber",
	1: "fileName",
	2: "fileSize",
	3: "fileHash",
}

// Decode decodes BatchFilePartInfo from json.
func (s *BatchFilePartInfo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BatchFilePartInfo to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ordinalNumber":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.OrdinalNumber = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ordinalNumber\"")
			}
		case "fileName":
			if err := func() error {
				s.FileName.Reset()
				if err := s.FileName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fileName\"")
			}
		case "fileSize":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int64()
				s.FileSize = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fileSize\"")
			}
		case "fileHash":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.FileHash.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fileHash\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BatchFilePartInfo")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBatchFilePartInfo) {
					name = jsonFieldsNameOfBatchFilePartInfo[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BatchFilePartInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BatchFilePartInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BatchSessionContextLimitsOverride) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BatchSessionContextLimitsOverride) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("maxInvoiceSizeInMB")
		e.Int32(s.MaxInvoiceSizeInMB)
	}
	{
		e.FieldStart("maxInvoiceWithAttachmentSizeInMB")
		e.Int32(s.MaxInvoiceWithAttachmentSizeInMB)
	}
	{
		e.FieldStart("maxInvoices")
		e.Int32(s.MaxInvoices)
	}
}

var jsonFieldsNameOfBatchSessionContextLimitsOverride = [3]string{
	0: "maxInvoiceSizeInMB",
	1: "maxInvoiceWithAttachmentSizeInMB",
	2: "maxInvoices",
}

// Decode decodes BatchSessionContextLimitsOverride from json.
func (s *BatchSessionContextLimitsOverride) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BatchSessionContextLimitsOverride to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "maxInvoiceSizeInMB":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.MaxInvoiceSizeInMB = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maxInvoiceSizeInMB\"")
			}
		case "maxInvoiceWithAttachmentSizeInMB":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int32()
				s.MaxInvoiceWithAttachmentSizeInMB = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maxInvoiceWithAttachmentSizeInMB\"")
			}
		case "maxInvoices":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int32()
				s.MaxInvoices = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maxInvoices\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BatchSessionContextLimitsOverride")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBatchSessionContextLimitsOverride) {
					name = jsonFieldsNameOfBatchSessionContextLimitsOverride[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BatchSessionContextLimitsOverride) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BatchSessionContextLimitsOverride) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BatchSessionEffectiveContextLimits) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BatchSessionEffectiveContextLimits) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("maxInvoiceSizeInMB")
		e.Int32(s.MaxInvoiceSizeInMB)
	}
	{
		e.FieldStart("maxInvoiceWithAttachmentSizeInMB")
		e.Int32(s.MaxInvoiceWithAttachmentSizeInMB)
	}
	{
		e.FieldStart("maxInvoices")
		e.Int32(s.MaxInvoices)
	}
}

var jsonFieldsNameOfBatchSessionEffectiveContextLimits = [3]string{
	0: "maxInvoiceSizeInMB",
	1: "maxInvoiceWithAttachmentSizeInMB",
	2: "maxInvoices",
}

// Decode decodes BatchSessionEffectiveContextLimits from json.
func (s *BatchSessionEffectiveContextLimits) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BatchSessionEffectiveContextLimits to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "maxInvoiceSizeInMB":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.MaxInvoiceSizeInMB = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maxInvoiceSizeInMB\"")
			}
		case "maxInvoiceWithAttachmentSizeInMB":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int32()
				s.MaxInvoiceWithAttachmentSizeInMB = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maxInvoiceWithAttachmentSizeInMB\"")
			}
		case "maxInvoices":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int32()
				s.MaxInvoices = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maxInvoices\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BatchSessionEffectiveContextLimits")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBatchSessionEffectiveContextLimits) {
					name = jsonFieldsNameOfBatchSessionEffectiveContextLimits[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BatchSessionEffectiveContextLimits) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BatchSessionEffectiveContextLimits) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BuyerIdentifierType as json.
func (s BuyerIdentifierType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes BuyerIdentifierType from json.
func (s *BuyerIdentifierType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BuyerIdentifierType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch BuyerIdentifierType(v) {
	case BuyerIdentifierTypeNone:
		*s = BuyerIdentifierTypeNone
	case BuyerIdentifierTypeOther:
		*s = BuyerIdentifierTypeOther
	case BuyerIdentifierTypeNip:
		*s = BuyerIdentifierTypeNip
	case BuyerIdentifierTypeVatUe:
		*s = BuyerIdentifierTypeVatUe
	default:
		*s = BuyerIdentifierType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s BuyerIdentifierType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BuyerIdentifierType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CertificateEffectiveSubjectLimits) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CertificateEffectiveSubjectLimits) encodeFields(e *jx.Encoder) {
	{
		if s.MaxCertificates.Set {
			e.FieldStart("maxCertificates")
			s.MaxCertificates.Encode(e)
		}
	}
}

var jsonFieldsNameOfCertificateEffectiveSubjectLimits = [1]string{
	0: "maxCertificates",
}

// Decode decodes CertificateEffectiveSubjectLimits from json.
func (s *CertificateEffectiveSubjectLimits) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CertificateEffectiveSubjectLimits to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "maxCertificates":
			if err := func() error {
				s.MaxCertificates.Reset()
				if err := s.MaxCertificates.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maxCertificates\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CertificateEffectiveSubjectLimits")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CertificateEffectiveSubjectLimits) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CertificateEffectiveSubjectLimits) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CertificateEnrollmentDataResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CertificateEnrollmentDataResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("commonName")
		e.Str(s.CommonName)
	}
	{
		e.FieldStart("countryName")
		e.Str(s.CountryName)
	}
	{
		if s.GivenName.Set {
			e.FieldStart("givenName")
			s.GivenName.Encode(e)
		}
	}
	{
		if s.Surname.Set {
			e.FieldStart("surname")
			s.Surname.Encode(e)
		}
	}
	{
		if s.SerialNumber.Set {
			e.FieldStart("serialNumber")
			s.SerialNumber.Encode(e)
		}
	}
	{
		if s.UniqueIdentifier.Set {
			e.FieldStart("uniqueIdentifier")
			s.UniqueIdentifier.Encode(e)
		}
	}
	{
		if s.OrganizationName.Set {
			e.FieldStart("organizationName")
			s.OrganizationName.Encode(e)
		}
	}
	{
		if s.OrganizationIdentifier.Set {
			e.FieldStart("organizationIdentifier")
			s.OrganizationIdentifier.Encode(e)
		}
	}
}

var jsonFieldsNameOfCertificateEnrollmentDataResponse = [8]string{
	0: "commonName",
	1: "countryName",
	2: "givenName",
	3: "surname",
	4: "serialNumber",
	5: "uniqueIdentifier",
	6: "organizationName",
	7: "organizationIdentifier",
}

// Decode decodes CertificateEnrollmentDataResponse from json.
func (s *CertificateEnrollmentDataResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CertificateEnrollmentDataResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "commonName":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.CommonName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"commonName\"")
			}
		case "countryName":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.CountryName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"countryName\"")
			}
		case "givenName":
			if err := func() error {
				s.GivenName.Reset()
				if err := s.GivenName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"givenName\"")
			}
		case "surname":
			if err := func() error {
				s.Surname.Reset()
				if err := s.Surname.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"surname\"")
			}
		case "serialNumber":
			if err := func() error {
				s.SerialNumber.Reset()
				if err := s.SerialNumber.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"serialNumber\"")
			}
		case "uniqueIdentifier":
			if err := func() error {
				s.UniqueIdentifier.Reset()
				if err := s.UniqueIdentifier.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uniqueIdentifier\"")
			}
		case "organizationName":
			if err := func() error {
				s.OrganizationName.Reset()
				if err := s.OrganizationName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"organizationName\"")
			}
		case "organizationIdentifier":
			if err := func() error {
				s.OrganizationIdentifier.Reset()
				if err := s.OrganizationIdentifier.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"organizationIdentifier\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CertificateEnrollmentDataResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCertificateEnrollmentDataResponse) {
					name = jsonFieldsNameOfCertificateEnrollmentDataResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CertificateEnrollmentDataResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CertificateEnrollmentDataResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CertificateEnrollmentStatusResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CertificateEnrollmentStatusResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("requestDate")
		json.EncodeDateTime(e, s.RequestDate)
	}
	{
		e.FieldStart("status")
		s.Status.Encode(e)
	}
	{
		if s.CertificateSerialNumber.Set {
			e.FieldStart("certificateSerialNumber")
			s.CertificateSerialNumber.Encode(e)
		}
	}
}

var jsonFieldsNameOfCertificateEnrollmentStatusResponse = [3]string{
	0: "requestDate",
	1: "status",
	2: "certificateSerialNumber",
}

// Decode decodes CertificateEnrollmentStatusResponse from json.
func (s *CertificateEnrollmentStatusResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CertificateEnrollmentStatusResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "requestDate":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.RequestDate = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requestDate\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "certificateSerialNumber":
			if err := func() error {
				s.CertificateSerialNumber.Reset()
				if err := s.CertificateSerialNumber.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"certificateSerialNumber\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CertificateEnrollmentStatusResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCertificateEnrollmentStatusResponse) {
					name = jsonFieldsNameOfCertificateEnrollmentStatusResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CertificateEnrollmentStatusResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CertificateEnrollmentStatusResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CertificateLimit) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CertificateLimit) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("remaining")
		e.Int32(s.Remaining)
	}
	{
		e.FieldStart("limit")
		e.Int32(s.Limit)
	}
}

var jsonFieldsNameOfCertificateLimit = [2]string{
	0: "remaining",
	1: "limit",
}

// Decode decodes CertificateLimit from json.
func (s *CertificateLimit) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CertificateLimit to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "remaining":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Remaining = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remaining\"")
			}
		case "limit":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int32()
				s.Limit = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"limit\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CertificateLimit")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCertificateLimit) {
					name = jsonFieldsNameOfCertificateLimit[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CertificateLimit) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CertificateLimit) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CertificateLimitsResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CertificateLimitsResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("canRequest")
		e.Bool(s.CanRequest)
	}
	{
		e.FieldStart("enrollment")
		s.Enrollment.Encode(e)
	}
	{
		e.FieldStart("certificate")
		s.Certificate.Encode(e)
	}
}

var jsonFieldsNameOfCertificateLimitsResponse = [3]string{
	0: "canRequest",
	1: "enrollment",
	2: "certificate",
}

// Decode decodes CertificateLimitsResponse from json.
func (s *CertificateLimitsResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CertificateLimitsResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "canRequest":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.CanRequest = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"canRequest\"")
			}
		case "enrollment":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Enrollment.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enrollment\"")
			}
		case "certificate":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Certificate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"certificate\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CertificateLimitsResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCertificateLimitsResponse) {
					name = jsonFieldsNameOfCertificateLimitsResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CertificateLimitsResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CertificateLimitsResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CertificateListItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CertificateListItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("certificateSerialNumber")
		e.Str(s.CertificateSerialNumber)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("commonName")
		e.Str(s.CommonName)
	}
	{
		e.FieldStart("status")
		s.Status.Encode(e)
	}
	{
		e.FieldStart("subjectIdentifier")
		s.SubjectIdentifier.Encode(e)
	}
	{
		e.FieldStart("validFrom")
		json.EncodeDateTime(e, s.ValidFrom)
	}
	{
		e.FieldStart("validTo")
		json.EncodeDateTime(e, s.ValidTo)
	}
	{
		if s.LastUseDate.Set {
			e.FieldStart("lastUseDate")
			s.LastUseDate.Encode(e, json.EncodeDateTime)
		}
	}
	{
		e.FieldStart("requestDate")
		json.EncodeDateTime(e, s.RequestDate)
	}
}

var jsonFieldsNameOfCertificateListItem = [10]string{
	0: "certificateSerialNumber",
	1: "name",
	2: "type",
	3: "commonName",
	4: "status",
	5: "subjectIdentifier",
	6: "validFrom",
	7: "validTo",
	8: "lastUseDate",
	9: "requestDate",
}

// Decode decodes CertificateListItem from json.
func (s *CertificateListItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CertificateListItem to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "certificateSerialNumber":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.CertificateSerialNumber = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"certificateSerialNumber\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "commonName":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.CommonName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"commonName\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "subjectIdentifier":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.SubjectIdentifier.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subjectIdentifier\"")
			}
		case "validFrom":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.ValidFrom = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"validFrom\"")
			}
		case "validTo":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.ValidTo = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"validTo\"")
			}
		case "lastUseDate":
			if err := func() error {
				s.LastUseDate.Reset()
				if err := s.LastUseDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastUseDate\"")
			}
		case "requestDate":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.RequestDate = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requestDate\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CertificateListItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCertificateListItem) {
					name = jsonFieldsNameOfCertificateListItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CertificateListItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CertificateListItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CertificateListItemStatus as json.
func (s CertificateListItemStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CertificateListItemStatus from json.
func (s *CertificateListItemStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CertificateListItemStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CertificateListItemStatus(v) {
	case CertificateListItemStatusActive:
		*s = CertificateListItemStatusActive
	case CertificateListItemStatusBlocked:
		*s = CertificateListItemStatusBlocked
	case CertificateListItemStatusRevoked:
		*s = CertificateListItemStatusRevoked
	case CertificateListItemStatusExpired:
		*s = CertificateListItemStatusExpired
	default:
		*s = CertificateListItemStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CertificateListItemStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CertificateListItemStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CertificateRevocationReason as json.
func (s CertificateRevocationReason) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CertificateRevocationReason from json.
func (s *CertificateRevocationReason) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CertificateRevocationReason to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CertificateRevocationReason(v) {
	case CertificateRevocationReasonUnspecified:
		*s = CertificateRevocationReasonUnspecified
	case CertificateRevocationReasonSuperseded:
		*s = CertificateRevocationReasonSuperseded
	case CertificateRevocationReasonKeyCompromise:
		*s = CertificateRevocationReasonKeyCompromise
	default:
		*s = CertificateRevocationReason(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CertificateRevocationReason) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CertificateRevocationReason) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CertificateSubjectIdentifier) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CertificateSubjectIdentifier) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("value")
		e.Str(s.Value)
	}
}

var jsonFieldsNameOfCertificateSubjectIdentifier = [2]string{
	0: "type",
	1: "value",
}

// Decode decodes CertificateSubjectIdentifier from json.
func (s *CertificateSubjectIdentifier) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CertificateSubjectIdentifier to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "value":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Value = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CertificateSubjectIdentifier")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCertificateSubjectIdentifier) {
					name = jsonFieldsNameOfCertificateSubjectIdentifier[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CertificateSubjectIdentifier) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CertificateSubjectIdentifier) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CertificateSubjectIdentifierType as json.
func (s CertificateSubjectIdentifierType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CertificateSubjectIdentifierType from json.
func (s *CertificateSubjectIdentifierType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CertificateSubjectIdentifierType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CertificateSubjectIdentifierType(v) {
	case CertificateSubjectIdentifierTypeNip:
		*s = CertificateSubjectIdentifierTypeNip
	case CertificateSubjectIdentifierTypePesel:
		*s = CertificateSubjectIdentifierTypePesel
	case CertificateSubjectIdentifierTypeFingerprint:
		*s = CertificateSubjectIdentifierTypeFingerprint
	default:
		*s = CertificateSubjectIdentifierType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CertificateSubjectIdentifierType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CertificateSubjectIdentifierType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CertificateSubjectLimitsOverride) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CertificateSubjectLimitsOverride) encodeFields(e *jx.Encoder) {
	{
		if s.MaxCertificates.Set {
			e.FieldStart("maxCertificates")
			s.MaxCertificates.Encode(e)
		}
	}
}

var jsonFieldsNameOfCertificateSubjectLimitsOverride = [1]string{
	0: "maxCertificates",
}

// Decode decodes CertificateSubjectLimitsOverride from json.
func (s *CertificateSubjectLimitsOverride) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CertificateSubjectLimitsOverride to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "maxCertificates":
			if err := func() error {
				s.MaxCertificates.Reset()
				if err := s.MaxCertificates.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maxCertificates\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CertificateSubjectLimitsOverride")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CertificateSubjectLimitsOverride) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CertificateSubjectLimitsOverride) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Challenge as json.
func (s Challenge) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes Challenge from json.
func (s *Challenge) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Challenge to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = Challenge(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s Challenge) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Challenge) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CheckAttachmentPermissionStatusResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CheckAttachmentPermissionStatusResponse) encodeFields(e *jx.Encoder) {
	{
		if s.IsAttachmentAllowed.Set {
			e.FieldStart("isAttachmentAllowed")
			s.IsAttachmentAllowed.Encode(e)
		}
	}
	{
		if s.RevokedDate.Set {
			e.FieldStart("revokedDate")
			s.RevokedDate.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfCheckAttachmentPermissionStatusResponse = [2]string{
	0: "isAttachmentAllowed",
	1: "revokedDate",
}

// Decode decodes CheckAttachmentPermissionStatusResponse from json.
func (s *CheckAttachmentPermissionStatusResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CheckAttachmentPermissionStatusResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "isAttachmentAllowed":
			if err := func() error {
				s.IsAttachmentAllowed.Reset()
				if err := s.IsAttachmentAllowed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isAttachmentAllowed\"")
			}
		case "revokedDate":
			if err := func() error {
				s.RevokedDate.Reset()
				if err := s.RevokedDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"revokedDate\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CheckAttachmentPermissionStatusResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CheckAttachmentPermissionStatusResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CheckAttachmentPermissionStatusResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CurrencyCode as json.
func (s CurrencyCode) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CurrencyCode from json.
func (s *CurrencyCode) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CurrencyCode to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CurrencyCode(v) {
	case CurrencyCodeAED:
		*s = CurrencyCodeAED
	case CurrencyCodeAFN:
		*s = CurrencyCodeAFN
	case CurrencyCodeALL:
		*s = CurrencyCodeALL
	case CurrencyCodeAMD:
		*s = CurrencyCodeAMD
	case CurrencyCodeANG:
		*s = CurrencyCodeANG
	case CurrencyCodeAOA:
		*s = CurrencyCodeAOA
	case CurrencyCodeARS:
		*s = CurrencyCodeARS
	case CurrencyCodeAUD:
		*s = CurrencyCodeAUD
	case CurrencyCodeAWG:
		*s = CurrencyCodeAWG
	case CurrencyCodeAZN:
		*s = CurrencyCodeAZN
	case CurrencyCodeBAM:
		*s = CurrencyCodeBAM
	case CurrencyCodeBBD:
		*s = CurrencyCodeBBD
	case CurrencyCodeBDT:
		*s = CurrencyCodeBDT
	case CurrencyCodeBGN:
		*s = CurrencyCodeBGN
	case CurrencyCodeBHD:
		*s = CurrencyCodeBHD
	case CurrencyCodeBIF:
		*s = CurrencyCodeBIF
	case CurrencyCodeBMD:
		*s = CurrencyCodeBMD
	case CurrencyCodeBND:
		*s = CurrencyCodeBND
	case CurrencyCodeBOB:
		*s = CurrencyCodeBOB
	case CurrencyCodeBOV:
		*s = CurrencyCodeBOV
	case CurrencyCodeBRL:
		*s = CurrencyCodeBRL
	case CurrencyCodeBSD:
		*s = CurrencyCodeBSD
	case CurrencyCodeBTN:
		*s = CurrencyCodeBTN
	case CurrencyCodeBWP:
		*s = CurrencyCodeBWP
	case CurrencyCodeBYN:
		*s = CurrencyCodeBYN
	case CurrencyCodeBZD:
		*s = CurrencyCodeBZD
	case CurrencyCodeCAD:
		*s = CurrencyCodeCAD
	case CurrencyCodeCDF:
		*s = CurrencyCodeCDF
	case CurrencyCodeCHE:
		*s = CurrencyCodeCHE
	case CurrencyCodeCHF:
		*s = CurrencyCodeCHF
	case CurrencyCodeCHW:
		*s = CurrencyCodeCHW
	case CurrencyCodeCLF:
		*s = CurrencyCodeCLF
	case CurrencyCodeCLP:
		*s = CurrencyCodeCLP
	case CurrencyCodeCNY:
		*s = CurrencyCodeCNY
	case CurrencyCodeCOP:
		*s = CurrencyCodeCOP
	case CurrencyCodeCOU:
		*s = CurrencyCodeCOU
	case CurrencyCodeCRC:
		*s = CurrencyCodeCRC
	case CurrencyCodeCUC:
		*s = CurrencyCodeCUC
	case CurrencyCodeCUP:
		*s = CurrencyCodeCUP
	case CurrencyCodeCVE:
		*s = CurrencyCodeCVE
	case CurrencyCodeCZK:
		*s = CurrencyCodeCZK
	case CurrencyCodeDJF:
		*s = CurrencyCodeDJF
	case CurrencyCodeDKK:
		*s = CurrencyCodeDKK
	case CurrencyCodeDOP:
		*s = CurrencyCodeDOP
	case CurrencyCodeDZD:
		*s = CurrencyCodeDZD
	case CurrencyCodeEGP:
		*s = CurrencyCodeEGP
	case CurrencyCodeERN:
		*s = CurrencyCodeERN
	case CurrencyCodeETB:
		*s = CurrencyCodeETB
	case CurrencyCodeEUR:
		*s = CurrencyCodeEUR
	case CurrencyCodeFJD:
		*s = CurrencyCodeFJD
	case CurrencyCodeFKP:
		*s = CurrencyCodeFKP
	case CurrencyCodeGBP:
		*s = CurrencyCodeGBP
	case CurrencyCodeGEL:
		*s = CurrencyCodeGEL
	case CurrencyCodeGGP:
		*s = CurrencyCodeGGP
	case CurrencyCodeGHS:
		*s = CurrencyCodeGHS
	case CurrencyCodeGIP:
		*s = CurrencyCodeGIP
	case CurrencyCodeGMD:
		*s = CurrencyCodeGMD
	case CurrencyCodeGNF:
		*s = CurrencyCodeGNF
	case CurrencyCodeGTQ:
		*s = CurrencyCodeGTQ
	case CurrencyCodeGYD:
		*s = CurrencyCodeGYD
	case CurrencyCodeHKD:
		*s = CurrencyCodeHKD
	case CurrencyCodeHNL:
		*s = CurrencyCodeHNL
	case CurrencyCodeHRK:
		*s = CurrencyCodeHRK
	case CurrencyCodeHTG:
		*s = CurrencyCodeHTG
	case CurrencyCodeHUF:
		*s = CurrencyCodeHUF
	case CurrencyCodeIDR:
		*s = CurrencyCodeIDR
	case CurrencyCodeILS:
		*s = CurrencyCodeILS
	case CurrencyCodeIMP:
		*s = CurrencyCodeIMP
	case CurrencyCodeINR:
		*s = CurrencyCodeINR
	case CurrencyCodeIQD:
		*s = CurrencyCodeIQD
	case CurrencyCodeIRR:
		*s = CurrencyCodeIRR
	case CurrencyCodeISK:
		*s = CurrencyCodeISK
	case CurrencyCodeJEP:
		*s = CurrencyCodeJEP
	case CurrencyCodeJMD:
		*s = CurrencyCodeJMD
	case CurrencyCodeJOD:
		*s = CurrencyCodeJOD
	case CurrencyCodeJPY:
		*s = CurrencyCodeJPY
	case CurrencyCodeKES:
		*s = CurrencyCodeKES
	case CurrencyCodeKGS:
		*s = CurrencyCodeKGS
	case CurrencyCodeKHR:
		*s = CurrencyCodeKHR
	case CurrencyCodeKMF:
		*s = CurrencyCodeKMF
	case CurrencyCodeKPW:
		*s = CurrencyCodeKPW
	case CurrencyCodeKRW:
		*s = CurrencyCodeKRW
	case CurrencyCodeKWD:
		*s = CurrencyCodeKWD
	case CurrencyCodeKYD:
		*s = CurrencyCodeKYD
	case CurrencyCodeKZT:
		*s = CurrencyCodeKZT
	case CurrencyCodeLAK:
		*s = CurrencyCodeLAK
	case CurrencyCodeLBP:
		*s = CurrencyCodeLBP
	case CurrencyCodeLKR:
		*s = CurrencyCodeLKR
	case CurrencyCodeLRD:
		*s = CurrencyCodeLRD
	case CurrencyCodeLSL:
		*s = CurrencyCodeLSL
	case CurrencyCodeLYD:
		*s = CurrencyCodeLYD
	case CurrencyCodeMAD:
		*s = CurrencyCodeMAD
	case CurrencyCodeMDL:
		*s = CurrencyCodeMDL
	case CurrencyCodeMGA:
		*s = CurrencyCodeMGA
	case CurrencyCodeMKD:
		*s = CurrencyCodeMKD
	case CurrencyCodeMMK:
		*s = CurrencyCodeMMK
	case CurrencyCodeMNT:
		*s = CurrencyCodeMNT
	case CurrencyCodeMOP:
		*s = CurrencyCodeMOP
	case CurrencyCodeMRU:
		*s = CurrencyCodeMRU
	case CurrencyCodeMUR:
		*s = CurrencyCodeMUR
	case CurrencyCodeMVR:
		*s = CurrencyCodeMVR
	case CurrencyCodeMWK:
		*s = CurrencyCodeMWK
	case CurrencyCodeMXN:
		*s = CurrencyCodeMXN
	case CurrencyCodeMXV:
		*s = CurrencyCodeMXV
	case CurrencyCodeMYR:
		*s = CurrencyCodeMYR
	case CurrencyCodeMZN:
		*s = CurrencyCodeMZN
	case CurrencyCodeNAD:
		*s = CurrencyCodeNAD
	case CurrencyCodeNGN:
		*s = CurrencyCodeNGN
	case CurrencyCodeNIO:
		*s = CurrencyCodeNIO
	case CurrencyCodeNOK:
		*s = CurrencyCodeNOK
	case CurrencyCodeNPR:
		*s = CurrencyCodeNPR
	case CurrencyCodeNZD:
		*s = CurrencyCodeNZD
	case CurrencyCodeOMR:
		*s = CurrencyCodeOMR
	case CurrencyCodePAB:
		*s = CurrencyCodePAB
	case CurrencyCodePEN:
		*s = CurrencyCodePEN
	case CurrencyCodePGK:
		*s = CurrencyCodePGK
	case CurrencyCodePHP:
		*s = CurrencyCodePHP
	case CurrencyCodePKR:
		*s = CurrencyCodePKR
	case CurrencyCodePLN:
		*s = CurrencyCodePLN
	case CurrencyCodePYG:
		*s = CurrencyCodePYG
	case CurrencyCodeQAR:
		*s = CurrencyCodeQAR
	case CurrencyCodeRON:
		*s = CurrencyCodeRON
	case CurrencyCodeRSD:
		*s = CurrencyCodeRSD
	case CurrencyCodeRUB:
		*s = CurrencyCodeRUB
	case CurrencyCodeRWF:
		*s = CurrencyCodeRWF
	case CurrencyCodeSAR:
		*s = CurrencyCodeSAR
	case CurrencyCodeSBD:
		*s = CurrencyCodeSBD
	case CurrencyCodeSCR:
		*s = CurrencyCodeSCR
	case CurrencyCodeSDG:
		*s = CurrencyCodeSDG
	case CurrencyCodeSEK:
		*s = CurrencyCodeSEK
	case CurrencyCodeSGD:
		*s = CurrencyCodeSGD
	case CurrencyCodeSHP:
		*s = CurrencyCodeSHP
	case CurrencyCodeSLL:
		*s = CurrencyCodeSLL
	case CurrencyCodeSOS:
		*s = CurrencyCodeSOS
	case CurrencyCodeSRD:
		*s = CurrencyCodeSRD
	case CurrencyCodeSSP:
		*s = CurrencyCodeSSP
	case CurrencyCodeSTN:
		*s = CurrencyCodeSTN
	case CurrencyCodeSVC:
		*s = CurrencyCodeSVC
	case CurrencyCodeSYP:
		*s = CurrencyCodeSYP
	case CurrencyCodeSZL:
		*s = CurrencyCodeSZL
	case CurrencyCodeTHB:
		*s = CurrencyCodeTHB
	case CurrencyCodeTJS:
		*s = CurrencyCodeTJS
	case CurrencyCodeTMT:
		*s = CurrencyCodeTMT
	case CurrencyCodeTND:
		*s = CurrencyCodeTND
	case CurrencyCodeTOP:
		*s = CurrencyCodeTOP
	case CurrencyCodeTRY:
		*s = CurrencyCodeTRY
	case CurrencyCodeTTD:
		*s = CurrencyCodeTTD
	case CurrencyCodeTWD:
		*s = CurrencyCodeTWD
	case CurrencyCodeTZS:
		*s = CurrencyCodeTZS
	case CurrencyCodeUAH:
		*s = CurrencyCodeUAH
	case CurrencyCodeUGX:
		*s = CurrencyCodeUGX
	case CurrencyCodeUSD:
		*s = CurrencyCodeUSD
	case CurrencyCodeUSN:
		*s = CurrencyCodeUSN
	case CurrencyCodeUYI:
		*s = CurrencyCodeUYI
	case CurrencyCodeUYU:
		*s = CurrencyCodeUYU
	case CurrencyCodeUYW:
		*s = CurrencyCodeUYW
	case CurrencyCodeUZS:
		*s = CurrencyCodeUZS
	case CurrencyCodeVES:
		*s = CurrencyCodeVES
	case CurrencyCodeVND:
		*s = CurrencyCodeVND
	case CurrencyCodeVUV:
		*s = CurrencyCodeVUV
	case CurrencyCodeWST:
		*s = CurrencyCodeWST
	case CurrencyCodeXAF:
		*s = CurrencyCodeXAF
	case CurrencyCodeXAG:
		*s = CurrencyCodeXAG
	case CurrencyCodeXAU:
		*s = CurrencyCodeXAU
	case CurrencyCodeXBA:
		*s = CurrencyCodeXBA
	case CurrencyCodeXBB:
		*s = CurrencyCodeXBB
	case CurrencyCodeXBC:
		*s = CurrencyCodeXBC
	case CurrencyCodeXBD:
		*s = CurrencyCodeXBD
	case CurrencyCodeXCD:
		*s = CurrencyCodeXCD
	case CurrencyCodeXCG:
		*s = CurrencyCodeXCG
	case CurrencyCodeXDR:
		*s = CurrencyCodeXDR
	case CurrencyCodeXOF:
		*s = CurrencyCodeXOF
	case CurrencyCodeXPD:
		*s = CurrencyCodeXPD
	case CurrencyCodeXPF:
		*s = CurrencyCodeXPF
	case CurrencyCodeXPT:
		*s = CurrencyCodeXPT
	case CurrencyCodeXSU:
		*s = CurrencyCodeXSU
	case CurrencyCodeXUA:
		*s = CurrencyCodeXUA
	case CurrencyCodeXXX:
		*s = CurrencyCodeXXX
	case CurrencyCodeYER:
		*s = CurrencyCodeYER
	case CurrencyCodeZAR:
		*s = CurrencyCodeZAR
	case CurrencyCodeZMW:
		*s = CurrencyCodeZMW
	case CurrencyCodeZWL:
		*s = CurrencyCodeZWL
	default:
		*s = CurrencyCode(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CurrencyCode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CurrencyCode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EffectiveApiRateLimitValues) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EffectiveApiRateLimitValues) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("perSecond")
		e.Int32(s.PerSecond)
	}
	{
		e.FieldStart("perMinute")
		e.Int32(s.PerMinute)
	}
	{
		e.FieldStart("perHour")
		e.Int32(s.PerHour)
	}
}

var jsonFieldsNameOfEffectiveApiRateLimitValues = [3]string{
	0: "perSecond",
	1: "perMinute",
	2: "perHour",
}

// Decode decodes EffectiveApiRateLimitValues from json.
func (s *EffectiveApiRateLimitValues) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EffectiveApiRateLimitValues to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "perSecond":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.PerSecond = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"perSecond\"")
			}
		case "perMinute":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int32()
				s.PerMinute = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"perMinute\"")
			}
		case "perHour":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int32()
				s.PerHour = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"perHour\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EffectiveApiRateLimitValues")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEffectiveApiRateLimitValues) {
					name = jsonFieldsNameOfEffectiveApiRateLimitValues[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EffectiveApiRateLimitValues) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EffectiveApiRateLimitValues) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EffectiveApiRateLimits) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EffectiveApiRateLimits) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("onlineSession")
		s.OnlineSession.Encode(e)
	}
	{
		e.FieldStart("batchSession")
		s.BatchSession.Encode(e)
	}
	{
		e.FieldStart("invoiceSend")
		s.InvoiceSend.Encode(e)
	}
	{
		e.FieldStart("invoiceStatus")
		s.InvoiceStatus.Encode(e)
	}
	{
		e.FieldStart("sessionList")
		s.SessionList.Encode(e)
	}
	{
		e.FieldStart("sessionInvoiceList")
		s.SessionInvoiceList.Encode(e)
	}
	{
		e.FieldStart("sessionMisc")
		s.SessionMisc.Encode(e)
	}
	{
		e.FieldStart("invoiceMetadata")
		s.InvoiceMetadata.Encode(e)
	}
	{
		e.FieldStart("invoiceExport")
		s.InvoiceExport.Encode(e)
	}
	{
		e.FieldStart("invoiceDownload")
		s.InvoiceDownload.Encode(e)
	}
	{
		e.FieldStart("other")
		s.Other.Encode(e)
	}
}

var jsonFieldsNameOfEffectiveApiRateLimits = [11]string{
	0:  "onlineSession",
	1:  "batchSession",
	2:  "invoiceSend",
	3:  "invoiceStatus",
	4:  "sessionList",
	5:  "sessionInvoiceList",
	6:  "sessionMisc",
	7:  "invoiceMetadata",
	8:  "invoiceExport",
	9:  "invoiceDownload",
	10: "other",
}

// Decode decodes EffectiveApiRateLimits from json.
func (s *EffectiveApiRateLimits) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EffectiveApiRateLimits to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "onlineSession":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.OnlineSession.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"onlineSession\"")
			}
		case "batchSession":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.BatchSession.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"batchSession\"")
			}
		case "invoiceSend":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.InvoiceSend.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"invoiceSend\"")
			}
		case "invoiceStatus":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.InvoiceStatus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"invoiceStatus\"")
			}
		case "sessionList":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.SessionList.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sessionList\"")
			}
		case "sessionInvoiceList":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.SessionInvoiceList.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sessionInvoiceList\"")
			}
		case "sessionMisc":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.SessionMisc.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sessionMisc\"")
			}
		case "invoiceMetadata":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.InvoiceMetadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"invoiceMetadata\"")
			}
		case "invoiceExport":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.InvoiceExport.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"invoiceExport\"")
			}
		case "invoiceDownload":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.InvoiceDownload.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"invoiceDownload\"")
			}
		case "other":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				if err := s.Other.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"other\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EffectiveApiRateLimits")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEffectiveApiRateLimits) {
					name = jsonFieldsNameOfEffectiveApiRateLimits[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EffectiveApiRateLimits) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EffectiveApiRateLimits) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EffectiveContextLimits) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EffectiveContextLimits) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("onlineSession")
		s.OnlineSession.Encode(e)
	}
	{
		e.FieldStart("batchSession")
		s.BatchSession.Encode(e)
	}
}

var jsonFieldsNameOfEffectiveContextLimits = [2]string{
	0: "onlineSession",
	1: "batchSession",
}

// Decode decodes EffectiveContextLimits from json.
func (s *EffectiveContextLimits) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EffectiveContextLimits to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "onlineSession":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.OnlineSession.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"onlineSession\"")
			}
		case "batchSession":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.BatchSession.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"batchSession\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EffectiveContextLimits")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEffectiveContextLimits) {
					name = jsonFieldsNameOfEffectiveContextLimits[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EffectiveContextLimits) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EffectiveContextLimits) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EffectiveSubjectLimits) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EffectiveSubjectLimits) encodeFields(e *jx.Encoder) {
	{
		if s.Enrollment.Set {
			e.FieldStart("enrollment")
			s.Enrollment.Encode(e)
		}
	}
	{
		if s.Certificate.Set {
			e.FieldStart("certificate")
			s.Certificate.Encode(e)
		}
	}
}

var jsonFieldsNameOfEffectiveSubjectLimits = [2]string{
	0: "enrollment",
	1: "certificate",
}

// Decode decodes EffectiveSubjectLimits from json.
func (s *EffectiveSubjectLimits) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EffectiveSubjectLimits to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "enrollment":
			if err := func() error {
				s.Enrollment.Reset()
				if err := s.Enrollment.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enrollment\"")
			}
		case "certificate":
			if err := func() error {
				s.Certificate.Reset()
				if err := s.Certificate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"certificate\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EffectiveSubjectLimits")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EffectiveSubjectLimits) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EffectiveSubjectLimits) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EncryptionInfo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EncryptionInfo) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("encryptedSymmetricKey")
		e.Base64(s.EncryptedSymmetricKey)
	}
	{
		e.FieldStart("initializationVector")
		e.Base64(s.InitializationVector)
	}
}

var jsonFieldsNameOfEncryptionInfo = [2]string{
	0: "encryptedSymmetricKey",
	1: "initializationVector",
}

// Decode decodes EncryptionInfo from json.
func (s *EncryptionInfo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EncryptionInfo to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "encryptedSymmetricKey":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Base64()
				s.EncryptedSymmetricKey = []byte(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"encryptedSymmetricKey\"")
			}
		case "initializationVector":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Base64()
				s.InitializationVector = []byte(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"initializationVector\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EncryptionInfo")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEncryptionInfo) {
					name = jsonFieldsNameOfEncryptionInfo[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EncryptionInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EncryptionInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EnrollCertificateRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EnrollCertificateRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("certificateName")
		e.Str(s.CertificateName)
	}
	{
		e.FieldStart("certificateType")
		s.CertificateType.Encode(e)
	}
	{
		e.FieldStart("csr")
		e.Base64(s.Csr)
	}
	{
		if s.ValidFrom.Set {
			e.FieldStart("validFrom")
			s.ValidFrom.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfEnrollCertificateRequest = [4]string{
	0: "certificateName",
	1: "certificateType",
	2: "csr",
	3: "validFrom",
}

// Decode decodes EnrollCertificateRequest from json.
func (s *EnrollCertificateRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnrollCertificateRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "certificateName":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.CertificateName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"certificateName\"")
			}
		case "certificateType":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.CertificateType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"certificateType\"")
			}
		case "csr":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Base64()
				s.Csr = []byte(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"csr\"")
			}
		case "validFrom":
			if err := func() error {
				s.ValidFrom.Reset()
				if err := s.ValidFrom.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"validFrom\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EnrollCertificateRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEnrollCertificateRequest) {
					name = jsonFieldsNameOfEnrollCertificateRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EnrollCertificateRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EnrollCertificateRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EnrollCertificateResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EnrollCertificateResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("referenceNumber")
		s.ReferenceNumber.Encode(e)
	}
	{
		e.FieldStart("timestamp")
		json.EncodeDateTime(e, s.Timestamp)
	}
}

var jsonFieldsNameOfEnrollCertificateResponse = [2]string{
	0: "referenceNumber",
	1: "timestamp",
}

// Decode decodes EnrollCertificateResponse from json.
func (s *EnrollCertificateResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnrollCertificateResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "referenceNumber":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ReferenceNumber.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"referenceNumber\"")
			}
		case "timestamp":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.Timestamp = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EnrollCertificateResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEnrollCertificateResponse) {
					name = jsonFieldsNameOfEnrollCertificateResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EnrollCertificateResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EnrollCertificateResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EnrollmentEffectiveSubjectLimits) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EnrollmentEffectiveSubjectLimits) encodeFields(e *jx.Encoder) {
	{
		if s.MaxEnrollments.Set {
			e.FieldStart("maxEnrollments")
			s.MaxEnrollments.Encode(e)
		}
	}
}

var jsonFieldsNameOfEnrollmentEffectiveSubjectLimits = [1]string{
	0: "maxEnrollments",
}

// Decode decodes EnrollmentEffectiveSubjectLimits from json.
func (s *EnrollmentEffectiveSubjectLimits) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnrollmentEffectiveSubjectLimits to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "maxEnrollments":
			if err := func() error {
				s.MaxEnrollments.Reset()
				if err := s.MaxEnrollments.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maxEnrollments\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EnrollmentEffectiveSubjectLimits")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EnrollmentEffectiveSubjectLimits) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EnrollmentEffectiveSubjectLimits) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EnrollmentSubjectLimitsOverride) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EnrollmentSubjectLimitsOverride) encodeFields(e *jx.Encoder) {
	{
		if s.MaxEnrollments.Set {
			e.FieldStart("maxEnrollments")
			s.MaxEnrollments.Encode(e)
		}
	}
}

var jsonFieldsNameOfEnrollmentSubjectLimitsOverride = [1]string{
	0: "maxEnrollments",
}

// Decode decodes EnrollmentSubjectLimitsOverride from json.
func (s *EnrollmentSubjectLimitsOverride) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnrollmentSubjectLimitsOverride to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "maxEnrollments":
			if err := func() error {
				s.MaxEnrollments.Reset()
				if err := s.MaxEnrollments.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maxEnrollments\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EnrollmentSubjectLimitsOverride")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EnrollmentSubjectLimitsOverride) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EnrollmentSubjectLimitsOverride) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EntityAuthorizationGrant) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EntityAuthorizationGrant) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		s.ID.Encode(e)
	}
	{
		if s.AuthorIdentifier.Set {
			e.FieldStart("authorIdentifier")
			s.AuthorIdentifier.Encode(e)
		}
	}
	{
		e.FieldStart("authorizedEntityIdentifier")
		s.AuthorizedEntityIdentifier.Encode(e)
	}
	{
		e.FieldStart("authorizingEntityIdentifier")
		s.AuthorizingEntityIdentifier.Encode(e)
	}
	{
		e.FieldStart("authorizationScope")
		s.AuthorizationScope.Encode(e)
	}
	{
		e.FieldStart("description")
		e.Str(s.Description)
	}
	{
		e.FieldStart("startDate")
		json.EncodeDateTime(e, s.StartDate)
	}
}

var jsonFieldsNameOfEntityAuthorizationGrant = [7]string{
	0: "id",
	1: "authorIdentifier",
	2: "authorizedEntityIdentifier",
	3: "authorizingEntityIdentifier",
	4: "authorizationScope",
	5: "description",
	6: "startDate",
}

// Decode decodes EntityAuthorizationGrant from json.
func (s *EntityAuthorizationGrant) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EntityAuthorizationGrant to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "authorIdentifier":
			if err := func() error {
				s.AuthorIdentifier.Reset()
				if err := s.AuthorIdentifier.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"authorIdentifier\"")
			}
		case "authorizedEntityIdentifier":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.AuthorizedEntityIdentifier.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"authorizedEntityIdentifier\"")
			}
		case "authorizingEntityIdentifier":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.AuthorizingEntityIdentifier.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"authorizingEntityIdentifier\"")
			}
		case "authorizationScope":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.AuthorizationScope.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"authorizationScope\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "startDate":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.StartDate = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"startDate\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EntityAuthorizationGrant")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01111101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEntityAuthorizationGrant) {
					name = jsonFieldsNameOfEntityAuthorizationGrant[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EntityAuthorizationGrant) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EntityAuthorizationGrant) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EntityAuthorizationPermissionType as json.
func (s EntityAuthorizationPermissionType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes EntityAuthorizationPermissionType from json.
func (s *EntityAuthorizationPermissionType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EntityAuthorizationPermissionType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch EntityAuthorizationPermissionType(v) {
	case EntityAuthorizationPermissionTypeSelfInvoicing:
		*s = EntityAuthorizationPermissionTypeSelfInvoicing
	case EntityAuthorizationPermissionTypeRRInvoicing:
		*s = EntityAuthorizationPermissionTypeRRInvoicing
	case EntityAuthorizationPermissionTypeTaxRepresentative:
		*s = EntityAuthorizationPermissionTypeTaxRepresentative
	case EntityAuthorizationPermissionTypePefInvoicing:
		*s = EntityAuthorizationPermissionTypePefInvoicing
	default:
		*s = EntityAuthorizationPermissionType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s EntityAuthorizationPermissionType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EntityAuthorizationPermissionType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EntityAuthorizationPermissionsGrantRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EntityAuthorizationPermissionsGrantRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("subjectIdentifier")
		s.SubjectIdentifier.Encode(e)
	}
	{
		e.FieldStart("permission")
		s.Permission.Encode(e)
	}
	{
		e.FieldStart("description")
		e.Str(s.Description)
	}
}

var jsonFieldsNameOfEntityAuthorizationPermissionsGrantRequest = [3]string{
	0: "subjectIdentifier",
	1: "permission",
	2: "description",
}

// Decode decodes EntityAuthorizationPermissionsGrantRequest from json.
func (s *EntityAuthorizationPermissionsGrantRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EntityAuthorizationPermissionsGrantRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "subjectIdentifier":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.SubjectIdentifier.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subjectIdentifier\"")
			}
		case "permission":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Permission.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"permission\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EntityAuthorizationPermissionsGrantRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEntityAuthorizationPermissionsGrantRequest) {
					name = jsonFieldsNameOfEntityAuthorizationPermissionsGrantRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EntityAuthorizationPermissionsGrantRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EntityAuthorizationPermissionsGrantRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EntityAuthorizationPermissionsQueryRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EntityAuthorizationPermissionsQueryRequest) encodeFields(e *jx.Encoder) {
	{
		if s.AuthorizingIdentifier.Set {
			e.FieldStart("authorizingIdentifier")
			s.AuthorizingIdentifier.Encode(e)
		}
	}
	{
		if s.AuthorizedIdentifier.Set {
			e.FieldStart("authorizedIdentifier")
			s.AuthorizedIdentifier.Encode(e)
		}
	}
	{
		e.FieldStart("queryType")
		s.QueryType.Encode(e)
	}
	{
		if s.PermissionTypes.Set {
			e.FieldStart("permissionTypes")
			s.PermissionTypes.Encode(e)
		}
	}
}

var jsonFieldsNameOfEntityAuthorizationPermissionsQueryRequest = [4]string{
	0: "authorizingIdentifier",
	1: "authorizedIdentifier",
	2: "queryType",
	3: "permissionTypes",
}

// Decode decodes EntityAuthorizationPermissionsQueryRequest from json.
func (s *EntityAuthorizationPermissionsQueryRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EntityAuthorizationPermissionsQueryRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "authorizingIdentifier":
			if err := func() error {
				s.AuthorizingIdentifier.Reset()
				if err := s.AuthorizingIdentifier.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"authorizingIdentifier\"")
			}
		case "authorizedIdentifier":
			if err := func() error {
				s.AuthorizedIdentifier.Reset()
				if err := s.AuthorizedIdentifier.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"authorizedIdentifier\"")
			}
		case "queryType":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.QueryType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"queryType\"")
			}
		case "permissionTypes":
			if err := func() error {
				s.PermissionTypes.Reset()
				if err := s.PermissionTypes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"permissionTypes\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EntityAuthorizationPermissionsQueryRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEntityAuthorizationPermissionsQueryRequest) {
					name = jsonFieldsNameOfEntityAuthorizationPermissionsQueryRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EntityAuthorizationPermissionsQueryRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EntityAuthorizationPermissionsQueryRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EntityAuthorizationPermissionsSubjectIdentifier) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EntityAuthorizationPermissionsSubjectIdentifier) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("value")
		e.Str(s.Value)
	}
}

var jsonFieldsNameOfEntityAuthorizationPermissionsSubjectIdentifier = [2]string{
	0: "type",
	1: "value",
}

// Decode decodes EntityAuthorizationPermissionsSubjectIdentifier from json.
func (s *EntityAuthorizationPermissionsSubjectIdentifier) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EntityAuthorizationPermissionsSubjectIdentifier to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "value":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Value = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EntityAuthorizationPermissionsSubjectIdentifier")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEntityAuthorizationPermissionsSubjectIdentifier) {
					name = jsonFieldsNameOfEntityAuthorizationPermissionsSubjectIdentifier[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EntityAuthorizationPermissionsSubjectIdentifier) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EntityAuthorizationPermissionsSubjectIdentifier) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EntityAuthorizationPermissionsSubjectIdentifierType as json.
func (s EntityAuthorizationPermissionsSubjectIdentifierType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes EntityAuthorizationPermissionsSubjectIdentifierType from json.
func (s *EntityAuthorizationPermissionsSubjectIdentifierType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EntityAuthorizationPermissionsSubjectIdentifierType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch EntityAuthorizationPermissionsSubjectIdentifierType(v) {
	case EntityAuthorizationPermissionsSubjectIdentifierTypeNip:
		*s = EntityAuthorizationPermissionsSubjectIdentifierTypeNip
	case EntityAuthorizationPermissionsSubjectIdentifierTypePeppolId:
		*s = EntityAuthorizationPermissionsSubjectIdentifierTypePeppolId
	default:
		*s = EntityAuthorizationPermissionsSubjectIdentifierType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s EntityAuthorizationPermissionsSubjectIdentifierType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EntityAuthorizationPermissionsSubjectIdentifierType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EntityAuthorizationsAuthorIdentifier) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EntityAuthorizationsAuthorIdentifier) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("value")
		e.Str(s.Value)
	}
}

var jsonFieldsNameOfEntityAuthorizationsAuthorIdentifier = [2]string{
	0: "type",
	1: "value",
}

// Decode decodes EntityAuthorizationsAuthorIdentifier from json.
func (s *EntityAuthorizationsAuthorIdentifier) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EntityAuthorizationsAuthorIdentifier to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "value":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Value = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EntityAuthorizationsAuthorIdentifier")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEntityAuthorizationsAuthorIdentifier) {
					name = jsonFieldsNameOfEntityAuthorizationsAuthorIdentifier[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EntityAuthorizationsAuthorIdentifier) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EntityAuthorizationsAuthorIdentifier) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EntityAuthorizationsAuthorIdentifierType as json.
func (s EntityAuthorizationsAuthorIdentifierType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes EntityAuthorizationsAuthorIdentifierType from json.
func (s *EntityAuthorizationsAuthorIdentifierType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EntityAuthorizationsAuthorIdentifierType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch EntityAuthorizationsAuthorIdentifierType(v) {
	case EntityAuthorizationsAuthorIdentifierTypeNip:
		*s = EntityAuthorizationsAuthorIdentifierTypeNip
	case EntityAuthorizationsAuthorIdentifierTypePesel:
		*s = EntityAuthorizationsAuthorIdentifierTypePesel
	case EntityAuthorizationsAuthorIdentifierTypeFingerprint:
		*s = EntityAuthorizationsAuthorIdentifierTypeFingerprint
	default:
		*s = EntityAuthorizationsAuthorIdentifierType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s EntityAuthorizationsAuthorIdentifierType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EntityAuthorizationsAuthorIdentifierType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EntityAuthorizationsAuthorizedEntityIdentifier) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EntityAuthorizationsAuthorizedEntityIdentifier) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("value")
		e.Str(s.Value)
	}
}

var jsonFieldsNameOfEntityAuthorizationsAuthorizedEntityIdentifier = [2]string{
	0: "type",
	1: "value",
}

// Decode decodes EntityAuthorizationsAuthorizedEntityIdentifier from json.
func (s *EntityAuthorizationsAuthorizedEntityIdentifier) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EntityAuthorizationsAuthorizedEntityIdentifier to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "value":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Value = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EntityAuthorizationsAuthorizedEntityIdentifier")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEntityAuthorizationsAuthorizedEntityIdentifier) {
					name = jsonFieldsNameOfEntityAuthorizationsAuthorizedEntityIdentifier[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EntityAuthorizationsAuthorizedEntityIdentifier) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EntityAuthorizationsAuthorizedEntityIdentifier) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EntityAuthorizationsAuthorizedEntityIdentifierType as json.
func (s EntityAuthorizationsAuthorizedEntityIdentifierType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes EntityAuthorizationsAuthorizedEntityIdentifierType from json.
func (s *EntityAuthorizationsAuthorizedEntityIdentifierType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EntityAuthorizationsAuthorizedEntityIdentifierType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch EntityAuthorizationsAuthorizedEntityIdentifierType(v) {
	case EntityAuthorizationsAuthorizedEntityIdentifierTypeNip:
		*s = EntityAuthorizationsAuthorizedEntityIdentifierTypeNip
	case EntityAuthorizationsAuthorizedEntityIdentifierTypePeppolId:
		*s = EntityAuthorizationsAuthorizedEntityIdentifierTypePeppolId
	default:
		*s = EntityAuthorizationsAuthorizedEntityIdentifierType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s EntityAuthorizationsAuthorizedEntityIdentifierType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EntityAuthorizationsAuthorizedEntityIdentifierType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EntityAuthorizationsAuthorizingEntityIdentifier) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EntityAuthorizationsAuthorizingEntityIdentifier) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("value")
		e.Str(s.Value)
	}
}

var jsonFieldsNameOfEntityAuthorizationsAuthorizingEntityIdentifier = [2]string{
	0: "type",
	1: "value",
}

// Decode decodes EntityAuthorizationsAuthorizingEntityIdentifier from json.
func (s *EntityAuthorizationsAuthorizingEntityIdentifier) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EntityAuthorizationsAuthorizingEntityIdentifier to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "value":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Value = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EntityAuthorizationsAuthorizingEntityIdentifier")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEntityAuthorizationsAuthorizingEntityIdentifier) {
					name = jsonFieldsNameOfEntityAuthorizationsAuthorizingEntityIdentifier[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EntityAuthorizationsAuthorizingEntityIdentifier) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EntityAuthorizationsAuthorizingEntityIdentifier) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EntityAuthorizationsAuthorizingEntityIdentifierType as json.
func (s EntityAuthorizationsAuthorizingEntityIdentifierType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes EntityAuthorizationsAuthorizingEntityIdentifierType from json.
func (s *EntityAuthorizationsAuthorizingEntityIdentifierType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EntityAuthorizationsAuthorizingEntityIdentifierType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch EntityAuthorizationsAuthorizingEntityIdentifierType(v) {
	case EntityAuthorizationsAuthorizingEntityIdentifierTypeNip:
		*s = EntityAuthorizationsAuthorizingEntityIdentifierTypeNip
	default:
		*s = EntityAuthorizationsAuthorizingEntityIdentifierType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s EntityAuthorizationsAuthorizingEntityIdentifierType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EntityAuthorizationsAuthorizingEntityIdentifierType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EntityPermission) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EntityPermission) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		if s.CanDelegate.Set {
			e.FieldStart("canDelegate")
			s.CanDelegate.Encode(e)
		}
	}
}

var jsonFieldsNameOfEntityPermission = [2]string{
	0: "type",
	1: "canDelegate",
}

// Decode decodes EntityPermission from json.
func (s *EntityPermission) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EntityPermission to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "canDelegate":
			if err := func() error {
				s.CanDelegate.Reset()
				if err := s.CanDelegate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"canDelegate\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EntityPermission")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEntityPermission) {
					name = jsonFieldsNameOfEntityPermission[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EntityPermission) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EntityPermission) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EntityPermissionType as json.
func (s EntityPermissionType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes EntityPermissionType from json.
func (s *EntityPermissionType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EntityPermissionType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch EntityPermissionType(v) {
	case EntityPermissionTypeInvoiceWrite:
		*s = EntityPermissionTypeInvoiceWrite
	case EntityPermissionTypeInvoiceRead:
		*s = EntityPermissionTypeInvoiceRead
	default:
		*s = EntityPermissionType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s EntityPermissionType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EntityPermissionType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EntityPermissionsGrantRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EntityPermissionsGrantRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("subjectIdentifier")
		s.SubjectIdentifier.Encode(e)
	}
	{
		e.FieldStart("permissions")
		e.ArrStart()
		for _, elem := range s.Permissions {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("description")
		e.Str(s.Description)
	}
}

var jsonFieldsNameOfEntityPermissionsGrantRequest = [3]string{
	0: "subjectIdentifier",
	1: "permissions",
	2: "description",
}

// Decode decodes EntityPermissionsGrantRequest from json.
func (s *EntityPermissionsGrantRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EntityPermissionsGrantRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "subjectIdentifier":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.SubjectIdentifier.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subjectIdentifier\"")
			}
		case "permissions":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Permissions = make([]EntityPermission, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem EntityPermission
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Permissions = append(s.Permissions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"permissions\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EntityPermissionsGrantRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEntityPermissionsGrantRequest) {
					name = jsonFieldsNameOfEntityPermissionsGrantRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EntityPermissionsGrantRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EntityPermissionsGrantRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EntityPermissionsSubjectIdentifier) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EntityPermissionsSubjectIdentifier) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("value")
		e.Str(s.Value)
	}
}

var jsonFieldsNameOfEntityPermissionsSubjectIdentifier = [2]string{
	0: "type",
	1: "value",
}

// Decode decodes EntityPermissionsSubjectIdentifier from json.
func (s *EntityPermissionsSubjectIdentifier) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EntityPermissionsSubjectIdentifier to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "value":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Value = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EntityPermissionsSubjectIdentifier")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEntityPermissionsSubjectIdentifier) {
					name = jsonFieldsNameOfEntityPermissionsSubjectIdentifier[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EntityPermissionsSubjectIdentifier) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EntityPermissionsSubjectIdentifier) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EntityPermissionsSubjectIdentifierType as json.
func (s EntityPermissionsSubjectIdentifierType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes EntityPermissionsSubjectIdentifierType from json.
func (s *EntityPermissionsSubjectIdentifierType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EntityPermissionsSubjectIdentifierType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch EntityPermissionsSubjectIdentifierType(v) {
	case EntityPermissionsSubjectIdentifierTypeNip:
		*s = EntityPermissionsSubjectIdentifierTypeNip
	default:
		*s = EntityPermissionsSubjectIdentifierType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s EntityPermissionsSubjectIdentifierType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EntityPermissionsSubjectIdentifierType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EntityPermissionsSubordinateEntityIdentifier) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EntityPermissionsSubordinateEntityIdentifier) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("value")
		e.Str(s.Value)
	}
}

var jsonFieldsNameOfEntityPermissionsSubordinateEntityIdentifier = [2]string{
	0: "type",
	1: "value",
}

// Decode decodes EntityPermissionsSubordinateEntityIdentifier from json.
func (s *EntityPermissionsSubordinateEntityIdentifier) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EntityPermissionsSubordinateEntityIdentifier to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "value":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Value = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EntityPermissionsSubordinateEntityIdentifier")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEntityPermissionsSubordinateEntityIdentifier) {
					name = jsonFieldsNameOfEntityPermissionsSubordinateEntityIdentifier[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EntityPermissionsSubordinateEntityIdentifier) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EntityPermissionsSubordinateEntityIdentifier) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EntityPermissionsSubordinateEntityIdentifierType as json.
func (s EntityPermissionsSubordinateEntityIdentifierType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes EntityPermissionsSubordinateEntityIdentifierType from json.
func (s *EntityPermissionsSubordinateEntityIdentifierType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EntityPermissionsSubordinateEntityIdentifierType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch EntityPermissionsSubordinateEntityIdentifierType(v) {
	case EntityPermissionsSubordinateEntityIdentifierTypeNip:
		*s = EntityPermissionsSubordinateEntityIdentifierTypeNip
	default:
		*s = EntityPermissionsSubordinateEntityIdentifierType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s EntityPermissionsSubordinateEntityIdentifierType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EntityPermissionsSubordinateEntityIdentifierType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EntityRole) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EntityRole) encodeFields(e *jx.Encoder) {
	{
		if s.ParentEntityIdentifier.Set {
			e.FieldStart("parentEntityIdentifier")
			s.ParentEntityIdentifier.Encode(e)
		}
	}
	{
		e.FieldStart("role")
		s.Role.Encode(e)
	}
	{
		e.FieldStart("description")
		e.Str(s.Description)
	}
	{
		e.FieldStart("startDate")
		json.EncodeDateTime(e, s.StartDate)
	}
}

var jsonFieldsNameOfEntityRole = [4]string{
	0: "parentEntityIdentifier",
	1: "role",
	2: "description",
	3: "startDate",
}

// Decode decodes EntityRole from json.
func (s *EntityRole) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EntityRole to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "parentEntityIdentifier":
			if err := func() error {
				s.ParentEntityIdentifier.Reset()
				if err := s.ParentEntityIdentifier.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parentEntityIdentifier\"")
			}
		case "role":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Role.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"role\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "startDate":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.StartDate = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"startDate\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EntityRole")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEntityRole) {
					name = jsonFieldsNameOfEntityRole[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EntityRole) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EntityRole) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EntityRoleType as json.
func (s EntityRoleType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes EntityRoleType from json.
func (s *EntityRoleType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EntityRoleType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch EntityRoleType(v) {
	case EntityRoleTypeCourtBailiff:
		*s = EntityRoleTypeCourtBailiff
	case EntityRoleTypeEnforcementAuthority:
		*s = EntityRoleTypeEnforcementAuthority
	case EntityRoleTypeLocalGovernmentUnit:
		*s = EntityRoleTypeLocalGovernmentUnit
	case EntityRoleTypeLocalGovernmentSubUnit:
		*s = EntityRoleTypeLocalGovernmentSubUnit
	case EntityRoleTypeVatGroupUnit:
		*s = EntityRoleTypeVatGroupUnit
	case EntityRoleTypeVatGroupSubUnit:
		*s = EntityRoleTypeVatGroupSubUnit
	default:
		*s = EntityRoleType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s EntityRoleType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EntityRoleType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EntityRolesParentEntityIdentifier) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EntityRolesParentEntityIdentifier) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("value")
		e.Str(s.Value)
	}
}

var jsonFieldsNameOfEntityRolesParentEntityIdentifier = [2]string{
	0: "type",
	1: "value",
}

// Decode decodes EntityRolesParentEntityIdentifier from json.
func (s *EntityRolesParentEntityIdentifier) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EntityRolesParentEntityIdentifier to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "value":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Value = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EntityRolesParentEntityIdentifier")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEntityRolesParentEntityIdentifier) {
					name = jsonFieldsNameOfEntityRolesParentEntityIdentifier[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EntityRolesParentEntityIdentifier) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EntityRolesParentEntityIdentifier) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EntityRolesParentEntityIdentifierType as json.
func (s EntityRolesParentEntityIdentifierType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes EntityRolesParentEntityIdentifierType from json.
func (s *EntityRolesParentEntityIdentifierType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EntityRolesParentEntityIdentifierType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch EntityRolesParentEntityIdentifierType(v) {
	case EntityRolesParentEntityIdentifierTypeNip:
		*s = EntityRolesParentEntityIdentifierTypeNip
	default:
		*s = EntityRolesParentEntityIdentifierType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s EntityRolesParentEntityIdentifierType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EntityRolesParentEntityIdentifierType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EuEntityAdministrationPermissionsContextIdentifier) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EuEntityAdministrationPermissionsContextIdentifier) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("value")
		e.Str(s.Value)
	}
}

var jsonFieldsNameOfEuEntityAdministrationPermissionsContextIdentifier = [2]string{
	0: "type",
	1: "value",
}

// Decode decodes EuEntityAdministrationPermissionsContextIdentifier from json.
func (s *EuEntityAdministrationPermissionsContextIdentifier) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EuEntityAdministrationPermissionsContextIdentifier to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "value":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Value = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EuEntityAdministrationPermissionsContextIdentifier")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEuEntityAdministrationPermissionsContextIdentifier) {
					name = jsonFieldsNameOfEuEntityAdministrationPermissionsContextIdentifier[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EuEntityAdministrationPermissionsContextIdentifier) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EuEntityAdministrationPermissionsContextIdentifier) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EuEntityAdministrationPermissionsContextIdentifierType as json.
func (s EuEntityAdministrationPermissionsContextIdentifierType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes EuEntityAdministrationPermissionsContextIdentifierType from json.
func (s *EuEntityAdministrationPermissionsContextIdentifierType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EuEntityAdministrationPermissionsContextIdentifierType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch EuEntityAdministrationPermissionsContextIdentifierType(v) {
	case EuEntityAdministrationPermissionsContextIdentifierTypeNipVatUe:
		*s = EuEntityAdministrationPermissionsContextIdentifierTypeNipVatUe
	default:
		*s = EuEntityAdministrationPermissionsContextIdentifierType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s EuEntityAdministrationPermissionsContextIdentifierType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EuEntityAdministrationPermissionsContextIdentifierType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EuEntityAdministrationPermissionsGrantRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EuEntityAdministrationPermissionsGrantRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("subjectIdentifier")
		s.SubjectIdentifier.Encode(e)
	}
	{
		e.FieldStart("contextIdentifier")
		s.ContextIdentifier.Encode(e)
	}
	{
		e.FieldStart("description")
		e.Str(s.Description)
	}
	{
		e.FieldStart("euEntityName")
		e.Str(s.EuEntityName)
	}
}

var jsonFieldsNameOfEuEntityAdministrationPermissionsGrantRequest = [4]string{
	0: "subjectIdentifier",
	1: "contextIdentifier",
	2: "description",
	3: "euEntityName",
}

// Decode decodes EuEntityAdministrationPermissionsGrantRequest from json.
func (s *EuEntityAdministrationPermissionsGrantRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EuEntityAdministrationPermissionsGrantRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "subjectIdentifier":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.SubjectIdentifier.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subjectIdentifier\"")
			}
		case "contextIdentifier":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.ContextIdentifier.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"contextIdentifier\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "euEntityName":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.EuEntityName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"euEntityName\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EuEntityAdministrationPermissionsGrantRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEuEntityAdministrationPermissionsGrantRequest) {
					name = jsonFieldsNameOfEuEntityAdministrationPermissionsGrantRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EuEntityAdministrationPermissionsGrantRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EuEntityAdministrationPermissionsGrantRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EuEntityAdministrationPermissionsSubjectIdentifier) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EuEntityAdministrationPermissionsSubjectIdentifier) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("value")
		e.Str(s.Value)
	}
}

var jsonFieldsNameOfEuEntityAdministrationPermissionsSubjectIdentifier = [2]string{
	0: "type",
	1: "value",
}

// Decode decodes EuEntityAdministrationPermissionsSubjectIdentifier from json.
func (s *EuEntityAdministrationPermissionsSubjectIdentifier) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EuEntityAdministrationPermissionsSubjectIdentifier to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "value":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Value = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EuEntityAdministrationPermissionsSubjectIdentifier")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEuEntityAdministrationPermissionsSubjectIdentifier) {
					name = jsonFieldsNameOfEuEntityAdministrationPermissionsSubjectIdentifier[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EuEntityAdministrationPermissionsSubjectIdentifier) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EuEntityAdministrationPermissionsSubjectIdentifier) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EuEntityAdministrationPermissionsSubjectIdentifierType as json.
func (s EuEntityAdministrationPermissionsSubjectIdentifierType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes EuEntityAdministrationPermissionsSubjectIdentifierType from json.
func (s *EuEntityAdministrationPermissionsSubjectIdentifierType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EuEntityAdministrationPermissionsSubjectIdentifierType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch EuEntityAdministrationPermissionsSubjectIdentifierType(v) {
	case EuEntityAdministrationPermissionsSubjectIdentifierTypeFingerprint:
		*s = EuEntityAdministrationPermissionsSubjectIdentifierTypeFingerprint
	default:
		*s = EuEntityAdministrationPermissionsSubjectIdentifierType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s EuEntityAdministrationPermissionsSubjectIdentifierType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EuEntityAdministrationPermissionsSubjectIdentifierType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EuEntityPermission) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EuEntityPermission) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		s.ID.Encode(e)
	}
	{
		e.FieldStart("authorIdentifier")
		s.AuthorIdentifier.Encode(e)
	}
	{
		e.FieldStart("vatUeIdentifier")
		e.Str(s.VatUeIdentifier)
	}
	{
		e.FieldStart("euEntityName")
		e.Str(s.EuEntityName)
	}
	{
		e.FieldStart("authorizedFingerprintIdentifier")
		e.Str(s.AuthorizedFingerprintIdentifier)
	}
	{
		e.FieldStart("permissionScope")
		s.PermissionScope.Encode(e)
	}
	{
		e.FieldStart("description")
		e.Str(s.Description)
	}
	{
		e.FieldStart("startDate")
		json.EncodeDateTime(e, s.StartDate)
	}
}

var jsonFieldsNameOfEuEntityPermission = [8]string{
	0: "id",
	1: "authorIdentifier",
	2: "vatUeIdentifier",
	3: "euEntityName",
	4: "authorizedFingerprintIdentifier",
	5: "permissionScope",
	6: "description",
	7: "startDate",
}

// Decode decodes EuEntityPermission from json.
func (s *EuEntityPermission) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EuEntityPermission to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "authorIdentifier":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.AuthorIdentifier.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"authorIdentifier\"")
			}
		case "vatUeIdentifier":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.VatUeIdentifier = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vatUeIdentifier\"")
			}
		case "euEntityName":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.EuEntityName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"euEntityName\"")
			}
		case "authorizedFingerprintIdentifier":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.AuthorizedFingerprintIdentifier = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"authorizedFingerprintIdentifier\"")
			}
		case "permissionScope":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.PermissionScope.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"permissionScope\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "startDate":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.StartDate = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"startDate\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EuEntityPermission")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b11111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEuEntityPermission) {
					name = jsonFieldsNameOfEuEntityPermission[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EuEntityPermission) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EuEntityPermission) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EuEntityPermissionType as json.
func (s EuEntityPermissionType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes EuEntityPermissionType from json.
func (s *EuEntityPermissionType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EuEntityPermissionType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch EuEntityPermissionType(v) {
	case EuEntityPermissionTypeInvoiceWrite:
		*s = EuEntityPermissionTypeInvoiceWrite
	case EuEntityPermissionTypeInvoiceRead:
		*s = EuEntityPermissionTypeInvoiceRead
	default:
		*s = EuEntityPermissionType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s EuEntityPermissionType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EuEntityPermissionType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EuEntityPermissionsAuthorIdentifier) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EuEntityPermissionsAuthorIdentifier) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("value")
		e.Str(s.Value)
	}
}

var jsonFieldsNameOfEuEntityPermissionsAuthorIdentifier = [2]string{
	0: "type",
	1: "value",
}

// Decode decodes EuEntityPermissionsAuthorIdentifier from json.
func (s *EuEntityPermissionsAuthorIdentifier) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EuEntityPermissionsAuthorIdentifier to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "value":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Value = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EuEntityPermissionsAuthorIdentifier")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEuEntityPermissionsAuthorIdentifier) {
					name = jsonFieldsNameOfEuEntityPermissionsAuthorIdentifier[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EuEntityPermissionsAuthorIdentifier) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EuEntityPermissionsAuthorIdentifier) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EuEntityPermissionsAuthorIdentifierType as json.
func (s EuEntityPermissionsAuthorIdentifierType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes EuEntityPermissionsAuthorIdentifierType from json.
func (s *EuEntityPermissionsAuthorIdentifierType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EuEntityPermissionsAuthorIdentifierType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch EuEntityPermissionsAuthorIdentifierType(v) {
	case EuEntityPermissionsAuthorIdentifierTypeNip:
		*s = EuEntityPermissionsAuthorIdentifierTypeNip
	case EuEntityPermissionsAuthorIdentifierTypePesel:
		*s = EuEntityPermissionsAuthorIdentifierTypePesel
	case EuEntityPermissionsAuthorIdentifierTypeFingerprint:
		*s = EuEntityPermissionsAuthorIdentifierTypeFingerprint
	default:
		*s = EuEntityPermissionsAuthorIdentifierType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s EuEntityPermissionsAuthorIdentifierType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EuEntityPermissionsAuthorIdentifierType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EuEntityPermissionsGrantRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EuEntityPermissionsGrantRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("subjectIdentifier")
		s.SubjectIdentifier.Encode(e)
	}
	{
		e.FieldStart("permissions")
		e.ArrStart()
		for _, elem := range s.Permissions {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("description")
		e.Str(s.Description)
	}
}

var jsonFieldsNameOfEuEntityPermissionsGrantRequest = [3]string{
	0: "subjectIdentifier",
	1: "permissions",
	2: "description",
}

// Decode decodes EuEntityPermissionsGrantRequest from json.
func (s *EuEntityPermissionsGrantRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EuEntityPermissionsGrantRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "subjectIdentifier":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.SubjectIdentifier.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subjectIdentifier\"")
			}
		case "permissions":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Permissions = make([]EuEntityPermissionType, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem EuEntityPermissionType
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Permissions = append(s.Permissions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"permissions\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EuEntityPermissionsGrantRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEuEntityPermissionsGrantRequest) {
					name = jsonFieldsNameOfEuEntityPermissionsGrantRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EuEntityPermissionsGrantRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EuEntityPermissionsGrantRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EuEntityPermissionsQueryPermissionType as json.
func (s EuEntityPermissionsQueryPermissionType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes EuEntityPermissionsQueryPermissionType from json.
func (s *EuEntityPermissionsQueryPermissionType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EuEntityPermissionsQueryPermissionType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch EuEntityPermissionsQueryPermissionType(v) {
	case EuEntityPermissionsQueryPermissionTypeVatUeManage:
		*s = EuEntityPermissionsQueryPermissionTypeVatUeManage
	case EuEntityPermissionsQueryPermissionTypeInvoiceWrite:
		*s = EuEntityPermissionsQueryPermissionTypeInvoiceWrite
	case EuEntityPermissionsQueryPermissionTypeInvoiceRead:
		*s = EuEntityPermissionsQueryPermissionTypeInvoiceRead
	case EuEntityPermissionsQueryPermissionTypeIntrospection:
		*s = EuEntityPermissionsQueryPermissionTypeIntrospection
	default:
		*s = EuEntityPermissionsQueryPermissionType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s EuEntityPermissionsQueryPermissionType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EuEntityPermissionsQueryPermissionType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EuEntityPermissionsQueryRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EuEntityPermissionsQueryRequest) encodeFields(e *jx.Encoder) {
	{
		if s.VatUeIdentifier.Set {
			e.FieldStart("vatUeIdentifier")
			s.VatUeIdentifier.Encode(e)
		}
	}
	{
		if s.AuthorizedFingerprintIdentifier.Set {
			e.FieldStart("authorizedFingerprintIdentifier")
			s.AuthorizedFingerprintIdentifier.Encode(e)
		}
	}
	{
		if s.PermissionTypes.Set {
			e.FieldStart("permissionTypes")
			s.PermissionTypes.Encode(e)
		}
	}
}

var jsonFieldsNameOfEuEntityPermissionsQueryRequest = [3]string{
	0: "vatUeIdentifier",
	1: "authorizedFingerprintIdentifier",
	2: "permissionTypes",
}

// Decode decodes EuEntityPermissionsQueryRequest from json.
func (s *EuEntityPermissionsQueryRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EuEntityPermissionsQueryRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "vatUeIdentifier":
			if err := func() error {
				s.VatUeIdentifier.Reset()
				if err := s.VatUeIdentifier.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vatUeIdentifier\"")
			}
		case "authorizedFingerprintIdentifier":
			if err := func() error {
				s.AuthorizedFingerprintIdentifier.Reset()
				if err := s.AuthorizedFingerprintIdentifier.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"authorizedFingerprintIdentifier\"")
			}
		case "permissionTypes":
			if err := func() error {
				s.PermissionTypes.Reset()
				if err := s.PermissionTypes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"permissionTypes\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EuEntityPermissionsQueryRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EuEntityPermissionsQueryRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EuEntityPermissionsQueryRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EuEntityPermissionsSubjectIdentifier) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EuEntityPermissionsSubjectIdentifier) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("value")
		e.Str(s.Value)
	}
}

var jsonFieldsNameOfEuEntityPermissionsSubjectIdentifier = [2]string{
	0: "type",
	1: "value",
}

// Decode decodes EuEntityPermissionsSubjectIdentifier from json.
func (s *EuEntityPermissionsSubjectIdentifier) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EuEntityPermissionsSubjectIdentifier to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "value":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Value = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EuEntityPermissionsSubjectIdentifier")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEuEntityPermissionsSubjectIdentifier) {
					name = jsonFieldsNameOfEuEntityPermissionsSubjectIdentifier[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EuEntityPermissionsSubjectIdentifier) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EuEntityPermissionsSubjectIdentifier) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EuEntityPermissionsSubjectIdentifierType as json.
func (s EuEntityPermissionsSubjectIdentifierType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes EuEntityPermissionsSubjectIdentifierType from json.
func (s *EuEntityPermissionsSubjectIdentifierType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EuEntityPermissionsSubjectIdentifierType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch EuEntityPermissionsSubjectIdentifierType(v) {
	case EuEntityPermissionsSubjectIdentifierTypeFingerprint:
		*s = EuEntityPermissionsSubjectIdentifierTypeFingerprint
	default:
		*s = EuEntityPermissionsSubjectIdentifierType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s EuEntityPermissionsSubjectIdentifierType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EuEntityPermissionsSubjectIdentifierType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ExceptionDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ExceptionDetails) encodeFields(e *jx.Encoder) {
	{
		if s.ExceptionCode.Set {
			e.FieldStart("exceptionCode")
			s.ExceptionCode.Encode(e)
		}
	}
	{
		if s.ExceptionDescription.Set {
			e.FieldStart("exceptionDescription")
			s.ExceptionDescription.Encode(e)
		}
	}
	{
		if s.Details.Set {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfExceptionDetails = [3]string{
	0: "exceptionCode",
	1: "exceptionDescription",
	2: "details",
}

// Decode decodes ExceptionDetails from json.
func (s *ExceptionDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ExceptionDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "exceptionCode":
			if err := func() error {
				s.ExceptionCode.Reset()
				if err := s.ExceptionCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"exceptionCode\"")
			}
		case "exceptionDescription":
			if err := func() error {
				s.ExceptionDescription.Reset()
				if err := s.ExceptionDescription.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"exceptionDescription\"")
			}
		case "details":
			if err := func() error {
				s.Details.Reset()
				if err := s.Details.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ExceptionDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ExceptionDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ExceptionDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ExceptionInfo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ExceptionInfo) encodeFields(e *jx.Encoder) {
	{
		if s.ExceptionDetailList.Set {
			e.FieldStart("exceptionDetailList")
			s.ExceptionDetailList.Encode(e)
		}
	}
	{
		if s.ReferenceNumber.Set {
			e.FieldStart("referenceNumber")
			s.ReferenceNumber.Encode(e)
		}
	}
	{
		if s.ServiceCode.Set {
			e.FieldStart("serviceCode")
			s.ServiceCode.Encode(e)
		}
	}
	{
		if s.ServiceCtx.Set {
			e.FieldStart("serviceCtx")
			s.ServiceCtx.Encode(e)
		}
	}
	{
		if s.ServiceName.Set {
			e.FieldStart("serviceName")
			s.ServiceName.Encode(e)
		}
	}
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfExceptionInfo = [6]string{
	0: "exceptionDetailList",
	1: "referenceNumber",
	2: "serviceCode",
	3: "serviceCtx",
	4: "serviceName",
	5: "timestamp",
}

// Decode decodes ExceptionInfo from json.
func (s *ExceptionInfo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ExceptionInfo to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "exceptionDetailList":
			if err := func() error {
				s.ExceptionDetailList.Reset()
				if err := s.ExceptionDetailList.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"exceptionDetailList\"")
			}
		case "referenceNumber":
			if err := func() error {
				s.ReferenceNumber.Reset()
				if err := s.ReferenceNumber.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"referenceNumber\"")
			}
		case "serviceCode":
			if err := func() error {
				s.ServiceCode.Reset()
				if err := s.ServiceCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"serviceCode\"")
			}
		case "serviceCtx":
			if err := func() error {
				s.ServiceCtx.Reset()
				if err := s.ServiceCtx.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"serviceCtx\"")
			}
		case "serviceName":
			if err := func() error {
				s.ServiceName.Reset()
				if err := s.ServiceName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"serviceName\"")
			}
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ExceptionInfo")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ExceptionInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ExceptionInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ExceptionResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ExceptionResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Exception.Set {
			e.FieldStart("exception")
			s.Exception.Encode(e)
		}
	}
}

var jsonFieldsNameOfExceptionResponse = [1]string{
	0: "exception",
}

// Decode decodes ExceptionResponse from json.
func (s *ExceptionResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ExceptionResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "exception":
			if err := func() error {
				s.Exception.Reset()
				if err := s.Exception.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"exception\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ExceptionResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ExceptionResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ExceptionResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ExportInvoicesResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ExportInvoicesResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("referenceNumber")
		s.ReferenceNumber.Encode(e)
	}
}

var jsonFieldsNameOfExportInvoicesResponse = [1]string{
	0: "referenceNumber",
}

// Decode decodes ExportInvoicesResponse from json.
func (s *ExportInvoicesResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ExportInvoicesResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "referenceNumber":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ReferenceNumber.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"referenceNumber\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ExportInvoicesResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfExportInvoicesResponse) {
					name = jsonFieldsNameOfExportInvoicesResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ExportInvoicesResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ExportInvoicesResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *FormCode) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *FormCode) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("systemCode")
		e.Str(s.SystemCode)
	}
	{
		e.FieldStart("schemaVersion")
		e.Str(s.SchemaVersion)
	}
	{
		e.FieldStart("value")
		e.Str(s.Value)
	}
}

var jsonFieldsNameOfFormCode = [3]string{
	0: "systemCode",
	1: "schemaVersion",
	2: "value",
}

// Decode decodes FormCode from json.
func (s *FormCode) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FormCode to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "systemCode":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.SystemCode = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"systemCode\"")
			}
		case "schemaVersion":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.SchemaVersion = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"schemaVersion\"")
			}
		case "value":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Value = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FormCode")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfFormCode) {
					name = jsonFieldsNameOfFormCode[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *FormCode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FormCode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GenerateTokenRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GenerateTokenRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("permissions")
		e.ArrStart()
		for _, elem := range s.Permissions {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("description")
		e.Str(s.Description)
	}
}

var jsonFieldsNameOfGenerateTokenRequest = [2]string{
	0: "permissions",
	1: "description",
}

// Decode decodes GenerateTokenRequest from json.
func (s *GenerateTokenRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GenerateTokenRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "permissions":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Permissions = make([]TokenPermissionType, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem TokenPermissionType
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Permissions = append(s.Permissions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"permissions\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GenerateTokenRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGenerateTokenRequest) {
					name = jsonFieldsNameOfGenerateTokenRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GenerateTokenRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GenerateTokenRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GenerateTokenResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GenerateTokenResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("referenceNumber")
		s.ReferenceNumber.Encode(e)
	}
	{
		e.FieldStart("token")
		e.Str(s.Token)
	}
}

var jsonFieldsNameOfGenerateTokenResponse = [2]string{
	0: "referenceNumber",
	1: "token",
}

// Decode decodes GenerateTokenResponse from json.
func (s *GenerateTokenResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GenerateTokenResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "referenceNumber":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ReferenceNumber.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"referenceNumber\"")
			}
		case "token":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Token = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"token\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GenerateTokenResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGenerateTokenResponse) {
					name = jsonFieldsNameOfGenerateTokenResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GenerateTokenResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GenerateTokenResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IndirectPermissionType as json.
func (s IndirectPermissionType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes IndirectPermissionType from json.
func (s *IndirectPermissionType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IndirectPermissionType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch IndirectPermissionType(v) {
	case IndirectPermissionTypeInvoiceRead:
		*s = IndirectPermissionTypeInvoiceRead
	case IndirectPermissionTypeInvoiceWrite:
		*s = IndirectPermissionTypeInvoiceWrite
	default:
		*s = IndirectPermissionType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s IndirectPermissionType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IndirectPermissionType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IndirectPermissionsGrantRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IndirectPermissionsGrantRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("subjectIdentifier")
		s.SubjectIdentifier.Encode(e)
	}
	{
		if s.TargetIdentifier.Set {
			e.FieldStart("targetIdentifier")
			s.TargetIdentifier.Encode(e)
		}
	}
	{
		e.FieldStart("permissions")
		e.ArrStart()
		for _, elem := range s.Permissions {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("description")
		e.Str(s.Description)
	}
}

var jsonFieldsNameOfIndirectPermissionsGrantRequest = [4]string{
	0: "subjectIdentifier",
	1: "targetIdentifier",
	2: "permissions",
	3: "description",
}

// Decode decodes IndirectPermissionsGrantRequest from json.
func (s *IndirectPermissionsGrantRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IndirectPermissionsGrantRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "subjectIdentifier":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.SubjectIdentifier.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subjectIdentifier\"")
			}
		case "targetIdentifier":
			if err := func() error {
				s.TargetIdentifier.Reset()
				if err := s.TargetIdentifier.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"targetIdentifier\"")
			}
		case "permissions":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.Permissions = make([]IndirectPermissionType, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IndirectPermissionType
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Permissions = append(s.Permissions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"permissions\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IndirectPermissionsGrantRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIndirectPermissionsGrantRequest) {
					name = jsonFieldsNameOfIndirectPermissionsGrantRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IndirectPermissionsGrantRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IndirectPermissionsGrantRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IndirectPermissionsSubjectIdentifier) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IndirectPermissionsSubjectIdentifier) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("value")
		e.Str(s.Value)
	}
}

var jsonFieldsNameOfIndirectPermissionsSubjectIdentifier = [2]string{
	0: "type",
	1: "value",
}

// Decode decodes IndirectPermissionsSubjectIdentifier from json.
func (s *IndirectPermissionsSubjectIdentifier) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IndirectPermissionsSubjectIdentifier to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "value":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Value = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IndirectPermissionsSubjectIdentifier")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIndirectPermissionsSubjectIdentifier) {
					name = jsonFieldsNameOfIndirectPermissionsSubjectIdentifier[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IndirectPermissionsSubjectIdentifier) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IndirectPermissionsSubjectIdentifier) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IndirectPermissionsSubjectIdentifierType as json.
func (s IndirectPermissionsSubjectIdentifierType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes IndirectPermissionsSubjectIdentifierType from json.
func (s *IndirectPermissionsSubjectIdentifierType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IndirectPermissionsSubjectIdentifierType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch IndirectPermissionsSubjectIdentifierType(v) {
	case IndirectPermissionsSubjectIdentifierTypeNip:
		*s = IndirectPermissionsSubjectIdentifierTypeNip
	case IndirectPermissionsSubjectIdentifierTypePesel:
		*s = IndirectPermissionsSubjectIdentifierTypePesel
	case IndirectPermissionsSubjectIdentifierTypeFingerprint:
		*s = IndirectPermissionsSubjectIdentifierTypeFingerprint
	default:
		*s = IndirectPermissionsSubjectIdentifierType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s IndirectPermissionsSubjectIdentifierType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IndirectPermissionsSubjectIdentifierType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IndirectPermissionsTargetIdentifier) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IndirectPermissionsTargetIdentifier) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		if s.Value.Set {
			e.FieldStart("value")
			s.Value.Encode(e)
		}
	}
}

var jsonFieldsNameOfIndirectPermissionsTargetIdentifier = [2]string{
	0: "type",
	1: "value",
}

// Decode decodes IndirectPermissionsTargetIdentifier from json.
func (s *IndirectPermissionsTargetIdentifier) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IndirectPermissionsTargetIdentifier to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "value":
			if err := func() error {
				s.Value.Reset()
				if err := s.Value.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IndirectPermissionsTargetIdentifier")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIndirectPermissionsTargetIdentifier) {
					name = jsonFieldsNameOfIndirectPermissionsTargetIdentifier[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IndirectPermissionsTargetIdentifier) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IndirectPermissionsTargetIdentifier) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IndirectPermissionsTargetIdentifierType as json.
func (s IndirectPermissionsTargetIdentifierType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes IndirectPermissionsTargetIdentifierType from json.
func (s *IndirectPermissionsTargetIdentifierType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IndirectPermissionsTargetIdentifierType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch IndirectPermissionsTargetIdentifierType(v) {
	case IndirectPermissionsTargetIdentifierTypeNip:
		*s = IndirectPermissionsTargetIdentifierTypeNip
	case IndirectPermissionsTargetIdentifierTypeAllPartners:
		*s = IndirectPermissionsTargetIdentifierTypeAllPartners
	case IndirectPermissionsTargetIdentifierTypeInternalId:
		*s = IndirectPermissionsTargetIdentifierTypeInternalId
	default:
		*s = IndirectPermissionsTargetIdentifierType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s IndirectPermissionsTargetIdentifierType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IndirectPermissionsTargetIdentifierType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InitTokenAuthenticationRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InitTokenAuthenticationRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("challenge")
		s.Challenge.Encode(e)
	}
	{
		e.FieldStart("contextIdentifier")
		s.ContextIdentifier.Encode(e)
	}
	{
		e.FieldStart("encryptedToken")
		e.Base64(s.EncryptedToken)
	}
	{
		if s.AuthorizationPolicy.Set {
			e.FieldStart("authorizationPolicy")
			s.AuthorizationPolicy.Encode(e)
		}
	}
}

var jsonFieldsNameOfInitTokenAuthenticationRequest = [4]string{
	0: "challenge",
	1: "contextIdentifier",
	2: "encryptedToken",
	3: "authorizationPolicy",
}

// Decode decodes InitTokenAuthenticationRequest from json.
func (s *InitTokenAuthenticationRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InitTokenAuthenticationRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "challenge":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Challenge.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"challenge\"")
			}
		case "contextIdentifier":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.ContextIdentifier.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"contextIdentifier\"")
			}
		case "encryptedToken":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Base64()
				s.EncryptedToken = []byte(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"encryptedToken\"")
			}
		case "authorizationPolicy":
			if err := func() error {
				s.AuthorizationPolicy.Reset()
				if err := s.AuthorizationPolicy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"authorizationPolicy\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InitTokenAuthenticationRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInitTokenAuthenticationRequest) {
					name = jsonFieldsNameOfInitTokenAuthenticationRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InitTokenAuthenticationRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InitTokenAuthenticationRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InvoiceExportRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InvoiceExportRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("encryption")
		s.Encryption.Encode(e)
	}
	{
		e.FieldStart("filters")
		s.Filters.Encode(e)
	}
}

var jsonFieldsNameOfInvoiceExportRequest = [2]string{
	0: "encryption",
	1: "filters",
}

// Decode decodes InvoiceExportRequest from json.
func (s *InvoiceExportRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InvoiceExportRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "encryption":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Encryption.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"encryption\"")
			}
		case "filters":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Filters.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"filters\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InvoiceExportRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInvoiceExportRequest) {
					name = jsonFieldsNameOfInvoiceExportRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InvoiceExportRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InvoiceExportRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InvoiceExportStatusResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InvoiceExportStatusResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("status")
		s.Status.Encode(e)
	}
	{
		if s.CompletedDate.Set {
			e.FieldStart("completedDate")
			s.CompletedDate.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.PackageExpirationDate.Set {
			e.FieldStart("packageExpirationDate")
			s.PackageExpirationDate.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Package.Set {
			e.FieldStart("package")
			s.Package.Encode(e)
		}
	}
}

var jsonFieldsNameOfInvoiceExportStatusResponse = [4]string{
	0: "status",
	1: "completedDate",
	2: "packageExpirationDate",
	3: "package",
}

// Decode decodes InvoiceExportStatusResponse from json.
func (s *InvoiceExportStatusResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InvoiceExportStatusResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "status":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "completedDate":
			if err := func() error {
				s.CompletedDate.Reset()
				if err := s.CompletedDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"completedDate\"")
			}
		case "packageExpirationDate":
			if err := func() error {
				s.PackageExpirationDate.Reset()
				if err := s.PackageExpirationDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"packageExpirationDate\"")
			}
		case "package":
			if err := func() error {
				s.Package.Reset()
				if err := s.Package.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"package\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InvoiceExportStatusResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInvoiceExportStatusResponse) {
					name = jsonFieldsNameOfInvoiceExportStatusResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InvoiceExportStatusResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InvoiceExportStatusResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InvoiceMetadata) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InvoiceMetadata) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("ksefNumber")
		s.KsefNumber.Encode(e)
	}
	{
		e.FieldStart("invoiceNumber")
		e.Str(s.InvoiceNumber)
	}
	{
		e.FieldStart("issueDate")
		json.EncodeDate(e, s.IssueDate)
	}
	{
		e.FieldStart("invoicingDate")
		json.EncodeDateTime(e, s.InvoicingDate)
	}
	{
		e.FieldStart("acquisitionDate")
		json.EncodeDateTime(e, s.AcquisitionDate)
	}
	{
		e.FieldStart("permanentStorageDate")
		json.EncodeDateTime(e, s.PermanentStorageDate)
	}
	{
		e.FieldStart("seller")
		s.Seller.Encode(e)
	}
	{
		e.FieldStart("buyer")
		s.Buyer.Encode(e)
	}
	{
		e.FieldStart("netAmount")
		e.Float64(s.NetAmount)
	}
	{
		e.FieldStart("grossAmount")
		e.Float64(s.GrossAmount)
	}
	{
		e.FieldStart("vatAmount")
		e.Float64(s.VatAmount)
	}
	{
		e.FieldStart("currency")
		e.Str(s.Currency)
	}
	{
		e.FieldStart("invoicingMode")
		s.InvoicingMode.Encode(e)
	}
	{
		e.FieldStart("invoiceType")
		s.InvoiceType.Encode(e)
	}
	{
		e.FieldStart("formCode")
		s.FormCode.Encode(e)
	}
	{
		e.FieldStart("isSelfInvoicing")
		e.Bool(s.IsSelfInvoicing)
	}
	{
		e.FieldStart("hasAttachment")
		e.Bool(s.HasAttachment)
	}
	{
		e.FieldStart("invoiceHash")
		s.InvoiceHash.Encode(e)
	}
	{
		if s.HashOfCorrectedInvoice.Set {
			e.FieldStart("hashOfCorrectedInvoice")
			s.HashOfCorrectedInvoice.Encode(e)
		}
	}
	{
		if s.ThirdSubjects.Set {
			e.FieldStart("thirdSubjects")
			s.ThirdSubjects.Encode(e)
		}
	}
	{
		if s.AuthorizedSubject.Set {
			e.FieldStart("authorizedSubject")
			s.AuthorizedSubject.Encode(e)
		}
	}
}

var jsonFieldsNameOfInvoiceMetadata = [21]string{
	0:  "ksefNumber",
	1:  "invoiceNumber",
	2:  "issueDate",
	3:  "invoicingDate",
	4:  "acquisitionDate",
	5:  "permanentStorageDate",
	6:  "seller",
	7:  "buyer",
	8:  "netAmount",
	9:  "grossAmount",
	10: "vatAmount",
	11: "currency",
	12: "invoicingMode",
	13: "invoiceType",
	14: "formCode",
	15: "isSelfInvoicing",
	16: "hasAttachment",
	17: "invoiceHash",
	18: "hashOfCorrectedInvoice",
	19: "thirdSubjects",
	20: "authorizedSubject",
}

// Decode decodes InvoiceMetadata from json.
func (s *InvoiceMetadata) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InvoiceMetadata to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ksefNumber":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.KsefNumber.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ksefNumber\"")
			}
		case "invoiceNumber":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.InvoiceNumber = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"invoiceNumber\"")
			}
		case "issueDate":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDate(d)
				s.IssueDate = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"issueDate\"")
			}
		case "invoicingDate":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.InvoicingDate = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"invoicingDate\"")
			}
		case "acquisitionDate":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.AcquisitionDate = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"acquisitionDate\"")
			}
		case "permanentStorageDate":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.PermanentStorageDate = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"permanentStorageDate\"")
			}
		case "seller":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.Seller.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"seller\"")
			}
		case "buyer":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.Buyer.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"buyer\"")
			}
		case "netAmount":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.NetAmount = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"netAmount\"")
			}
		case "grossAmount":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.GrossAmount = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"grossAmount\"")
			}
		case "vatAmount":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Float64()
				s.VatAmount = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vatAmount\"")
			}
		case "currency":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Currency = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency\"")
			}
		case "invoicingMode":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				if err := s.InvoicingMode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"invoicingMode\"")
			}
		case "invoiceType":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				if err := s.InvoiceType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"invoiceType\"")
			}
		case "formCode":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				if err := s.FormCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"formCode\"")
			}
		case "isSelfInvoicing":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := d.Bool()
				s.IsSelfInvoicing = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isSelfInvoicing\"")
			}
		case "hasAttachment":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.HasAttachment = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hasAttachment\"")
			}
		case "invoiceHash":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				if err := s.InvoiceHash.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"invoiceHash\"")
			}
		case "hashOfCorrectedInvoice":
			if err := func() error {
				s.HashOfCorrectedInvoice.Reset()
				if err := s.HashOfCorrectedInvoice.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hashOfCorrectedInvoice\"")
			}
		case "thirdSubjects":
			if err := func() error {
				s.ThirdSubjects.Reset()
				if err := s.ThirdSubjects.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thirdSubjects\"")
			}
		case "authorizedSubject":
			if err := func() error {
				s.AuthorizedSubject.Reset()
				if err := s.AuthorizedSubject.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"authorizedSubject\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InvoiceMetadata")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b11111111,
		0b11111111,
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInvoiceMetadata) {
					name = jsonFieldsNameOfInvoiceMetadata[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InvoiceMetadata) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InvoiceMetadata) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InvoiceMetadataAuthorizedSubject) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InvoiceMetadataAuthorizedSubject) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("nip")
		s.Nip.Encode(e)
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		e.FieldStart("role")
		e.Int32(s.Role)
	}
}

var jsonFieldsNameOfInvoiceMetadataAuthorizedSubject = [3]string{
	0: "nip",
	1: "name",
	2: "role",
}

// Decode decodes InvoiceMetadataAuthorizedSubject from json.
func (s *InvoiceMetadataAuthorizedSubject) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InvoiceMetadataAuthorizedSubject to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "nip":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Nip.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nip\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "role":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int32()
				s.Role = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"role\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InvoiceMetadataAuthorizedSubject")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInvoiceMetadataAuthorizedSubject) {
					name = jsonFieldsNameOfInvoiceMetadataAuthorizedSubject[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InvoiceMetadataAuthorizedSubject) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InvoiceMetadataAuthorizedSubject) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InvoiceMetadataBuyer) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InvoiceMetadataBuyer) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("identifier")
		s.Identifier.Encode(e)
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
}

var jsonFieldsNameOfInvoiceMetadataBuyer = [2]string{
	0: "identifier",
	1: "name",
}

// Decode decodes InvoiceMetadataBuyer from json.
func (s *InvoiceMetadataBuyer) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InvoiceMetadataBuyer to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "identifier":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Identifier.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"identifier\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InvoiceMetadataBuyer")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInvoiceMetadataBuyer) {
					name = jsonFieldsNameOfInvoiceMetadataBuyer[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InvoiceMetadataBuyer) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InvoiceMetadataBuyer) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InvoiceMetadataBuyerIdentifier) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InvoiceMetadataBuyerIdentifier) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		if s.Value.Set {
			e.FieldStart("value")
			s.Value.Encode(e)
		}
	}
}

var jsonFieldsNameOfInvoiceMetadataBuyerIdentifier = [2]string{
	0: "type",
	1: "value",
}

// Decode decodes InvoiceMetadataBuyerIdentifier from json.
func (s *InvoiceMetadataBuyerIdentifier) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InvoiceMetadataBuyerIdentifier to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "value":
			if err := func() error {
				s.Value.Reset()
				if err := s.Value.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InvoiceMetadataBuyerIdentifier")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInvoiceMetadataBuyerIdentifier) {
					name = jsonFieldsNameOfInvoiceMetadataBuyerIdentifier[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InvoiceMetadataBuyerIdentifier) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InvoiceMetadataBuyerIdentifier) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InvoiceMetadataSeller) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InvoiceMetadataSeller) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("nip")
		s.Nip.Encode(e)
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
}

var jsonFieldsNameOfInvoiceMetadataSeller = [2]string{
	0: "nip",
	1: "name",
}

// Decode decodes InvoiceMetadataSeller from json.
func (s *InvoiceMetadataSeller) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InvoiceMetadataSeller to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "nip":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Nip.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nip\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InvoiceMetadataSeller")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInvoiceMetadataSeller) {
					name = jsonFieldsNameOfInvoiceMetadataSeller[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InvoiceMetadataSeller) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InvoiceMetadataSeller) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InvoiceMetadataThirdSubject) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InvoiceMetadataThirdSubject) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("identifier")
		s.Identifier.Encode(e)
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		e.FieldStart("role")
		e.Int32(s.Role)
	}
}

var jsonFieldsNameOfInvoiceMetadataThirdSubject = [3]string{
	0: "identifier",
	1: "name",
	2: "role",
}

// Decode decodes InvoiceMetadataThirdSubject from json.
func (s *InvoiceMetadataThirdSubject) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InvoiceMetadataThirdSubject to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "identifier":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Identifier.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"identifier\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "role":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int32()
				s.Role = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"role\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InvoiceMetadataThirdSubject")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInvoiceMetadataThirdSubject) {
					name = jsonFieldsNameOfInvoiceMetadataThirdSubject[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InvoiceMetadataThirdSubject) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InvoiceMetadataThirdSubject) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InvoiceMetadataThirdSubjectIdentifier) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InvoiceMetadataThirdSubjectIdentifier) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		if s.Value.Set {
			e.FieldStart("value")
			s.Value.Encode(e)
		}
	}
}

var jsonFieldsNameOfInvoiceMetadataThirdSubjectIdentifier = [2]string{
	0: "type",
	1: "value",
}

// Decode decodes InvoiceMetadataThirdSubjectIdentifier from json.
func (s *InvoiceMetadataThirdSubjectIdentifier) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InvoiceMetadataThirdSubjectIdentifier to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "value":
			if err := func() error {
				s.Value.Reset()
				if err := s.Value.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InvoiceMetadataThirdSubjectIdentifier")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInvoiceMetadataThirdSubjectIdentifier) {
					name = jsonFieldsNameOfInvoiceMetadataThirdSubjectIdentifier[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InvoiceMetadataThirdSubjectIdentifier) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InvoiceMetadataThirdSubjectIdentifier) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InvoicePackage) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InvoicePackage) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("invoiceCount")
		e.Int64(s.InvoiceCount)
	}
	{
		e.FieldStart("size")
		e.Int64(s.Size)
	}
	{
		e.FieldStart("parts")
		e.ArrStart()
		for _, elem := range s.Parts {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("isTruncated")
		e.Bool(s.IsTruncated)
	}
	{
		if s.LastIssueDate.Set {
			e.FieldStart("lastIssueDate")
			s.LastIssueDate.Encode(e, json.EncodeDate)
		}
	}
	{
		if s.LastInvoicingDate.Set {
			e.FieldStart("lastInvoicingDate")
			s.LastInvoicingDate.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.LastPermanentStorageDate.Set {
			e.FieldStart("lastPermanentStorageDate")
			s.LastPermanentStorageDate.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfInvoicePackage = [7]string{
	0: "invoiceCount",
	1: "size",
	2: "parts",
	3: "isTruncated",
	4: "lastIssueDate",
	5: "lastInvoicingDate",
	6: "lastPermanentStorageDate",
}

// Decode decodes InvoicePackage from json.
func (s *InvoicePackage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InvoicePackage to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "invoiceCount":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int64()
				s.InvoiceCount = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"invoiceCount\"")
			}
		case "size":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int64()
				s.Size = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"size\"")
			}
		case "parts":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.Parts = make([]InvoicePackagePart, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem InvoicePackagePart
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Parts = append(s.Parts, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parts\"")
			}
		case "isTruncated":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Bool()
				s.IsTruncated = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isTruncated\"")
			}
		case "lastIssueDate":
			if err := func() error {
				s.LastIssueDate.Reset()
				if err := s.LastIssueDate.Decode(d, json.DecodeDate); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastIssueDate\"")
			}
		case "lastInvoicingDate":
			if err := func() error {
				s.LastInvoicingDate.Reset()
				if err := s.LastInvoicingDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastInvoicingDate\"")
			}
		case "lastPermanentStorageDate":
			if err := func() error {
				s.LastPermanentStorageDate.Reset()
				if err := s.LastPermanentStorageDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastPermanentStorageDate\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InvoicePackage")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInvoicePackage) {
					name = jsonFieldsNameOfInvoicePackage[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InvoicePackage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InvoicePackage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InvoicePackagePart) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InvoicePackagePart) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("ordinalNumber")
		e.Int32(s.OrdinalNumber)
	}
	{
		e.FieldStart("partName")
		e.Str(s.PartName)
	}
	{
		e.FieldStart("method")
		e.Str(s.Method)
	}
	{
		e.FieldStart("url")
		json.EncodeURI(e, s.URL)
	}
	{
		e.FieldStart("partSize")
		e.Int64(s.PartSize)
	}
	{
		e.FieldStart("partHash")
		s.PartHash.Encode(e)
	}
	{
		e.FieldStart("encryptedPartSize")
		e.Int64(s.EncryptedPartSize)
	}
	{
		e.FieldStart("encryptedPartHash")
		s.EncryptedPartHash.Encode(e)
	}
	{
		e.FieldStart("expirationDate")
		json.EncodeDateTime(e, s.ExpirationDate)
	}
}

var jsonFieldsNameOfInvoicePackagePart = [9]string{
	0: "ordinalNumber",
	1: "partName",
	2: "method",
	3: "url",
	4: "partSize",
	5: "partHash",
	6: "encryptedPartSize",
	7: "encryptedPartHash",
	8: "expirationDate",
}

// Decode decodes InvoicePackagePart from json.
func (s *InvoicePackagePart) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InvoicePackagePart to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ordinalNumber":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.OrdinalNumber = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ordinalNumber\"")
			}
		case "partName":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.PartName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"partName\"")
			}
		case "method":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Method = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"method\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "partSize":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int64()
				s.PartSize = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"partSize\"")
			}
		case "partHash":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.PartHash.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"partHash\"")
			}
		case "encryptedPartSize":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int64()
				s.EncryptedPartSize = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"encryptedPartSize\"")
			}
		case "encryptedPartHash":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.EncryptedPartHash.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"encryptedPartHash\"")
			}
		case "expirationDate":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.ExpirationDate = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expirationDate\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InvoicePackagePart")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInvoicePackagePart) {
					name = jsonFieldsNameOfInvoicePackagePart[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InvoicePackagePart) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InvoicePackagePart) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes InvoicePermissionType as json.
func (s InvoicePermissionType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes InvoicePermissionType from json.
func (s *InvoicePermissionType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InvoicePermissionType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch InvoicePermissionType(v) {
	case InvoicePermissionTypeSelfInvoicing:
		*s = InvoicePermissionTypeSelfInvoicing
	case InvoicePermissionTypeTaxRepresentative:
		*s = InvoicePermissionTypeTaxRepresentative
	case InvoicePermissionTypeRRInvoicing:
		*s = InvoicePermissionTypeRRInvoicing
	case InvoicePermissionTypePefInvoicing:
		*s = InvoicePermissionTypePefInvoicing
	default:
		*s = InvoicePermissionType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s InvoicePermissionType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InvoicePermissionType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InvoiceQueryAmount) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InvoiceQueryAmount) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		if s.From.Set {
			e.FieldStart("from")
			s.From.Encode(e)
		}
	}
	{
		if s.To.Set {
			e.FieldStart("to")
			s.To.Encode(e)
		}
	}
}

var jsonFieldsNameOfInvoiceQueryAmount = [3]string{
	0: "type",
	1: "from",
	2: "to",
}

// Decode decodes InvoiceQueryAmount from json.
func (s *InvoiceQueryAmount) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InvoiceQueryAmount to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "from":
			if err := func() error {
				s.From.Reset()
				if err := s.From.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"from\"")
			}
		case "to":
			if err := func() error {
				s.To.Reset()
				if err := s.To.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"to\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InvoiceQueryAmount")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInvoiceQueryAmount) {
					name = jsonFieldsNameOfInvoiceQueryAmount[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InvoiceQueryAmount) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InvoiceQueryAmount) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InvoiceQueryBuyerIdentifier) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InvoiceQueryBuyerIdentifier) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		if s.Value.Set {
			e.FieldStart("value")
			s.Value.Encode(e)
		}
	}
}

var jsonFieldsNameOfInvoiceQueryBuyerIdentifier = [2]string{
	0: "type",
	1: "value",
}

// Decode decodes InvoiceQueryBuyerIdentifier from json.
func (s *InvoiceQueryBuyerIdentifier) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InvoiceQueryBuyerIdentifier to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "value":
			if err := func() error {
				s.Value.Reset()
				if err := s.Value.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InvoiceQueryBuyerIdentifier")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInvoiceQueryBuyerIdentifier) {
					name = jsonFieldsNameOfInvoiceQueryBuyerIdentifier[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InvoiceQueryBuyerIdentifier) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InvoiceQueryBuyerIdentifier) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InvoiceQueryDateRange) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InvoiceQueryDateRange) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("dateType")
		s.DateType.Encode(e)
	}
	{
		e.FieldStart("from")
		json.EncodeDateTime(e, s.From)
	}
	{
		if s.To.Set {
			e.FieldStart("to")
			s.To.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfInvoiceQueryDateRange = [3]string{
	0: "dateType",
	1: "from",
	2: "to",
}

// Decode decodes InvoiceQueryDateRange from json.
func (s *InvoiceQueryDateRange) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InvoiceQueryDateRange to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "dateType":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.DateType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dateType\"")
			}
		case "from":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.From = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"from\"")
			}
		case "to":
			if err := func() error {
				s.To.Reset()
				if err := s.To.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"to\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InvoiceQueryDateRange")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInvoiceQueryDateRange) {
					name = jsonFieldsNameOfInvoiceQueryDateRange[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InvoiceQueryDateRange) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InvoiceQueryDateRange) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes InvoiceQueryDateType as json.
func (s InvoiceQueryDateType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes InvoiceQueryDateType from json.
func (s *InvoiceQueryDateType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InvoiceQueryDateType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch InvoiceQueryDateType(v) {
	case InvoiceQueryDateTypeIssue:
		*s = InvoiceQueryDateTypeIssue
	case InvoiceQueryDateTypeInvoicing:
		*s = InvoiceQueryDateTypeInvoicing
	case InvoiceQueryDateTypePermanentStorage:
		*s = InvoiceQueryDateTypePermanentStorage
	default:
		*s = InvoiceQueryDateType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s InvoiceQueryDateType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InvoiceQueryDateType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InvoiceQueryFilters) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InvoiceQueryFilters) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("subjectType")
		s.SubjectType.Encode(e)
	}
	{
		e.FieldStart("dateRange")
		s.DateRange.Encode(e)
	}
	{
		if s.KsefNumber.Set {
			e.FieldStart("ksefNumber")
			s.KsefNumber.Encode(e)
		}
	}
	{
		if s.InvoiceNumber.Set {
			e.FieldStart("invoiceNumber")
			s.InvoiceNumber.Encode(e)
		}
	}
	{
		if s.Amount.Set {
			e.FieldStart("amount")
			s.Amount.Encode(e)
		}
	}
	{
		if s.SellerNip.Set {
			e.FieldStart("sellerNip")
			s.SellerNip.Encode(e)
		}
	}
	{
		if s.BuyerIdentifier.Set {
			e.FieldStart("buyerIdentifier")
			s.BuyerIdentifier.Encode(e)
		}
	}
	{
		if s.CurrencyCodes.Set {
			e.FieldStart("currencyCodes")
			s.CurrencyCodes.Encode(e)
		}
	}
	{
		if s.InvoicingMode.Set {
			e.FieldStart("invoicingMode")
			s.InvoicingMode.Encode(e)
		}
	}
	{
		if s.IsSelfInvoicing.Set {
			e.FieldStart("isSelfInvoicing")
			s.IsSelfInvoicing.Encode(e)
		}
	}
	{
		if s.FormType.Set {
			e.FieldStart("formType")
			s.FormType.Encode(e)
		}
	}
	{
		if s.InvoiceTypes.Set {
			e.FieldStart("invoiceTypes")
			s.InvoiceTypes.Encode(e)
		}
	}
	{
		if s.HasAttachment.Set {
			e.FieldStart("hasAttachment")
			s.HasAttachment.Encode(e)
		}
	}
}

var jsonFieldsNameOfInvoiceQueryFilters = [13]string{
	0:  "subjectType",
	1:  "dateRange",
	2:  "ksefNumber",
	3:  "invoiceNumber",
	4:  "amount",
	5:  "sellerNip",
	6:  "buyerIdentifier",
	7:  "currencyCodes",
	8:  "invoicingMode",
	9:  "isSelfInvoicing",
	10: "formType",
	11: "invoiceTypes",
	12: "hasAttachment",
}

// Decode decodes InvoiceQueryFilters from json.
func (s *InvoiceQueryFilters) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InvoiceQueryFilters to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "subjectType":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.SubjectType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subjectType\"")
			}
		case "dateRange":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.DateRange.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dateRange\"")
			}
		case "ksefNumber":
			if err := func() error {
				s.KsefNumber.Reset()
				if err := s.KsefNumber.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ksefNumber\"")
			}
		case "invoiceNumber":
			if err := func() error {
				s.InvoiceNumber.Reset()
				if err := s.InvoiceNumber.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"invoiceNumber\"")
			}
		case "amount":
			if err := func() error {
				s.Amount.Reset()
				if err := s.Amount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"amount\"")
			}
		case "sellerNip":
			if err := func() error {
				s.SellerNip.Reset()
				if err := s.SellerNip.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sellerNip\"")
			}
		case "buyerIdentifier":
			if err := func() error {
				s.BuyerIdentifier.Reset()
				if err := s.BuyerIdentifier.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"buyerIdentifier\"")
			}
		case "currencyCodes":
			if err := func() error {
				s.CurrencyCodes.Reset()
				if err := s.CurrencyCodes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currencyCodes\"")
			}
		case "invoicingMode":
			if err := func() error {
				s.InvoicingMode.Reset()
				if err := s.InvoicingMode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"invoicingMode\"")
			}
		case "isSelfInvoicing":
			if err := func() error {
				s.IsSelfInvoicing.Reset()
				if err := s.IsSelfInvoicing.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isSelfInvoicing\"")
			}
		case "formType":
			if err := func() error {
				s.FormType.Reset()
				if err := s.FormType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"formType\"")
			}
		case "invoiceTypes":
			if err := func() error {
				s.InvoiceTypes.Reset()
				if err := s.InvoiceTypes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"invoiceTypes\"")
			}
		case "hasAttachment":
			if err := func() error {
				s.HasAttachment.Reset()
				if err := s.HasAttachment.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hasAttachment\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InvoiceQueryFilters")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000011,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInvoiceQueryFilters) {
					name = jsonFieldsNameOfInvoiceQueryFilters[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InvoiceQueryFilters) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InvoiceQueryFilters) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes InvoiceQueryFormType as json.
func (s InvoiceQueryFormType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes InvoiceQueryFormType from json.
func (s *InvoiceQueryFormType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InvoiceQueryFormType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch InvoiceQueryFormType(v) {
	case InvoiceQueryFormTypeFA:
		*s = InvoiceQueryFormTypeFA
	case InvoiceQueryFormTypePEF:
		*s = InvoiceQueryFormTypePEF
	case InvoiceQueryFormTypeRR:
		*s = InvoiceQueryFormTypeRR
	default:
		*s = InvoiceQueryFormType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s InvoiceQueryFormType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InvoiceQueryFormType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes InvoiceQuerySubjectType as json.
func (s InvoiceQuerySubjectType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes InvoiceQuerySubjectType from json.
func (s *InvoiceQuerySubjectType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InvoiceQuerySubjectType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch InvoiceQuerySubjectType(v) {
	case InvoiceQuerySubjectTypeSubject1:
		*s = InvoiceQuerySubjectTypeSubject1
	case InvoiceQuerySubjectTypeSubject2:
		*s = InvoiceQuerySubjectTypeSubject2
	case InvoiceQuerySubjectTypeSubject3:
		*s = InvoiceQuerySubjectTypeSubject3
	case InvoiceQuerySubjectTypeSubjectAuthorized:
		*s = InvoiceQuerySubjectTypeSubjectAuthorized
	default:
		*s = InvoiceQuerySubjectType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s InvoiceQuerySubjectType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InvoiceQuerySubjectType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes InvoiceType as json.
func (s InvoiceType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes InvoiceType from json.
func (s *InvoiceType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InvoiceType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch InvoiceType(v) {
	case InvoiceTypeVat:
		*s = InvoiceTypeVat
	case InvoiceTypeZal:
		*s = InvoiceTypeZal
	case InvoiceTypeKor:
		*s = InvoiceTypeKor
	case InvoiceTypeRoz:
		*s = InvoiceTypeRoz
	case InvoiceTypeUpr:
		*s = InvoiceTypeUpr
	case InvoiceTypeKorZal:
		*s = InvoiceTypeKorZal
	case InvoiceTypeKorRoz:
		*s = InvoiceTypeKorRoz
	case InvoiceTypeVatPef:
		*s = InvoiceTypeVatPef
	case InvoiceTypeVatPefSp:
		*s = InvoiceTypeVatPefSp
	case InvoiceTypeKorPef:
		*s = InvoiceTypeKorPef
	case InvoiceTypeVatRr:
		*s = InvoiceTypeVatRr
	case InvoiceTypeKorVatRr:
		*s = InvoiceTypeKorVatRr
	default:
		*s = InvoiceType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s InvoiceType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InvoiceType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes InvoicingMode as json.
func (s InvoicingMode) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes InvoicingMode from json.
func (s *InvoicingMode) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InvoicingMode to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch InvoicingMode(v) {
	case InvoicingModeOnline:
		*s = InvoicingModeOnline
	case InvoicingModeOffline:
		*s = InvoicingModeOffline
	default:
		*s = InvoicingMode(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s InvoicingMode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InvoicingMode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes KsefCertificateType as json.
func (s KsefCertificateType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes KsefCertificateType from json.
func (s *KsefCertificateType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode KsefCertificateType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch KsefCertificateType(v) {
	case KsefCertificateTypeAuthentication:
		*s = KsefCertificateTypeAuthentication
	case KsefCertificateTypeOffline:
		*s = KsefCertificateTypeOffline
	default:
		*s = KsefCertificateType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s KsefCertificateType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *KsefCertificateType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes KsefNumber as json.
func (s KsefNumber) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes KsefNumber from json.
func (s *KsefNumber) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode KsefNumber to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = KsefNumber(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s KsefNumber) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *KsefNumber) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o NilString) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *NilString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilString to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v string
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Nip as json.
func (s Nip) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes Nip from json.
func (s *Nip) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Nip to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = Nip(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s Nip) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Nip) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *OnlineSessionContextLimitsOverride) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *OnlineSessionContextLimitsOverride) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("maxInvoiceSizeInMB")
		e.Int32(s.MaxInvoiceSizeInMB)
	}
	{
		e.FieldStart("maxInvoiceWithAttachmentSizeInMB")
		e.Int32(s.MaxInvoiceWithAttachmentSizeInMB)
	}
	{
		e.FieldStart("maxInvoices")
		e.Int32(s.MaxInvoices)
	}
}

var jsonFieldsNameOfOnlineSessionContextLimitsOverride = [3]string{
	0: "maxInvoiceSizeInMB",
	1: "maxInvoiceWithAttachmentSizeInMB",
	2: "maxInvoices",
}

// Decode decodes OnlineSessionContextLimitsOverride from json.
func (s *OnlineSessionContextLimitsOverride) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OnlineSessionContextLimitsOverride to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "maxInvoiceSizeInMB":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.MaxInvoiceSizeInMB = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maxInvoiceSizeInMB\"")
			}
		case "maxInvoiceWithAttachmentSizeInMB":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int32()
				s.MaxInvoiceWithAttachmentSizeInMB = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maxInvoiceWithAttachmentSizeInMB\"")
			}
		case "maxInvoices":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int32()
				s.MaxInvoices = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maxInvoices\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode OnlineSessionContextLimitsOverride")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfOnlineSessionContextLimitsOverride) {
					name = jsonFieldsNameOfOnlineSessionContextLimitsOverride[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *OnlineSessionContextLimitsOverride) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OnlineSessionContextLimitsOverride) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *OnlineSessionEffectiveContextLimits) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *OnlineSessionEffectiveContextLimits) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("maxInvoiceSizeInMB")
		e.Int32(s.MaxInvoiceSizeInMB)
	}
	{
		e.FieldStart("maxInvoiceWithAttachmentSizeInMB")
		e.Int32(s.MaxInvoiceWithAttachmentSizeInMB)
	}
	{
		e.FieldStart("maxInvoices")
		e.Int32(s.MaxInvoices)
	}
}

var jsonFieldsNameOfOnlineSessionEffectiveContextLimits = [3]string{
	0: "maxInvoiceSizeInMB",
	1: "maxInvoiceWithAttachmentSizeInMB",
	2: "maxInvoices",
}

// Decode decodes OnlineSessionEffectiveContextLimits from json.
func (s *OnlineSessionEffectiveContextLimits) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OnlineSessionEffectiveContextLimits to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "maxInvoiceSizeInMB":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.MaxInvoiceSizeInMB = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maxInvoiceSizeInMB\"")
			}
		case "maxInvoiceWithAttachmentSizeInMB":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int32()
				s.MaxInvoiceWithAttachmentSizeInMB = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maxInvoiceWithAttachmentSizeInMB\"")
			}
		case "maxInvoices":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int32()
				s.MaxInvoices = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maxInvoices\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode OnlineSessionEffectiveContextLimits")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfOnlineSessionEffectiveContextLimits) {
					name = jsonFieldsNameOfOnlineSessionEffectiveContextLimits[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *OnlineSessionEffectiveContextLimits) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OnlineSessionEffectiveContextLimits) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *OpenBatchSessionRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *OpenBatchSessionRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("formCode")
		s.FormCode.Encode(e)
	}
	{
		e.FieldStart("batchFile")
		s.BatchFile.Encode(e)
	}
	{
		e.FieldStart("encryption")
		s.Encryption.Encode(e)
	}
	{
		if s.OfflineMode.Set {
			e.FieldStart("offlineMode")
			s.OfflineMode.Encode(e)
		}
	}
}

var jsonFieldsNameOfOpenBatchSessionRequest = [4]string{
	0: "formCode",
	1: "batchFile",
	2: "encryption",
	3: "offlineMode",
}

// Decode decodes OpenBatchSessionRequest from json.
func (s *OpenBatchSessionRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OpenBatchSessionRequest to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "formCode":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.FormCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"formCode\"")
			}
		case "batchFile":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.BatchFile.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"batchFile\"")
			}
		case "encryption":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Encryption.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"encryption\"")
			}
		case "offlineMode":
			if err := func() error {
				s.OfflineMode.Reset()
				if err := s.OfflineMode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"offlineMode\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode OpenBatchSessionRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfOpenBatchSessionRequest) {
					name = jsonFieldsNameOfOpenBatchSessionRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *OpenBatchSessionRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OpenBatchSessionRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *OpenBatchSessionResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *OpenBatchSessionResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("referenceNumber")
		s.ReferenceNumber.Encode(e)
	}
	{
		e.FieldStart("partUploadRequests")
		e.ArrStart()
		for _, elem := range s.PartUploadRequests {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfOpenBatchSessionResponse = [2]string{
	0: "referenceNumber",
	1: "partUploadRequests",
}

// Decode decodes OpenBatchSessionResponse from json.
func (s *OpenBatchSessionResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OpenBatchSessionResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "referenceNumber":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ReferenceNumber.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"referenceNumber\"")
			}
		case "partUploadRequests":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.PartUploadRequests = make([]PartUploadRequest, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem PartUploadRequest
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.PartUploadRequests = append(s.PartUploadRequests, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"partUploadRequests\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode OpenBatchSessionResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfOpenBatchSessionResponse) {
					name = jsonFieldsNameOfOpenBatchSessionResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *OpenBatchSessionResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OpenBatchSessionResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *OpenOnlineSessionRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *OpenOnlineSessionRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("formCode")
		s.FormCode.Encode(e)
	}
	{
		e.FieldStart("encryption")
		s.Encryption.Encode(e)
	}
}

var jsonFieldsNameOfOpenOnlineSessionRequest = [2]string{
	0: "formCode",
	1: "encryption",
}

// Decode decodes OpenOnlineSessionRequest from json.
func (s *OpenOnlineSessionRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OpenOnlineSessionRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "formCode":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.FormCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"formCode\"")
			}
		case "encryption":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Encryption.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"encryption\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode OpenOnlineSessionRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfOpenOnlineSessionRequest) {
					name = jsonFieldsNameOfOpenOnlineSessionRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *OpenOnlineSessionRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OpenOnlineSessionRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *OpenOnlineSessionResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *OpenOnlineSessionResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("referenceNumber")
		s.ReferenceNumber.Encode(e)
	}
	{
		e.FieldStart("validUntil")
		json.EncodeDateTime(e, s.ValidUntil)
	}
}

var jsonFieldsNameOfOpenOnlineSessionResponse = [2]string{
	0: "referenceNumber",
	1: "validUntil",
}

// Decode decodes OpenOnlineSessionResponse from json.
func (s *OpenOnlineSessionResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OpenOnlineSessionResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "referenceNumber":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ReferenceNumber.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"referenceNumber\"")
			}
		case "validUntil":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.ValidUntil = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"validUntil\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode OpenOnlineSessionResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfOpenOnlineSessionResponse) {
					name = jsonFieldsNameOfOpenOnlineSessionResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *OpenOnlineSessionResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OpenOnlineSessionResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AttachmentPermissionGrantRequest as json.
func (o OptAttachmentPermissionGrantRequest) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes AttachmentPermissionGrantRequest from json.
func (o *OptAttachmentPermissionGrantRequest) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAttachmentPermissionGrantRequest to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAttachmentPermissionGrantRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAttachmentPermissionGrantRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AttachmentPermissionRevokeRequest as json.
func (o OptAttachmentPermissionRevokeRequest) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes AttachmentPermissionRevokeRequest from json.
func (o *OptAttachmentPermissionRevokeRequest) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAttachmentPermissionRevokeRequest to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAttachmentPermissionRevokeRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAttachmentPermissionRevokeRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes bool as json.
func (o OptBool) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Bool(bool(o.Value))
}

// Decode decodes bool from json.
func (o *OptBool) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBool to nil")
	}
	o.Set = true
	v, err := d.Bool()
	if err != nil {
		return err
	}
	o.Value = bool(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBool) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBool) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes time.Time as json.
func (o OptDateTime) Encode(e *jx.Encoder, format func(*jx.Encoder, time.Time)) {
	if !o.Set {
		return
	}
	format(e, o.Value)
}

// Decode decodes time.Time from json.
func (o *OptDateTime) Decode(d *jx.Decoder, format func(*jx.Decoder) (time.Time, error)) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDateTime to nil")
	}
	o.Set = true
	v, err := format(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDateTime) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e, json.EncodeDateTime)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDateTime) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d, json.DecodeDateTime)
}

// Encode encodes EnrollCertificateRequest as json.
func (o OptEnrollCertificateRequest) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes EnrollCertificateRequest from json.
func (o *OptEnrollCertificateRequest) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptEnrollCertificateRequest to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptEnrollCertificateRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptEnrollCertificateRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EntityAuthorizationPermissionsGrantRequest as json.
func (o OptEntityAuthorizationPermissionsGrantRequest) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes EntityAuthorizationPermissionsGrantRequest from json.
func (o *OptEntityAuthorizationPermissionsGrantRequest) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptEntityAuthorizationPermissionsGrantRequest to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptEntityAuthorizationPermissionsGrantRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptEntityAuthorizationPermissionsGrantRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EntityAuthorizationPermissionsQueryRequest as json.
func (o OptEntityAuthorizationPermissionsQueryRequest) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes EntityAuthorizationPermissionsQueryRequest from json.
func (o *OptEntityAuthorizationPermissionsQueryRequest) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptEntityAuthorizationPermissionsQueryRequest to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptEntityAuthorizationPermissionsQueryRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptEntityAuthorizationPermissionsQueryRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EntityPermissionsGrantRequest as json.
func (o OptEntityPermissionsGrantRequest) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes EntityPermissionsGrantRequest from json.
func (o *OptEntityPermissionsGrantRequest) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptEntityPermissionsGrantRequest to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptEntityPermissionsGrantRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptEntityPermissionsGrantRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EuEntityAdministrationPermissionsGrantRequest as json.
func (o OptEuEntityAdministrationPermissionsGrantRequest) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes EuEntityAdministrationPermissionsGrantRequest from json.
func (o *OptEuEntityAdministrationPermissionsGrantRequest) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptEuEntityAdministrationPermissionsGrantRequest to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptEuEntityAdministrationPermissionsGrantRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptEuEntityAdministrationPermissionsGrantRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EuEntityPermissionsGrantRequest as json.
func (o OptEuEntityPermissionsGrantRequest) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes EuEntityPermissionsGrantRequest from json.
func (o *OptEuEntityPermissionsGrantRequest) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptEuEntityPermissionsGrantRequest to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptEuEntityPermissionsGrantRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptEuEntityPermissionsGrantRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EuEntityPermissionsQueryRequest as json.
func (o OptEuEntityPermissionsQueryRequest) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes EuEntityPermissionsQueryRequest from json.
func (o *OptEuEntityPermissionsQueryRequest) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptEuEntityPermissionsQueryRequest to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptEuEntityPermissionsQueryRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptEuEntityPermissionsQueryRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GenerateTokenRequest as json.
func (o OptGenerateTokenRequest) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GenerateTokenRequest from json.
func (o *OptGenerateTokenRequest) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGenerateTokenRequest to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGenerateTokenRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGenerateTokenRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IndirectPermissionsGrantRequest as json.
func (o OptIndirectPermissionsGrantRequest) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IndirectPermissionsGrantRequest from json.
func (o *OptIndirectPermissionsGrantRequest) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIndirectPermissionsGrantRequest to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIndirectPermissionsGrantRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIndirectPermissionsGrantRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes InitTokenAuthenticationRequest as json.
func (o OptInitTokenAuthenticationRequest) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes InitTokenAuthenticationRequest from json.
func (o *OptInitTokenAuthenticationRequest) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInitTokenAuthenticationRequest to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInitTokenAuthenticationRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInitTokenAuthenticationRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int32 as json.
func (o OptInt32) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int32(int32(o.Value))
}

// Decode decodes int32 from json.
func (o *OptInt32) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt32 to nil")
	}
	o.Set = true
	v, err := d.Int32()
	if err != nil {
		return err
	}
	o.Value = int32(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInt32) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInt32) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes InvoiceExportRequest as json.
func (o OptInvoiceExportRequest) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes InvoiceExportRequest from json.
func (o *OptInvoiceExportRequest) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInvoiceExportRequest to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInvoiceExportRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInvoiceExportRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes InvoiceQueryFilters as json.
func (o OptInvoiceQueryFilters) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes InvoiceQueryFilters from json.
func (o *OptInvoiceQueryFilters) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInvoiceQueryFilters to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInvoiceQueryFilters) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInvoiceQueryFilters) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AllowedIps as json.
func (o OptNilAllowedIps) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes AllowedIps from json.
func (o *OptNilAllowedIps) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilAllowedIps to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v AllowedIps
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilAllowedIps) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilAllowedIps) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AuthorizationPolicy as json.
func (o OptNilAuthorizationPolicy) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes AuthorizationPolicy from json.
func (o *OptNilAuthorizationPolicy) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilAuthorizationPolicy to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v AuthorizationPolicy
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilAuthorizationPolicy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilAuthorizationPolicy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes bool as json.
func (o OptNilBool) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Bool(bool(o.Value))
}

// Decode decodes bool from json.
func (o *OptNilBool) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilBool to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v bool
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	v, err := d.Bool()
	if err != nil {
		return err
	}
	o.Value = bool(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilBool) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilBool) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CertificateEffectiveSubjectLimits as json.
func (o OptNilCertificateEffectiveSubjectLimits) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CertificateEffectiveSubjectLimits from json.
func (o *OptNilCertificateEffectiveSubjectLimits) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilCertificateEffectiveSubjectLimits to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v CertificateEffectiveSubjectLimits
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilCertificateEffectiveSubjectLimits) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilCertificateEffectiveSubjectLimits) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CertificateListItemStatus as json.
func (o OptNilCertificateListItemStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CertificateListItemStatus from json.
func (o *OptNilCertificateListItemStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilCertificateListItemStatus to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v CertificateListItemStatus
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilCertificateListItemStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilCertificateListItemStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CertificateRevocationReason as json.
func (o OptNilCertificateRevocationReason) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CertificateRevocationReason from json.
func (o *OptNilCertificateRevocationReason) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilCertificateRevocationReason to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v CertificateRevocationReason
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilCertificateRevocationReason) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilCertificateRevocationReason) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CertificateSubjectLimitsOverride as json.
func (o OptNilCertificateSubjectLimitsOverride) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CertificateSubjectLimitsOverride from json.
func (o *OptNilCertificateSubjectLimitsOverride) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilCertificateSubjectLimitsOverride to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v CertificateSubjectLimitsOverride
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilCertificateSubjectLimitsOverride) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilCertificateSubjectLimitsOverride) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes []CurrencyCode as json.
func (o OptNilCurrencyCodeArray) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.ArrStart()
	for _, elem := range o.Value {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes []CurrencyCode from json.
func (o *OptNilCurrencyCodeArray) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilCurrencyCodeArray to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v []CurrencyCode
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	o.Value = make([]CurrencyCode, 0)
	if err := d.Arr(func(d *jx.Decoder) error {
		var elem CurrencyCode
		if err := elem.Decode(d); err != nil {
			return err
		}
		o.Value = append(o.Value, elem)
		return nil
	}); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilCurrencyCodeArray) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilCurrencyCodeArray) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes time.Time as json.
func (o OptNilDate) Encode(e *jx.Encoder, format func(*jx.Encoder, time.Time)) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	format(e, o.Value)
}

// Decode decodes time.Time from json.
func (o *OptNilDate) Decode(d *jx.Decoder, format func(*jx.Decoder) (time.Time, error)) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilDate to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v time.Time
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	v, err := format(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilDate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e, json.EncodeDate)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilDate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d, json.DecodeDate)
}

// Encode encodes time.Time as json.
func (o OptNilDateTime) Encode(e *jx.Encoder, format func(*jx.Encoder, time.Time)) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	format(e, o.Value)
}

// Decode decodes time.Time from json.
func (o *OptNilDateTime) Decode(d *jx.Decoder, format func(*jx.Decoder) (time.Time, error)) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilDateTime to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v time.Time
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	v, err := format(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilDateTime) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e, json.EncodeDateTime)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilDateTime) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d, json.DecodeDateTime)
}

// Encode encodes EnrollmentEffectiveSubjectLimits as json.
func (o OptNilEnrollmentEffectiveSubjectLimits) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes EnrollmentEffectiveSubjectLimits from json.
func (o *OptNilEnrollmentEffectiveSubjectLimits) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilEnrollmentEffectiveSubjectLimits to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v EnrollmentEffectiveSubjectLimits
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilEnrollmentEffectiveSubjectLimits) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilEnrollmentEffectiveSubjectLimits) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EnrollmentSubjectLimitsOverride as json.
func (o OptNilEnrollmentSubjectLimitsOverride) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes EnrollmentSubjectLimitsOverride from json.
func (o *OptNilEnrollmentSubjectLimitsOverride) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilEnrollmentSubjectLimitsOverride to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v EnrollmentSubjectLimitsOverride
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilEnrollmentSubjectLimitsOverride) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilEnrollmentSubjectLimitsOverride) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EntityAuthorizationsAuthorIdentifier as json.
func (o OptNilEntityAuthorizationsAuthorIdentifier) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes EntityAuthorizationsAuthorIdentifier from json.
func (o *OptNilEntityAuthorizationsAuthorIdentifier) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilEntityAuthorizationsAuthorIdentifier to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v EntityAuthorizationsAuthorIdentifier
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilEntityAuthorizationsAuthorIdentifier) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilEntityAuthorizationsAuthorIdentifier) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EntityAuthorizationsAuthorizedEntityIdentifier as json.
func (o OptNilEntityAuthorizationsAuthorizedEntityIdentifier) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes EntityAuthorizationsAuthorizedEntityIdentifier from json.
func (o *OptNilEntityAuthorizationsAuthorizedEntityIdentifier) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilEntityAuthorizationsAuthorizedEntityIdentifier to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v EntityAuthorizationsAuthorizedEntityIdentifier
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilEntityAuthorizationsAuthorizedEntityIdentifier) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilEntityAuthorizationsAuthorizedEntityIdentifier) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EntityAuthorizationsAuthorizingEntityIdentifier as json.
func (o OptNilEntityAuthorizationsAuthorizingEntityIdentifier) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes EntityAuthorizationsAuthorizingEntityIdentifier from json.
func (o *OptNilEntityAuthorizationsAuthorizingEntityIdentifier) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilEntityAuthorizationsAuthorizingEntityIdentifier to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v EntityAuthorizationsAuthorizingEntityIdentifier
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilEntityAuthorizationsAuthorizingEntityIdentifier) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilEntityAuthorizationsAuthorizingEntityIdentifier) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EntityPermissionsSubordinateEntityIdentifier as json.
func (o OptNilEntityPermissionsSubordinateEntityIdentifier) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes EntityPermissionsSubordinateEntityIdentifier from json.
func (o *OptNilEntityPermissionsSubordinateEntityIdentifier) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilEntityPermissionsSubordinateEntityIdentifier to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v EntityPermissionsSubordinateEntityIdentifier
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilEntityPermissionsSubordinateEntityIdentifier) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilEntityPermissionsSubordinateEntityIdentifier) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EntityRolesParentEntityIdentifier as json.
func (o OptNilEntityRolesParentEntityIdentifier) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes EntityRolesParentEntityIdentifier from json.
func (o *OptNilEntityRolesParentEntityIdentifier) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilEntityRolesParentEntityIdentifier to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v EntityRolesParentEntityIdentifier
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilEntityRolesParentEntityIdentifier) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilEntityRolesParentEntityIdentifier) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes []EuEntityPermissionsQueryPermissionType as json.
func (o OptNilEuEntityPermissionsQueryPermissionTypeArray) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.ArrStart()
	for _, elem := range o.Value {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes []EuEntityPermissionsQueryPermissionType from json.
func (o *OptNilEuEntityPermissionsQueryPermissionTypeArray) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilEuEntityPermissionsQueryPermissionTypeArray to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v []EuEntityPermissionsQueryPermissionType
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	o.Value = make([]EuEntityPermissionsQueryPermissionType, 0)
	if err := d.Arr(func(d *jx.Decoder) error {
		var elem EuEntityPermissionsQueryPermissionType
		if err := elem.Decode(d); err != nil {
			return err
		}
		o.Value = append(o.Value, elem)
		return nil
	}); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilEuEntityPermissionsQueryPermissionTypeArray) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilEuEntityPermissionsQueryPermissionTypeArray) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes []ExceptionDetails as json.
func (o OptNilExceptionDetailsArray) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.ArrStart()
	for _, elem := range o.Value {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes []ExceptionDetails from json.
func (o *OptNilExceptionDetailsArray) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilExceptionDetailsArray to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v []ExceptionDetails
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	o.Value = make([]ExceptionDetails, 0)
	if err := d.Arr(func(d *jx.Decoder) error {
		var elem ExceptionDetails
		if err := elem.Decode(d); err != nil {
			return err
		}
		o.Value = append(o.Value, elem)
		return nil
	}); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilExceptionDetailsArray) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilExceptionDetailsArray) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ExceptionInfo as json.
func (o OptNilExceptionInfo) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ExceptionInfo from json.
func (o *OptNilExceptionInfo) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilExceptionInfo to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v ExceptionInfo
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilExceptionInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilExceptionInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes float64 as json.
func (o OptNilFloat64) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Float64(float64(o.Value))
}

// Decode decodes float64 from json.
func (o *OptNilFloat64) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilFloat64 to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v float64
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	v, err := d.Float64()
	if err != nil {
		return err
	}
	o.Value = float64(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilFloat64) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilFloat64) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IndirectPermissionsTargetIdentifier as json.
func (o OptNilIndirectPermissionsTargetIdentifier) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IndirectPermissionsTargetIdentifier from json.
func (o *OptNilIndirectPermissionsTargetIdentifier) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilIndirectPermissionsTargetIdentifier to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v IndirectPermissionsTargetIdentifier
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilIndirectPermissionsTargetIdentifier) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilIndirectPermissionsTargetIdentifier) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int32 as json.
func (o OptNilInt32) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Int32(int32(o.Value))
}

// Decode decodes int32 from json.
func (o *OptNilInt32) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilInt32 to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v int32
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	v, err := d.Int32()
	if err != nil {
		return err
	}
	o.Value = int32(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilInt32) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilInt32) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes InvoiceMetadataAuthorizedSubject as json.
func (o OptNilInvoiceMetadataAuthorizedSubject) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes InvoiceMetadataAuthorizedSubject from json.
func (o *OptNilInvoiceMetadataAuthorizedSubject) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilInvoiceMetadataAuthorizedSubject to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v InvoiceMetadataAuthorizedSubject
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilInvoiceMetadataAuthorizedSubject) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilInvoiceMetadataAuthorizedSubject) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes []InvoiceMetadataThirdSubject as json.
func (o OptNilInvoiceMetadataThirdSubjectArray) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.ArrStart()
	for _, elem := range o.Value {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes []InvoiceMetadataThirdSubject from json.
func (o *OptNilInvoiceMetadataThirdSubjectArray) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilInvoiceMetadataThirdSubjectArray to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v []InvoiceMetadataThirdSubject
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	o.Value = make([]InvoiceMetadataThirdSubject, 0)
	if err := d.Arr(func(d *jx.Decoder) error {
		var elem InvoiceMetadataThirdSubject
		if err := elem.Decode(d); err != nil {
			return err
		}
		o.Value = append(o.Value, elem)
		return nil
	}); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilInvoiceMetadataThirdSubjectArray) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilInvoiceMetadataThirdSubjectArray) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes InvoicePackage as json.
func (o OptNilInvoicePackage) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes InvoicePackage from json.
func (o *OptNilInvoicePackage) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilInvoicePackage to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v InvoicePackage
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilInvoicePackage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilInvoicePackage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes []InvoicePermissionType as json.
func (o OptNilInvoicePermissionTypeArray) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.ArrStart()
	for _, elem := range o.Value {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes []InvoicePermissionType from json.
func (o *OptNilInvoicePermissionTypeArray) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilInvoicePermissionTypeArray to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v []InvoicePermissionType
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	o.Value = make([]InvoicePermissionType, 0)
	if err := d.Arr(func(d *jx.Decoder) error {
		var elem InvoicePermissionType
		if err := elem.Decode(d); err != nil {
			return err
		}
		o.Value = append(o.Value, elem)
		return nil
	}); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilInvoicePermissionTypeArray) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilInvoicePermissionTypeArray) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes InvoiceQueryAmount as json.
func (o OptNilInvoiceQueryAmount) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes InvoiceQueryAmount from json.
func (o *OptNilInvoiceQueryAmount) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilInvoiceQueryAmount to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v InvoiceQueryAmount
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilInvoiceQueryAmount) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilInvoiceQueryAmount) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes InvoiceQueryBuyerIdentifier as json.
func (o OptNilInvoiceQueryBuyerIdentifier) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes InvoiceQueryBuyerIdentifier from json.
func (o *OptNilInvoiceQueryBuyerIdentifier) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilInvoiceQueryBuyerIdentifier to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v InvoiceQueryBuyerIdentifier
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilInvoiceQueryBuyerIdentifier) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilInvoiceQueryBuyerIdentifier) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes InvoiceQueryFormType as json.
func (o OptNilInvoiceQueryFormType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes InvoiceQueryFormType from json.
func (o *OptNilInvoiceQueryFormType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilInvoiceQueryFormType to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v InvoiceQueryFormType
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilInvoiceQueryFormType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilInvoiceQueryFormType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes []InvoiceType as json.
func (o OptNilInvoiceTypeArray) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.ArrStart()
	for _, elem := range o.Value {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes []InvoiceType from json.
func (o *OptNilInvoiceTypeArray) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilInvoiceTypeArray to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v []InvoiceType
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	o.Value = make([]InvoiceType, 0)
	if err := d.Arr(func(d *jx.Decoder) error {
		var elem InvoiceType
		if err := elem.Decode(d); err != nil {
			return err
		}
		o.Value = append(o.Value, elem)
		return nil
	}); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilInvoiceTypeArray) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilInvoiceTypeArray) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes InvoicingMode as json.
func (o OptNilInvoicingMode) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes InvoicingMode from json.
func (o *OptNilInvoicingMode) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilInvoicingMode to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v InvoicingMode
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilInvoicingMode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilInvoicingMode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes KsefCertificateType as json.
func (o OptNilKsefCertificateType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes KsefCertificateType from json.
func (o *OptNilKsefCertificateType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilKsefCertificateType to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v KsefCertificateType
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilKsefCertificateType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilKsefCertificateType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes KsefNumber as json.
func (o OptNilKsefNumber) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes KsefNumber from json.
func (o *OptNilKsefNumber) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilKsefNumber to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v KsefNumber
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilKsefNumber) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilKsefNumber) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Nip as json.
func (o OptNilNip) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Nip from json.
func (o *OptNilNip) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilNip to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v Nip
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilNip) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilNip) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PermissionState as json.
func (o OptNilPermissionState) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes PermissionState from json.
func (o *OptNilPermissionState) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilPermissionState to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v PermissionState
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilPermissionState) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilPermissionState) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes []PersonPermissionType as json.
func (o OptNilPersonPermissionTypeArray) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.ArrStart()
	for _, elem := range o.Value {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes []PersonPermissionType from json.
func (o *OptNilPersonPermissionTypeArray) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilPersonPermissionTypeArray to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v []PersonPermissionType
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	o.Value = make([]PersonPermissionType, 0)
	if err := d.Arr(func(d *jx.Decoder) error {
		var elem PersonPermissionType
		if err := elem.Decode(d); err != nil {
			return err
		}
		o.Value = append(o.Value, elem)
		return nil
	}); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilPersonPermissionTypeArray) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilPersonPermissionTypeArray) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PersonPermissionsAuthorIdentifier as json.
func (o OptNilPersonPermissionsAuthorIdentifier) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PersonPermissionsAuthorIdentifier from json.
func (o *OptNilPersonPermissionsAuthorIdentifier) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilPersonPermissionsAuthorIdentifier to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v PersonPermissionsAuthorIdentifier
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilPersonPermissionsAuthorIdentifier) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilPersonPermissionsAuthorIdentifier) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PersonPermissionsAuthorizedIdentifier as json.
func (o OptNilPersonPermissionsAuthorizedIdentifier) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PersonPermissionsAuthorizedIdentifier from json.
func (o *OptNilPersonPermissionsAuthorizedIdentifier) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilPersonPermissionsAuthorizedIdentifier to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v PersonPermissionsAuthorizedIdentifier
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilPersonPermissionsAuthorizedIdentifier) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilPersonPermissionsAuthorizedIdentifier) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PersonPermissionsContextIdentifier as json.
func (o OptNilPersonPermissionsContextIdentifier) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PersonPermissionsContextIdentifier from json.
func (o *OptNilPersonPermissionsContextIdentifier) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilPersonPermissionsContextIdentifier to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v PersonPermissionsContextIdentifier
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilPersonPermissionsContextIdentifier) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilPersonPermissionsContextIdentifier) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PersonPermissionsTargetIdentifier as json.
func (o OptNilPersonPermissionsTargetIdentifier) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PersonPermissionsTargetIdentifier from json.
func (o *OptNilPersonPermissionsTargetIdentifier) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilPersonPermissionsTargetIdentifier to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v PersonPermissionsTargetIdentifier
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilPersonPermissionsTargetIdentifier) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilPersonPermissionsTargetIdentifier) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes []PersonalPermissionType as json.
func (o OptNilPersonalPermissionTypeArray) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.ArrStart()
	for _, elem := range o.Value {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes []PersonalPermissionType from json.
func (o *OptNilPersonalPermissionTypeArray) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilPersonalPermissionTypeArray to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v []PersonalPermissionType
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	o.Value = make([]PersonalPermissionType, 0)
	if err := d.Arr(func(d *jx.Decoder) error {
		var elem PersonalPermissionType
		if err := elem.Decode(d); err != nil {
			return err
		}
		o.Value = append(o.Value, elem)
		return nil
	}); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilPersonalPermissionTypeArray) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilPersonalPermissionTypeArray) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PersonalPermissionsAuthorizedIdentifier as json.
func (o OptNilPersonalPermissionsAuthorizedIdentifier) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PersonalPermissionsAuthorizedIdentifier from json.
func (o *OptNilPersonalPermissionsAuthorizedIdentifier) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilPersonalPermissionsAuthorizedIdentifier to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v PersonalPermissionsAuthorizedIdentifier
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilPersonalPermissionsAuthorizedIdentifier) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilPersonalPermissionsAuthorizedIdentifier) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PersonalPermissionsContextIdentifier as json.
func (o OptNilPersonalPermissionsContextIdentifier) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PersonalPermissionsContextIdentifier from json.
func (o *OptNilPersonalPermissionsContextIdentifier) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilPersonalPermissionsContextIdentifier to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v PersonalPermissionsContextIdentifier
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilPersonalPermissionsContextIdentifier) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilPersonalPermissionsContextIdentifier) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PersonalPermissionsTargetIdentifier as json.
func (o OptNilPersonalPermissionsTargetIdentifier) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PersonalPermissionsTargetIdentifier from json.
func (o *OptNilPersonalPermissionsTargetIdentifier) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilPersonalPermissionsTargetIdentifier to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v PersonalPermissionsTargetIdentifier
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilPersonalPermissionsTargetIdentifier) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilPersonalPermissionsTargetIdentifier) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReferenceNumber as json.
func (o OptNilReferenceNumber) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ReferenceNumber from json.
func (o *OptNilReferenceNumber) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilReferenceNumber to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v ReferenceNumber
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilReferenceNumber) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilReferenceNumber) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Sha256HashBase64 as json.
func (o OptNilSha256HashBase64) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Sha256HashBase64 from json.
func (o *OptNilSha256HashBase64) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilSha256HashBase64 to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v Sha256HashBase64
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilSha256HashBase64) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilSha256HashBase64) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o OptNilString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptNilString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilString to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v string
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes []string as json.
func (o OptNilStringArray) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.ArrStart()
	for _, elem := range o.Value {
		e.Str(elem)
	}
	e.ArrEnd()
}

// Decode decodes []string from json.
func (o *OptNilStringArray) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilStringArray to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v []string
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	o.Value = make([]string, 0)
	if err := d.Arr(func(d *jx.Decoder) error {
		var elem string
		v, err := d.Str()
		elem = string(v)
		if err != nil {
			return err
		}
		o.Value = append(o.Value, elem)
		return nil
	}); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilStringArray) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilStringArray) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes []Subunit as json.
func (o OptNilSubunitArray) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.ArrStart()
	for _, elem := range o.Value {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes []Subunit from json.
func (o *OptNilSubunitArray) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilSubunitArray to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v []Subunit
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	o.Value = make([]Subunit, 0)
	if err := d.Arr(func(d *jx.Decoder) error {
		var elem Subunit
		if err := elem.Decode(d); err != nil {
			return err
		}
		o.Value = append(o.Value, elem)
		return nil
	}); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilSubunitArray) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilSubunitArray) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SubunitPermissionsSubunitIdentifier as json.
func (o OptNilSubunitPermissionsSubunitIdentifier) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SubunitPermissionsSubunitIdentifier from json.
func (o *OptNilSubunitPermissionsSubunitIdentifier) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilSubunitPermissionsSubunitIdentifier to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v SubunitPermissionsSubunitIdentifier
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilSubunitPermissionsSubunitIdentifier) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilSubunitPermissionsSubunitIdentifier) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes url.URL as json.
func (o OptNilURI) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	json.EncodeURI(e, o.Value)
}

// Decode decodes url.URL from json.
func (o *OptNilURI) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilURI to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v url.URL
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	v, err := json.DecodeURI(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilURI) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilURI) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpoResponse as json.
func (o OptNilUpoResponse) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes UpoResponse from json.
func (o *OptNilUpoResponse) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilUpoResponse to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v UpoResponse
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilUpoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilUpoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes OpenBatchSessionRequest as json.
func (o OptOpenBatchSessionRequest) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes OpenBatchSessionRequest from json.
func (o *OptOpenBatchSessionRequest) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptOpenBatchSessionRequest to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptOpenBatchSessionRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptOpenBatchSessionRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes OpenOnlineSessionRequest as json.
func (o OptOpenOnlineSessionRequest) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes OpenOnlineSessionRequest from json.
func (o *OptOpenOnlineSessionRequest) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptOpenOnlineSessionRequest to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptOpenOnlineSessionRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptOpenOnlineSessionRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PersonCreateRequest as json.
func (o OptPersonCreateRequest) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PersonCreateRequest from json.
func (o *OptPersonCreateRequest) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPersonCreateRequest to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPersonCreateRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPersonCreateRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PersonPermissionsGrantRequest as json.
func (o OptPersonPermissionsGrantRequest) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PersonPermissionsGrantRequest from json.
func (o *OptPersonPermissionsGrantRequest) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPersonPermissionsGrantRequest to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPersonPermissionsGrantRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPersonPermissionsGrantRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PersonPermissionsQueryRequest as json.
func (o OptPersonPermissionsQueryRequest) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PersonPermissionsQueryRequest from json.
func (o *OptPersonPermissionsQueryRequest) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPersonPermissionsQueryRequest to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPersonPermissionsQueryRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPersonPermissionsQueryRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PersonRemoveRequest as json.
func (o OptPersonRemoveRequest) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PersonRemoveRequest from json.
func (o *OptPersonRemoveRequest) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPersonRemoveRequest to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPersonRemoveRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPersonRemoveRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PersonalPermissionsQueryRequest as json.
func (o OptPersonalPermissionsQueryRequest) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PersonalPermissionsQueryRequest from json.
func (o *OptPersonalPermissionsQueryRequest) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPersonalPermissionsQueryRequest to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPersonalPermissionsQueryRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPersonalPermissionsQueryRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes QueryCertificatesRequest as json.
func (o OptQueryCertificatesRequest) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes QueryCertificatesRequest from json.
func (o *OptQueryCertificatesRequest) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptQueryCertificatesRequest to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptQueryCertificatesRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptQueryCertificatesRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReferenceNumber as json.
func (o OptReferenceNumber) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ReferenceNumber from json.
func (o *OptReferenceNumber) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptReferenceNumber to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptReferenceNumber) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptReferenceNumber) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RetrieveCertificatesRequest as json.
func (o OptRetrieveCertificatesRequest) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes RetrieveCertificatesRequest from json.
func (o *OptRetrieveCertificatesRequest) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptRetrieveCertificatesRequest to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptRetrieveCertificatesRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptRetrieveCertificatesRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RevokeCertificateRequest as json.
func (o OptRevokeCertificateRequest) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes RevokeCertificateRequest from json.
func (o *OptRevokeCertificateRequest) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptRevokeCertificateRequest to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptRevokeCertificateRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptRevokeCertificateRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SendInvoiceRequest as json.
func (o OptSendInvoiceRequest) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SendInvoiceRequest from json.
func (o *OptSendInvoiceRequest) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSendInvoiceRequest to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSendInvoiceRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSendInvoiceRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SetRateLimitsRequest as json.
func (o OptSetRateLimitsRequest) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SetRateLimitsRequest from json.
func (o *OptSetRateLimitsRequest) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSetRateLimitsRequest to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSetRateLimitsRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSetRateLimitsRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SetSessionLimitsRequest as json.
func (o OptSetSessionLimitsRequest) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SetSessionLimitsRequest from json.
func (o *OptSetSessionLimitsRequest) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSetSessionLimitsRequest to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSetSessionLimitsRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSetSessionLimitsRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SetSubjectLimitsRequest as json.
func (o OptSetSubjectLimitsRequest) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SetSubjectLimitsRequest from json.
func (o *OptSetSubjectLimitsRequest) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSetSubjectLimitsRequest to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSetSubjectLimitsRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSetSubjectLimitsRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SubjectCreateRequest as json.
func (o OptSubjectCreateRequest) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SubjectCreateRequest from json.
func (o *OptSubjectCreateRequest) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSubjectCreateRequest to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSubjectCreateRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSubjectCreateRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SubjectIdentifierType as json.
func (o OptSubjectIdentifierType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes SubjectIdentifierType from json.
func (o *OptSubjectIdentifierType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSubjectIdentifierType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSubjectIdentifierType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSubjectIdentifierType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SubjectRemoveRequest as json.
func (o OptSubjectRemoveRequest) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SubjectRemoveRequest from json.
func (o *OptSubjectRemoveRequest) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSubjectRemoveRequest to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSubjectRemoveRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSubjectRemoveRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SubordinateEntityRolesQueryRequest as json.
func (o OptSubordinateEntityRolesQueryRequest) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SubordinateEntityRolesQueryRequest from json.
func (o *OptSubordinateEntityRolesQueryRequest) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSubordinateEntityRolesQueryRequest to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSubordinateEntityRolesQueryRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSubordinateEntityRolesQueryRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SubunitPermissionsGrantRequest as json.
func (o OptSubunitPermissionsGrantRequest) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SubunitPermissionsGrantRequest from json.
func (o *OptSubunitPermissionsGrantRequest) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSubunitPermissionsGrantRequest to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSubunitPermissionsGrantRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSubunitPermissionsGrantRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SubunitPermissionsQueryRequest as json.
func (o OptSubunitPermissionsQueryRequest) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SubunitPermissionsQueryRequest from json.
func (o *OptSubunitPermissionsQueryRequest) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSubunitPermissionsQueryRequest to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSubunitPermissionsQueryRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSubunitPermissionsQueryRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TestDataPermissionsGrantRequest as json.
func (o OptTestDataPermissionsGrantRequest) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes TestDataPermissionsGrantRequest from json.
func (o *OptTestDataPermissionsGrantRequest) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTestDataPermissionsGrantRequest to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTestDataPermissionsGrantRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTestDataPermissionsGrantRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TestDataPermissionsRevokeRequest as json.
func (o OptTestDataPermissionsRevokeRequest) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes TestDataPermissionsRevokeRequest from json.
func (o *OptTestDataPermissionsRevokeRequest) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTestDataPermissionsRevokeRequest to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTestDataPermissionsRevokeRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTestDataPermissionsRevokeRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PartUploadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PartUploadRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("ordinalNumber")
		e.Int32(s.OrdinalNumber)
	}
	{
		e.FieldStart("method")
		e.Str(s.Method)
	}
	{
		e.FieldStart("url")
		json.EncodeURI(e, s.URL)
	}
	{
		e.FieldStart("headers")
		s.Headers.Encode(e)
	}
}

var jsonFieldsNameOfPartUploadRequest = [4]string{
	0: "ordinalNumber",
	1: "method",
	2: "url",
	3: "headers",
}

// Decode decodes PartUploadRequest from json.
func (s *PartUploadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PartUploadRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ordinalNumber":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.OrdinalNumber = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ordinalNumber\"")
			}
		case "method":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Method = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"method\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "headers":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Headers.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"headers\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PartUploadRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPartUploadRequest) {
					name = jsonFieldsNameOfPartUploadRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PartUploadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PartUploadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s PartUploadRequestHeaders) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s PartUploadRequestHeaders) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		elem.Encode(e)
	}
}

// Decode decodes PartUploadRequestHeaders from json.
func (s *PartUploadRequestHeaders) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PartUploadRequestHeaders to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem NilString
		if err := func() error {
			if err := elem.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PartUploadRequestHeaders")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PartUploadRequestHeaders) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PartUploadRequestHeaders) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PeppolId as json.
func (s PeppolId) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes PeppolId from json.
func (s *PeppolId) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PeppolId to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PeppolId(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PeppolId) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PeppolId) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PeppolProvider) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PeppolProvider) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		s.ID.Encode(e)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("dateCreated")
		json.EncodeDateTime(e, s.DateCreated)
	}
}

var jsonFieldsNameOfPeppolProvider = [3]string{
	0: "id",
	1: "name",
	2: "dateCreated",
}

// Decode decodes PeppolProvider from json.
func (s *PeppolProvider) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PeppolProvider to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "dateCreated":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.DateCreated = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dateCreated\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PeppolProvider")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPeppolProvider) {
					name = jsonFieldsNameOfPeppolProvider[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PeppolProvider) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PeppolProvider) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PermissionId as json.
func (s PermissionId) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes PermissionId from json.
func (s *PermissionId) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PermissionId to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PermissionId(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PermissionId) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PermissionId) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PermissionState as json.
func (s PermissionState) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PermissionState from json.
func (s *PermissionState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PermissionState to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PermissionState(v) {
	case PermissionStateActive:
		*s = PermissionStateActive
	case PermissionStateInactive:
		*s = PermissionStateInactive
	default:
		*s = PermissionState(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PermissionState) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PermissionState) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PermissionsOperationResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PermissionsOperationResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("referenceNumber")
		s.ReferenceNumber.Encode(e)
	}
}

var jsonFieldsNameOfPermissionsOperationResponse = [1]string{
	0: "referenceNumber",
}

// Decode decodes PermissionsOperationResponse from json.
func (s *PermissionsOperationResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PermissionsOperationResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "referenceNumber":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ReferenceNumber.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"referenceNumber\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PermissionsOperationResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPermissionsOperationResponse) {
					name = jsonFieldsNameOfPermissionsOperationResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PermissionsOperationResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PermissionsOperationResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PermissionsOperationStatusResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PermissionsOperationStatusResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("status")
		s.Status.Encode(e)
	}
}

var jsonFieldsNameOfPermissionsOperationStatusResponse = [1]string{
	0: "status",
}

// Decode decodes PermissionsOperationStatusResponse from json.
func (s *PermissionsOperationStatusResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PermissionsOperationStatusResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "status":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PermissionsOperationStatusResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPermissionsOperationStatusResponse) {
					name = jsonFieldsNameOfPermissionsOperationStatusResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PermissionsOperationStatusResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PermissionsOperationStatusResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PersonCreateRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PersonCreateRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("nip")
		s.Nip.Encode(e)
	}
	{
		e.FieldStart("pesel")
		s.Pesel.Encode(e)
	}
	{
		e.FieldStart("isBailiff")
		e.Bool(s.IsBailiff)
	}
	{
		e.FieldStart("description")
		e.Str(s.Description)
	}
	{
		if s.IsDeceased.Set {
			e.FieldStart("isDeceased")
			s.IsDeceased.Encode(e)
		}
	}
	{
		if s.CreatedDate.Set {
			e.FieldStart("createdDate")
			s.CreatedDate.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfPersonCreateRequest = [6]string{
	0: "nip",
	1: "pesel",
	2: "isBailiff",
	3: "description",
	4: "isDeceased",
	5: "createdDate",
}

// Decode decodes PersonCreateRequest from json.
func (s *PersonCreateRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PersonCreateRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "nip":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Nip.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nip\"")
			}
		case "pesel":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Pesel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pesel\"")
			}
		case "isBailiff":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Bool()
				s.IsBailiff = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isBailiff\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "isDeceased":
			if err := func() error {
				s.IsDeceased.Reset()
				if err := s.IsDeceased.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isDeceased\"")
			}
		case "createdDate":
			if err := func() error {
				s.CreatedDate.Reset()
				if err := s.CreatedDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdDate\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PersonCreateRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPersonCreateRequest) {
					name = jsonFieldsNameOfPersonCreateRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PersonCreateRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PersonCreateRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PersonPermission) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PersonPermission) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		s.ID.Encode(e)
	}
	{
		e.FieldStart("authorizedIdentifier")
		s.AuthorizedIdentifier.Encode(e)
	}
	{
		if s.ContextIdentifier.Set {
			e.FieldStart("contextIdentifier")
			s.ContextIdentifier.Encode(e)
		}
	}
	{
		if s.TargetIdentifier.Set {
			e.FieldStart("targetIdentifier")
			s.TargetIdentifier.Encode(e)
		}
	}
	{
		e.FieldStart("authorIdentifier")
		s.AuthorIdentifier.Encode(e)
	}
	{
		e.FieldStart("permissionScope")
		s.PermissionScope.Encode(e)
	}
	{
		e.FieldStart("description")
		e.Str(s.Description)
	}
	{
		e.FieldStart("permissionState")
		s.PermissionState.Encode(e)
	}
	{
		e.FieldStart("startDate")
		json.EncodeDateTime(e, s.StartDate)
	}
	{
		e.FieldStart("canDelegate")
		e.Bool(s.CanDelegate)
	}
}

var jsonFieldsNameOfPersonPermission = [10]string{
	0: "id",
	1: "authorizedIdentifier",
	2: "contextIdentifier",
	3: "targetIdentifier",
	4: "authorIdentifier",
	5: "permissionScope",
	6: "description",
	7: "permissionState",
	8: "startDate",
	9: "canDelegate",
}

// Decode decodes PersonPermission from json.
func (s *PersonPermission) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PersonPermission to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "authorizedIdentifier":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.AuthorizedIdentifier.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"authorizedIdentifier\"")
			}
		case "contextIdentifier":
			if err := func() error {
				s.ContextIdentifier.Reset()
				if err := s.ContextIdentifier.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"contextIdentifier\"")
			}
		case "targetIdentifier":
			if err := func() error {
				s.TargetIdentifier.Reset()
				if err := s.TargetIdentifier.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"targetIdentifier\"")
			}
		case "authorIdentifier":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.AuthorIdentifier.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"authorIdentifier\"")
			}
		case "permissionScope":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.PermissionScope.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"permissionScope\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "permissionState":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.PermissionState.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"permissionState\"")
			}
		case "startDate":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.StartDate = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"startDate\"")
			}
		case "canDelegate":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.CanDelegate = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"canDelegate\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PersonPermission")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11110011,
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPersonPermission) {
					name = jsonFieldsNameOfPersonPermission[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PersonPermission) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PersonPermission) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PersonPermissionScope as json.
func (s PersonPermissionScope) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PersonPermissionScope from json.
func (s *PersonPermissionScope) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PersonPermissionScope to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PersonPermissionScope(v) {
	case PersonPermissionScopeCredentialsManage:
		*s = PersonPermissionScopeCredentialsManage
	case PersonPermissionScopeCredentialsRead:
		*s = PersonPermissionScopeCredentialsRead
	case PersonPermissionScopeInvoiceWrite:
		*s = PersonPermissionScopeInvoiceWrite
	case PersonPermissionScopeInvoiceRead:
		*s = PersonPermissionScopeInvoiceRead
	case PersonPermissionScopeIntrospection:
		*s = PersonPermissionScopeIntrospection
	case PersonPermissionScopeSubunitManage:
		*s = PersonPermissionScopeSubunitManage
	case PersonPermissionScopeEnforcementOperations:
		*s = PersonPermissionScopeEnforcementOperations
	default:
		*s = PersonPermissionScope(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PersonPermissionScope) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PersonPermissionScope) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PersonPermissionType as json.
func (s PersonPermissionType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PersonPermissionType from json.
func (s *PersonPermissionType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PersonPermissionType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PersonPermissionType(v) {
	case PersonPermissionTypeCredentialsManage:
		*s = PersonPermissionTypeCredentialsManage
	case PersonPermissionTypeCredentialsRead:
		*s = PersonPermissionTypeCredentialsRead
	case PersonPermissionTypeInvoiceWrite:
		*s = PersonPermissionTypeInvoiceWrite
	case PersonPermissionTypeInvoiceRead:
		*s = PersonPermissionTypeInvoiceRead
	case PersonPermissionTypeIntrospection:
		*s = PersonPermissionTypeIntrospection
	case PersonPermissionTypeSubunitManage:
		*s = PersonPermissionTypeSubunitManage
	case PersonPermissionTypeEnforcementOperations:
		*s = PersonPermissionTypeEnforcementOperations
	default:
		*s = PersonPermissionType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PersonPermissionType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PersonPermissionType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PersonPermissionsAuthorIdentifier) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PersonPermissionsAuthorIdentifier) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		if s.Value.Set {
			e.FieldStart("value")
			s.Value.Encode(e)
		}
	}
}

var jsonFieldsNameOfPersonPermissionsAuthorIdentifier = [2]string{
	0: "type",
	1: "value",
}

// Decode decodes PersonPermissionsAuthorIdentifier from json.
func (s *PersonPermissionsAuthorIdentifier) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PersonPermissionsAuthorIdentifier to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "value":
			if err := func() error {
				s.Value.Reset()
				if err := s.Value.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PersonPermissionsAuthorIdentifier")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPersonPermissionsAuthorIdentifier) {
					name = jsonFieldsNameOfPersonPermissionsAuthorIdentifier[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PersonPermissionsAuthorIdentifier) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PersonPermissionsAuthorIdentifier) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PersonPermissionsAuthorIdentifierType as json.
func (s PersonPermissionsAuthorIdentifierType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PersonPermissionsAuthorIdentifierType from json.
func (s *PersonPermissionsAuthorIdentifierType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PersonPermissionsAuthorIdentifierType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PersonPermissionsAuthorIdentifierType(v) {
	case PersonPermissionsAuthorIdentifierTypeNip:
		*s = PersonPermissionsAuthorIdentifierTypeNip
	case PersonPermissionsAuthorIdentifierTypePesel:
		*s = PersonPermissionsAuthorIdentifierTypePesel
	case PersonPermissionsAuthorIdentifierTypeFingerprint:
		*s = PersonPermissionsAuthorIdentifierTypeFingerprint
	case PersonPermissionsAuthorIdentifierTypeSystem:
		*s = PersonPermissionsAuthorIdentifierTypeSystem
	default:
		*s = PersonPermissionsAuthorIdentifierType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PersonPermissionsAuthorIdentifierType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PersonPermissionsAuthorIdentifierType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PersonPermissionsAuthorizedIdentifier) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PersonPermissionsAuthorizedIdentifier) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("value")
		e.Str(s.Value)
	}
}

var jsonFieldsNameOfPersonPermissionsAuthorizedIdentifier = [2]string{
	0: "type",
	1: "value",
}

// Decode decodes PersonPermissionsAuthorizedIdentifier from json.
func (s *PersonPermissionsAuthorizedIdentifier) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PersonPermissionsAuthorizedIdentifier to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "value":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Value = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PersonPermissionsAuthorizedIdentifier")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPersonPermissionsAuthorizedIdentifier) {
					name = jsonFieldsNameOfPersonPermissionsAuthorizedIdentifier[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PersonPermissionsAuthorizedIdentifier) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PersonPermissionsAuthorizedIdentifier) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PersonPermissionsAuthorizedIdentifierType as json.
func (s PersonPermissionsAuthorizedIdentifierType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PersonPermissionsAuthorizedIdentifierType from json.
func (s *PersonPermissionsAuthorizedIdentifierType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PersonPermissionsAuthorizedIdentifierType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PersonPermissionsAuthorizedIdentifierType(v) {
	case PersonPermissionsAuthorizedIdentifierTypeNip:
		*s = PersonPermissionsAuthorizedIdentifierTypeNip
	case PersonPermissionsAuthorizedIdentifierTypePesel:
		*s = PersonPermissionsAuthorizedIdentifierTypePesel
	case PersonPermissionsAuthorizedIdentifierTypeFingerprint:
		*s = PersonPermissionsAuthorizedIdentifierTypeFingerprint
	default:
		*s = PersonPermissionsAuthorizedIdentifierType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PersonPermissionsAuthorizedIdentifierType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PersonPermissionsAuthorizedIdentifierType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PersonPermissionsContextIdentifier) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PersonPermissionsContextIdentifier) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("value")
		e.Str(s.Value)
	}
}

var jsonFieldsNameOfPersonPermissionsContextIdentifier = [2]string{
	0: "type",
	1: "value",
}

// Decode decodes PersonPermissionsContextIdentifier from json.
func (s *PersonPermissionsContextIdentifier) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PersonPermissionsContextIdentifier to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "value":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Value = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PersonPermissionsContextIdentifier")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPersonPermissionsContextIdentifier) {
					name = jsonFieldsNameOfPersonPermissionsContextIdentifier[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PersonPermissionsContextIdentifier) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PersonPermissionsContextIdentifier) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PersonPermissionsContextIdentifierType as json.
func (s PersonPermissionsContextIdentifierType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PersonPermissionsContextIdentifierType from json.
func (s *PersonPermissionsContextIdentifierType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PersonPermissionsContextIdentifierType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PersonPermissionsContextIdentifierType(v) {
	case PersonPermissionsContextIdentifierTypeNip:
		*s = PersonPermissionsContextIdentifierTypeNip
	case PersonPermissionsContextIdentifierTypeInternalId:
		*s = PersonPermissionsContextIdentifierTypeInternalId
	default:
		*s = PersonPermissionsContextIdentifierType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PersonPermissionsContextIdentifierType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PersonPermissionsContextIdentifierType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PersonPermissionsGrantRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PersonPermissionsGrantRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("subjectIdentifier")
		s.SubjectIdentifier.Encode(e)
	}
	{
		e.FieldStart("permissions")
		e.ArrStart()
		for _, elem := range s.Permissions {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("description")
		e.Str(s.Description)
	}
}

var jsonFieldsNameOfPersonPermissionsGrantRequest = [3]string{
	0: "subjectIdentifier",
	1: "permissions",
	2: "description",
}

// Decode decodes PersonPermissionsGrantRequest from json.
func (s *PersonPermissionsGrantRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PersonPermissionsGrantRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "subjectIdentifier":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.SubjectIdentifier.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subjectIdentifier\"")
			}
		case "permissions":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Permissions = make([]PersonPermissionType, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem PersonPermissionType
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Permissions = append(s.Permissions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"permissions\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PersonPermissionsGrantRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPersonPermissionsGrantRequest) {
					name = jsonFieldsNameOfPersonPermissionsGrantRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PersonPermissionsGrantRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PersonPermissionsGrantRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PersonPermissionsQueryRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PersonPermissionsQueryRequest) encodeFields(e *jx.Encoder) {
	{
		if s.AuthorIdentifier.Set {
			e.FieldStart("authorIdentifier")
			s.AuthorIdentifier.Encode(e)
		}
	}
	{
		if s.AuthorizedIdentifier.Set {
			e.FieldStart("authorizedIdentifier")
			s.AuthorizedIdentifier.Encode(e)
		}
	}
	{
		if s.ContextIdentifier.Set {
			e.FieldStart("contextIdentifier")
			s.ContextIdentifier.Encode(e)
		}
	}
	{
		if s.TargetIdentifier.Set {
			e.FieldStart("targetIdentifier")
			s.TargetIdentifier.Encode(e)
		}
	}
	{
		if s.PermissionTypes.Set {
			e.FieldStart("permissionTypes")
			s.PermissionTypes.Encode(e)
		}
	}
	{
		if s.PermissionState.Set {
			e.FieldStart("permissionState")
			s.PermissionState.Encode(e)
		}
	}
	{
		e.FieldStart("queryType")
		s.QueryType.Encode(e)
	}
}

var jsonFieldsNameOfPersonPermissionsQueryRequest = [7]string{
	0: "authorIdentifier",
	1: "authorizedIdentifier",
	2: "contextIdentifier",
	3: "targetIdentifier",
	4: "permissionTypes",
	5: "permissionState",
	6: "queryType",
}

// Decode decodes PersonPermissionsQueryRequest from json.
func (s *PersonPermissionsQueryRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PersonPermissionsQueryRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "authorIdentifier":
			if err := func() error {
				s.AuthorIdentifier.Reset()
				if err := s.AuthorIdentifier.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"authorIdentifier\"")
			}
		case "authorizedIdentifier":
			if err := func() error {
				s.AuthorizedIdentifier.Reset()
				if err := s.AuthorizedIdentifier.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"authorizedIdentifier\"")
			}
		case "contextIdentifier":
			if err := func() error {
				s.ContextIdentifier.Reset()
				if err := s.ContextIdentifier.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"contextIdentifier\"")
			}
		case "targetIdentifier":
			if err := func() error {
				s.TargetIdentifier.Reset()
				if err := s.TargetIdentifier.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"targetIdentifier\"")
			}
		case "permissionTypes":
			if err := func() error {
				s.PermissionTypes.Reset()
				if err := s.PermissionTypes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"permissionTypes\"")
			}
		case "permissionState":
			if err := func() error {
				s.PermissionState.Reset()
				if err := s.PermissionState.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"permissionState\"")
			}
		case "queryType":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.QueryType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"queryType\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PersonPermissionsQueryRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPersonPermissionsQueryRequest) {
					name = jsonFieldsNameOfPersonPermissionsQueryRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PersonPermissionsQueryRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PersonPermissionsQueryRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PersonPermissionsQueryType as json.
func (s PersonPermissionsQueryType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PersonPermissionsQueryType from json.
func (s *PersonPermissionsQueryType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PersonPermissionsQueryType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PersonPermissionsQueryType(v) {
	case PersonPermissionsQueryTypePermissionsInCurrentContext:
		*s = PersonPermissionsQueryTypePermissionsInCurrentContext
	case PersonPermissionsQueryTypePermissionsGrantedInCurrentContext:
		*s = PersonPermissionsQueryTypePermissionsGrantedInCurrentContext
	default:
		*s = PersonPermissionsQueryType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PersonPermissionsQueryType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PersonPermissionsQueryType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PersonPermissionsSubjectIdentifier) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PersonPermissionsSubjectIdentifier) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("value")
		e.Str(s.Value)
	}
}

var jsonFieldsNameOfPersonPermissionsSubjectIdentifier = [2]string{
	0: "type",
	1: "value",
}

// Decode decodes PersonPermissionsSubjectIdentifier from json.
func (s *PersonPermissionsSubjectIdentifier) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PersonPermissionsSubjectIdentifier to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "value":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Value = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PersonPermissionsSubjectIdentifier")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPersonPermissionsSubjectIdentifier) {
					name = jsonFieldsNameOfPersonPermissionsSubjectIdentifier[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PersonPermissionsSubjectIdentifier) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PersonPermissionsSubjectIdentifier) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PersonPermissionsSubjectIdentifierType as json.
func (s PersonPermissionsSubjectIdentifierType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PersonPermissionsSubjectIdentifierType from json.
func (s *PersonPermissionsSubjectIdentifierType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PersonPermissionsSubjectIdentifierType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PersonPermissionsSubjectIdentifierType(v) {
	case PersonPermissionsSubjectIdentifierTypeNip:
		*s = PersonPermissionsSubjectIdentifierTypeNip
	case PersonPermissionsSubjectIdentifierTypePesel:
		*s = PersonPermissionsSubjectIdentifierTypePesel
	case PersonPermissionsSubjectIdentifierTypeFingerprint:
		*s = PersonPermissionsSubjectIdentifierTypeFingerprint
	default:
		*s = PersonPermissionsSubjectIdentifierType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PersonPermissionsSubjectIdentifierType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PersonPermissionsSubjectIdentifierType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PersonPermissionsTargetIdentifier) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PersonPermissionsTargetIdentifier) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		if s.Value.Set {
			e.FieldStart("value")
			s.Value.Encode(e)
		}
	}
}

var jsonFieldsNameOfPersonPermissionsTargetIdentifier = [2]string{
	0: "type",
	1: "value",
}

// Decode decodes PersonPermissionsTargetIdentifier from json.
func (s *PersonPermissionsTargetIdentifier) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PersonPermissionsTargetIdentifier to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "value":
			if err := func() error {
				s.Value.Reset()
				if err := s.Value.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PersonPermissionsTargetIdentifier")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPersonPermissionsTargetIdentifier) {
					name = jsonFieldsNameOfPersonPermissionsTargetIdentifier[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PersonPermissionsTargetIdentifier) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PersonPermissionsTargetIdentifier) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PersonPermissionsTargetIdentifierType as json.
func (s PersonPermissionsTargetIdentifierType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PersonPermissionsTargetIdentifierType from json.
func (s *PersonPermissionsTargetIdentifierType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PersonPermissionsTargetIdentifierType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PersonPermissionsTargetIdentifierType(v) {
	case PersonPermissionsTargetIdentifierTypeNip:
		*s = PersonPermissionsTargetIdentifierTypeNip
	case PersonPermissionsTargetIdentifierTypeAllPartners:
		*s = PersonPermissionsTargetIdentifierTypeAllPartners
	case PersonPermissionsTargetIdentifierTypeInternalId:
		*s = PersonPermissionsTargetIdentifierTypeInternalId
	default:
		*s = PersonPermissionsTargetIdentifierType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PersonPermissionsTargetIdentifierType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PersonPermissionsTargetIdentifierType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PersonRemoveRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PersonRemoveRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("nip")
		s.Nip.Encode(e)
	}
}

var jsonFieldsNameOfPersonRemoveRequest = [1]string{
	0: "nip",
}

// Decode decodes PersonRemoveRequest from json.
func (s *PersonRemoveRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PersonRemoveRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "nip":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Nip.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nip\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PersonRemoveRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPersonRemoveRequest) {
					name = jsonFieldsNameOfPersonRemoveRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PersonRemoveRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PersonRemoveRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PersonalPermission) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PersonalPermission) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		s.ID.Encode(e)
	}
	{
		if s.ContextIdentifier.Set {
			e.FieldStart("contextIdentifier")
			s.ContextIdentifier.Encode(e)
		}
	}
	{
		if s.AuthorizedIdentifier.Set {
			e.FieldStart("authorizedIdentifier")
			s.AuthorizedIdentifier.Encode(e)
		}
	}
	{
		if s.TargetIdentifier.Set {
			e.FieldStart("targetIdentifier")
			s.TargetIdentifier.Encode(e)
		}
	}
	{
		e.FieldStart("permissionScope")
		s.PermissionScope.Encode(e)
	}
	{
		e.FieldStart("description")
		e.Str(s.Description)
	}
	{
		e.FieldStart("permissionState")
		s.PermissionState.Encode(e)
	}
	{
		e.FieldStart("startDate")
		json.EncodeDateTime(e, s.StartDate)
	}
	{
		e.FieldStart("canDelegate")
		e.Bool(s.CanDelegate)
	}
}

var jsonFieldsNameOfPersonalPermission = [9]string{
	0: "id",
	1: "contextIdentifier",
	2: "authorizedIdentifier",
	3: "targetIdentifier",
	4: "permissionScope",
	5: "description",
	6: "permissionState",
	7: "startDate",
	8: "canDelegate",
}

// Decode decodes PersonalPermission from json.
func (s *PersonalPermission) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PersonalPermission to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "contextIdentifier":
			if err := func() error {
				s.ContextIdentifier.Reset()
				if err := s.ContextIdentifier.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"contextIdentifier\"")
			}
		case "authorizedIdentifier":
			if err := func() error {
				s.AuthorizedIdentifier.Reset()
				if err := s.AuthorizedIdentifier.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"authorizedIdentifier\"")
			}
		case "targetIdentifier":
			if err := func() error {
				s.TargetIdentifier.Reset()
				if err := s.TargetIdentifier.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"targetIdentifier\"")
			}
		case "permissionScope":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.PermissionScope.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"permissionScope\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "permissionState":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.PermissionState.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"permissionState\"")
			}
		case "startDate":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.StartDate = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"startDate\"")
			}
		case "canDelegate":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.CanDelegate = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"canDelegate\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PersonalPermission")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11110001,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPersonalPermission) {
					name = jsonFieldsNameOfPersonalPermission[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PersonalPermission) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PersonalPermission) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PersonalPermissionScope as json.
func (s PersonalPermissionScope) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PersonalPermissionScope from json.
func (s *PersonalPermissionScope) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PersonalPermissionScope to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PersonalPermissionScope(v) {
	case PersonalPermissionScopeCredentialsManage:
		*s = PersonalPermissionScopeCredentialsManage
	case PersonalPermissionScopeCredentialsRead:
		*s = PersonalPermissionScopeCredentialsRead
	case PersonalPermissionScopeInvoiceWrite:
		*s = PersonalPermissionScopeInvoiceWrite
	case PersonalPermissionScopeInvoiceRead:
		*s = PersonalPermissionScopeInvoiceRead
	case PersonalPermissionScopeIntrospection:
		*s = PersonalPermissionScopeIntrospection
	case PersonalPermissionScopeSubunitManage:
		*s = PersonalPermissionScopeSubunitManage
	case PersonalPermissionScopeEnforcementOperations:
		*s = PersonalPermissionScopeEnforcementOperations
	case PersonalPermissionScopeVatUeManage:
		*s = PersonalPermissionScopeVatUeManage
	default:
		*s = PersonalPermissionScope(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PersonalPermissionScope) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PersonalPermissionScope) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PersonalPermissionType as json.
func (s PersonalPermissionType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PersonalPermissionType from json.
func (s *PersonalPermissionType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PersonalPermissionType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PersonalPermissionType(v) {
	case PersonalPermissionTypeCredentialsManage:
		*s = PersonalPermissionTypeCredentialsManage
	case PersonalPermissionTypeCredentialsRead:
		*s = PersonalPermissionTypeCredentialsRead
	case PersonalPermissionTypeInvoiceWrite:
		*s = PersonalPermissionTypeInvoiceWrite
	case PersonalPermissionTypeInvoiceRead:
		*s = PersonalPermissionTypeInvoiceRead
	case PersonalPermissionTypeIntrospection:
		*s = PersonalPermissionTypeIntrospection
	case PersonalPermissionTypeSubunitManage:
		*s = PersonalPermissionTypeSubunitManage
	case PersonalPermissionTypeEnforcementOperations:
		*s = PersonalPermissionTypeEnforcementOperations
	case PersonalPermissionTypeVatUeManage:
		*s = PersonalPermissionTypeVatUeManage
	default:
		*s = PersonalPermissionType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PersonalPermissionType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PersonalPermissionType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PersonalPermissionsAuthorizedIdentifier) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PersonalPermissionsAuthorizedIdentifier) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("value")
		e.Str(s.Value)
	}
}

var jsonFieldsNameOfPersonalPermissionsAuthorizedIdentifier = [2]string{
	0: "type",
	1: "value",
}

// Decode decodes PersonalPermissionsAuthorizedIdentifier from json.
func (s *PersonalPermissionsAuthorizedIdentifier) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PersonalPermissionsAuthorizedIdentifier to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "value":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Value = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PersonalPermissionsAuthorizedIdentifier")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPersonalPermissionsAuthorizedIdentifier) {
					name = jsonFieldsNameOfPersonalPermissionsAuthorizedIdentifier[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PersonalPermissionsAuthorizedIdentifier) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PersonalPermissionsAuthorizedIdentifier) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PersonalPermissionsAuthorizedIdentifierType as json.
func (s PersonalPermissionsAuthorizedIdentifierType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PersonalPermissionsAuthorizedIdentifierType from json.
func (s *PersonalPermissionsAuthorizedIdentifierType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PersonalPermissionsAuthorizedIdentifierType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PersonalPermissionsAuthorizedIdentifierType(v) {
	case PersonalPermissionsAuthorizedIdentifierTypeNip:
		*s = PersonalPermissionsAuthorizedIdentifierTypeNip
	case PersonalPermissionsAuthorizedIdentifierTypePesel:
		*s = PersonalPermissionsAuthorizedIdentifierTypePesel
	case PersonalPermissionsAuthorizedIdentifierTypeFingerprint:
		*s = PersonalPermissionsAuthorizedIdentifierTypeFingerprint
	default:
		*s = PersonalPermissionsAuthorizedIdentifierType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PersonalPermissionsAuthorizedIdentifierType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PersonalPermissionsAuthorizedIdentifierType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PersonalPermissionsContextIdentifier) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PersonalPermissionsContextIdentifier) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("value")
		e.Str(s.Value)
	}
}

var jsonFieldsNameOfPersonalPermissionsContextIdentifier = [2]string{
	0: "type",
	1: "value",
}

// Decode decodes PersonalPermissionsContextIdentifier from json.
func (s *PersonalPermissionsContextIdentifier) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PersonalPermissionsContextIdentifier to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "value":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Value = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PersonalPermissionsContextIdentifier")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPersonalPermissionsContextIdentifier) {
					name = jsonFieldsNameOfPersonalPermissionsContextIdentifier[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PersonalPermissionsContextIdentifier) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PersonalPermissionsContextIdentifier) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PersonalPermissionsContextIdentifierType as json.
func (s PersonalPermissionsContextIdentifierType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PersonalPermissionsContextIdentifierType from json.
func (s *PersonalPermissionsContextIdentifierType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PersonalPermissionsContextIdentifierType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PersonalPermissionsContextIdentifierType(v) {
	case PersonalPermissionsContextIdentifierTypeNip:
		*s = PersonalPermissionsContextIdentifierTypeNip
	case PersonalPermissionsContextIdentifierTypeInternalId:
		*s = PersonalPermissionsContextIdentifierTypeInternalId
	default:
		*s = PersonalPermissionsContextIdentifierType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PersonalPermissionsContextIdentifierType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PersonalPermissionsContextIdentifierType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PersonalPermissionsQueryRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PersonalPermissionsQueryRequest) encodeFields(e *jx.Encoder) {
	{
		if s.ContextIdentifier.Set {
			e.FieldStart("contextIdentifier")
			s.ContextIdentifier.Encode(e)
		}
	}
	{
		if s.TargetIdentifier.Set {
			e.FieldStart("targetIdentifier")
			s.TargetIdentifier.Encode(e)
		}
	}
	{
		if s.PermissionTypes.Set {
			e.FieldStart("permissionTypes")
			s.PermissionTypes.Encode(e)
		}
	}
	{
		if s.PermissionState.Set {
			e.FieldStart("permissionState")
			s.PermissionState.Encode(e)
		}
	}
}

var jsonFieldsNameOfPersonalPermissionsQueryRequest = [4]string{
	0: "contextIdentifier",
	1: "targetIdentifier",
	2: "permissionTypes",
	3: "permissionState",
}

// Decode decodes PersonalPermissionsQueryRequest from json.
func (s *PersonalPermissionsQueryRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PersonalPermissionsQueryRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "contextIdentifier":
			if err := func() error {
				s.ContextIdentifier.Reset()
				if err := s.ContextIdentifier.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"contextIdentifier\"")
			}
		case "targetIdentifier":
			if err := func() error {
				s.TargetIdentifier.Reset()
				if err := s.TargetIdentifier.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"targetIdentifier\"")
			}
		case "permissionTypes":
			if err := func() error {
				s.PermissionTypes.Reset()
				if err := s.PermissionTypes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"permissionTypes\"")
			}
		case "permissionState":
			if err := func() error {
				s.PermissionState.Reset()
				if err := s.PermissionState.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"permissionState\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PersonalPermissionsQueryRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PersonalPermissionsQueryRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PersonalPermissionsQueryRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PersonalPermissionsTargetIdentifier) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PersonalPermissionsTargetIdentifier) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		if s.Value.Set {
			e.FieldStart("value")
			s.Value.Encode(e)
		}
	}
}

var jsonFieldsNameOfPersonalPermissionsTargetIdentifier = [2]string{
	0: "type",
	1: "value",
}

// Decode decodes PersonalPermissionsTargetIdentifier from json.
func (s *PersonalPermissionsTargetIdentifier) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PersonalPermissionsTargetIdentifier to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "value":
			if err := func() error {
				s.Value.Reset()
				if err := s.Value.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PersonalPermissionsTargetIdentifier")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPersonalPermissionsTargetIdentifier) {
					name = jsonFieldsNameOfPersonalPermissionsTargetIdentifier[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PersonalPermissionsTargetIdentifier) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PersonalPermissionsTargetIdentifier) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PersonalPermissionsTargetIdentifierType as json.
func (s PersonalPermissionsTargetIdentifierType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PersonalPermissionsTargetIdentifierType from json.
func (s *PersonalPermissionsTargetIdentifierType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PersonalPermissionsTargetIdentifierType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PersonalPermissionsTargetIdentifierType(v) {
	case PersonalPermissionsTargetIdentifierTypeNip:
		*s = PersonalPermissionsTargetIdentifierTypeNip
	case PersonalPermissionsTargetIdentifierTypeAllPartners:
		*s = PersonalPermissionsTargetIdentifierTypeAllPartners
	case PersonalPermissionsTargetIdentifierTypeInternalId:
		*s = PersonalPermissionsTargetIdentifierTypeInternalId
	default:
		*s = PersonalPermissionsTargetIdentifierType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PersonalPermissionsTargetIdentifierType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PersonalPermissionsTargetIdentifierType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Pesel as json.
func (s Pesel) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes Pesel from json.
func (s *Pesel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Pesel to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = Pesel(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s Pesel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Pesel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PublicKeyCertificate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PublicKeyCertificate) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("certificate")
		e.Str(s.Certificate)
	}
	{
		e.FieldStart("validFrom")
		json.EncodeDateTime(e, s.ValidFrom)
	}
	{
		e.FieldStart("validTo")
		json.EncodeDateTime(e, s.ValidTo)
	}
	{
		e.FieldStart("usage")
		e.ArrStart()
		for _, elem := range s.Usage {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfPublicKeyCertificate = [4]string{
	0: "certificate",
	1: "validFrom",
	2: "validTo",
	3: "usage",
}

// Decode decodes PublicKeyCertificate from json.
func (s *PublicKeyCertificate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PublicKeyCertificate to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "certificate":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Certificate = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"certificate\"")
			}
		case "validFrom":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.ValidFrom = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"validFrom\"")
			}
		case "validTo":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.ValidTo = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"validTo\"")
			}
		case "usage":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				s.Usage = make([]PublicKeyCertificateUsage, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem PublicKeyCertificateUsage
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Usage = append(s.Usage, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"usage\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PublicKeyCertificate")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPublicKeyCertificate) {
					name = jsonFieldsNameOfPublicKeyCertificate[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PublicKeyCertificate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PublicKeyCertificate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PublicKeyCertificateUsage as json.
func (s PublicKeyCertificateUsage) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PublicKeyCertificateUsage from json.
func (s *PublicKeyCertificateUsage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PublicKeyCertificateUsage to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PublicKeyCertificateUsage(v) {
	case PublicKeyCertificateUsageKsefTokenEncryption:
		*s = PublicKeyCertificateUsageKsefTokenEncryption
	case PublicKeyCertificateUsageSymmetricKeyEncryption:
		*s = PublicKeyCertificateUsageSymmetricKeyEncryption
	default:
		*s = PublicKeyCertificateUsage(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PublicKeyCertificateUsage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PublicKeyCertificateUsage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *QueryCertificatesRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *QueryCertificatesRequest) encodeFields(e *jx.Encoder) {
	{
		if s.CertificateSerialNumber.Set {
			e.FieldStart("certificateSerialNumber")
			s.CertificateSerialNumber.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.ExpiresAfter.Set {
			e.FieldStart("expiresAfter")
			s.ExpiresAfter.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfQueryCertificatesRequest = [5]string{
	0: "certificateSerialNumber",
	1: "name",
	2: "type",
	3: "status",
	4: "expiresAfter",
}

// Decode decodes QueryCertificatesRequest from json.
func (s *QueryCertificatesRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode QueryCertificatesRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "certificateSerialNumber":
			if err := func() error {
				s.CertificateSerialNumber.Reset()
				if err := s.CertificateSerialNumber.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"certificateSerialNumber\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "expiresAfter":
			if err := func() error {
				s.ExpiresAfter.Reset()
				if err := s.ExpiresAfter.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expiresAfter\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode QueryCertificatesRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *QueryCertificatesRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *QueryCertificatesRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *QueryCertificatesResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *QueryCertificatesResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("certificates")
		e.ArrStart()
		for _, elem := range s.Certificates {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("hasMore")
		e.Bool(s.HasMore)
	}
}

var jsonFieldsNameOfQueryCertificatesResponse = [2]string{
	0: "certificates",
	1: "hasMore",
}

// Decode decodes QueryCertificatesResponse from json.
func (s *QueryCertificatesResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode QueryCertificatesResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "certificates":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Certificates = make([]CertificateListItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem CertificateListItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Certificates = append(s.Certificates, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"certificates\"")
			}
		case "hasMore":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.HasMore = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hasMore\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode QueryCertificatesResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfQueryCertificatesResponse) {
					name = jsonFieldsNameOfQueryCertificatesResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *QueryCertificatesResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *QueryCertificatesResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *QueryEntityAuthorizationPermissionsResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *QueryEntityAuthorizationPermissionsResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("authorizationGrants")
		e.ArrStart()
		for _, elem := range s.AuthorizationGrants {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("hasMore")
		e.Bool(s.HasMore)
	}
}

var jsonFieldsNameOfQueryEntityAuthorizationPermissionsResponse = [2]string{
	0: "authorizationGrants",
	1: "hasMore",
}

// Decode decodes QueryEntityAuthorizationPermissionsResponse from json.
func (s *QueryEntityAuthorizationPermissionsResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode QueryEntityAuthorizationPermissionsResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "authorizationGrants":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.AuthorizationGrants = make([]EntityAuthorizationGrant, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem EntityAuthorizationGrant
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.AuthorizationGrants = append(s.AuthorizationGrants, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"authorizationGrants\"")
			}
		case "hasMore":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.HasMore = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hasMore\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode QueryEntityAuthorizationPermissionsResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfQueryEntityAuthorizationPermissionsResponse) {
					name = jsonFieldsNameOfQueryEntityAuthorizationPermissionsResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *QueryEntityAuthorizationPermissionsResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *QueryEntityAuthorizationPermissionsResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *QueryEntityRolesResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *QueryEntityRolesResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("roles")
		e.ArrStart()
		for _, elem := range s.Roles {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("hasMore")
		e.Bool(s.HasMore)
	}
}

var jsonFieldsNameOfQueryEntityRolesResponse = [2]string{
	0: "roles",
	1: "hasMore",
}

// Decode decodes QueryEntityRolesResponse from json.
func (s *QueryEntityRolesResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode QueryEntityRolesResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "roles":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Roles = make([]EntityRole, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem EntityRole
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Roles = append(s.Roles, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"roles\"")
			}
		case "hasMore":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.HasMore = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hasMore\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode QueryEntityRolesResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfQueryEntityRolesResponse) {
					name = jsonFieldsNameOfQueryEntityRolesResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *QueryEntityRolesResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *QueryEntityRolesResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *QueryEuEntityPermissionsResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *QueryEuEntityPermissionsResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("permissions")
		e.ArrStart()
		for _, elem := range s.Permissions {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("hasMore")
		e.Bool(s.HasMore)
	}
}

var jsonFieldsNameOfQueryEuEntityPermissionsResponse = [2]string{
	0: "permissions",
	1: "hasMore",
}

// Decode decodes QueryEuEntityPermissionsResponse from json.
func (s *QueryEuEntityPermissionsResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode QueryEuEntityPermissionsResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "permissions":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Permissions = make([]EuEntityPermission, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem EuEntityPermission
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Permissions = append(s.Permissions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"permissions\"")
			}
		case "hasMore":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.HasMore = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hasMore\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode QueryEuEntityPermissionsResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfQueryEuEntityPermissionsResponse) {
					name = jsonFieldsNameOfQueryEuEntityPermissionsResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *QueryEuEntityPermissionsResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *QueryEuEntityPermissionsResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *QueryInvoicesMetadataResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *QueryInvoicesMetadataResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("hasMore")
		e.Bool(s.HasMore)
	}
	{
		e.FieldStart("isTruncated")
		e.Bool(s.IsTruncated)
	}
	{
		e.FieldStart("invoices")
		e.ArrStart()
		for _, elem := range s.Invoices {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfQueryInvoicesMetadataResponse = [3]string{
	0: "hasMore",
	1: "isTruncated",
	2: "invoices",
}

// Decode decodes QueryInvoicesMetadataResponse from json.
func (s *QueryInvoicesMetadataResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode QueryInvoicesMetadataResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "hasMore":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.HasMore = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hasMore\"")
			}
		case "isTruncated":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.IsTruncated = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isTruncated\"")
			}
		case "invoices":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.Invoices = make([]InvoiceMetadata, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem InvoiceMetadata
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Invoices = append(s.Invoices, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"invoices\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode QueryInvoicesMetadataResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfQueryInvoicesMetadataResponse) {
					name = jsonFieldsNameOfQueryInvoicesMetadataResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *QueryInvoicesMetadataResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *QueryInvoicesMetadataResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *QueryPeppolProvidersResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *QueryPeppolProvidersResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("peppolProviders")
		e.ArrStart()
		for _, elem := range s.PeppolProviders {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("hasMore")
		e.Bool(s.HasMore)
	}
}

var jsonFieldsNameOfQueryPeppolProvidersResponse = [2]string{
	0: "peppolProviders",
	1: "hasMore",
}

// Decode decodes QueryPeppolProvidersResponse from json.
func (s *QueryPeppolProvidersResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode QueryPeppolProvidersResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "peppolProviders":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.PeppolProviders = make([]PeppolProvider, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem PeppolProvider
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.PeppolProviders = append(s.PeppolProviders, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"peppolProviders\"")
			}
		case "hasMore":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.HasMore = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hasMore\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode QueryPeppolProvidersResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfQueryPeppolProvidersResponse) {
					name = jsonFieldsNameOfQueryPeppolProvidersResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *QueryPeppolProvidersResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *QueryPeppolProvidersResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *QueryPersonPermissionsResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *QueryPersonPermissionsResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("permissions")
		e.ArrStart()
		for _, elem := range s.Permissions {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("hasMore")
		e.Bool(s.HasMore)
	}
}

var jsonFieldsNameOfQueryPersonPermissionsResponse = [2]string{
	0: "permissions",
	1: "hasMore",
}

// Decode decodes QueryPersonPermissionsResponse from json.
func (s *QueryPersonPermissionsResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode QueryPersonPermissionsResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "permissions":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Permissions = make([]PersonPermission, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem PersonPermission
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Permissions = append(s.Permissions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"permissions\"")
			}
		case "hasMore":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.HasMore = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hasMore\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode QueryPersonPermissionsResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfQueryPersonPermissionsResponse) {
					name = jsonFieldsNameOfQueryPersonPermissionsResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *QueryPersonPermissionsResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *QueryPersonPermissionsResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *QueryPersonalPermissionsResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *QueryPersonalPermissionsResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("permissions")
		e.ArrStart()
		for _, elem := range s.Permissions {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("hasMore")
		e.Bool(s.HasMore)
	}
}

var jsonFieldsNameOfQueryPersonalPermissionsResponse = [2]string{
	0: "permissions",
	1: "hasMore",
}

// Decode decodes QueryPersonalPermissionsResponse from json.
func (s *QueryPersonalPermissionsResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode QueryPersonalPermissionsResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "permissions":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Permissions = make([]PersonalPermission, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem PersonalPermission
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Permissions = append(s.Permissions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"permissions\"")
			}
		case "hasMore":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.HasMore = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hasMore\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode QueryPersonalPermissionsResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfQueryPersonalPermissionsResponse) {
					name = jsonFieldsNameOfQueryPersonalPermissionsResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *QueryPersonalPermissionsResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *QueryPersonalPermissionsResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *QuerySubordinateEntityRolesResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *QuerySubordinateEntityRolesResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("roles")
		e.ArrStart()
		for _, elem := range s.Roles {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("hasMore")
		e.Bool(s.HasMore)
	}
}

var jsonFieldsNameOfQuerySubordinateEntityRolesResponse = [2]string{
	0: "roles",
	1: "hasMore",
}

// Decode decodes QuerySubordinateEntityRolesResponse from json.
func (s *QuerySubordinateEntityRolesResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode QuerySubordinateEntityRolesResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "roles":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Roles = make([]SubordinateEntityRole, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SubordinateEntityRole
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Roles = append(s.Roles, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"roles\"")
			}
		case "hasMore":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.HasMore = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hasMore\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode QuerySubordinateEntityRolesResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfQuerySubordinateEntityRolesResponse) {
					name = jsonFieldsNameOfQuerySubordinateEntityRolesResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *QuerySubordinateEntityRolesResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *QuerySubordinateEntityRolesResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *QuerySubunitPermissionsResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *QuerySubunitPermissionsResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("permissions")
		e.ArrStart()
		for _, elem := range s.Permissions {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("hasMore")
		e.Bool(s.HasMore)
	}
}

var jsonFieldsNameOfQuerySubunitPermissionsResponse = [2]string{
	0: "permissions",
	1: "hasMore",
}

// Decode decodes QuerySubunitPermissionsResponse from json.
func (s *QuerySubunitPermissionsResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode QuerySubunitPermissionsResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "permissions":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Permissions = make([]SubunitPermission, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SubunitPermission
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Permissions = append(s.Permissions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"permissions\"")
			}
		case "hasMore":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.HasMore = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hasMore\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode QuerySubunitPermissionsResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfQuerySubunitPermissionsResponse) {
					name = jsonFieldsNameOfQuerySubunitPermissionsResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *QuerySubunitPermissionsResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *QuerySubunitPermissionsResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *QueryTokensResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *QueryTokensResponse) encodeFields(e *jx.Encoder) {
	{
		if s.ContinuationToken.Set {
			e.FieldStart("continuationToken")
			s.ContinuationToken.Encode(e)
		}
	}
	{
		e.FieldStart("tokens")
		e.ArrStart()
		for _, elem := range s.Tokens {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfQueryTokensResponse = [2]string{
	0: "continuationToken",
	1: "tokens",
}

// Decode decodes QueryTokensResponse from json.
func (s *QueryTokensResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode QueryTokensResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "continuationToken":
			if err := func() error {
				s.ContinuationToken.Reset()
				if err := s.ContinuationToken.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"continuationToken\"")
			}
		case "tokens":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Tokens = make([]QueryTokensResponseItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem QueryTokensResponseItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Tokens = append(s.Tokens, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tokens\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode QueryTokensResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfQueryTokensResponse) {
					name = jsonFieldsNameOfQueryTokensResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *QueryTokensResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *QueryTokensResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *QueryTokensResponseItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *QueryTokensResponseItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("referenceNumber")
		s.ReferenceNumber.Encode(e)
	}
	{
		e.FieldStart("authorIdentifier")
		s.AuthorIdentifier.Encode(e)
	}
	{
		e.FieldStart("contextIdentifier")
		s.ContextIdentifier.Encode(e)
	}
	{
		e.FieldStart("description")
		e.Str(s.Description)
	}
	{
		e.FieldStart("requestedPermissions")
		e.ArrStart()
		for _, elem := range s.RequestedPermissions {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("dateCreated")
		json.EncodeDateTime(e, s.DateCreated)
	}
	{
		if s.LastUseDate.Set {
			e.FieldStart("lastUseDate")
			s.LastUseDate.Encode(e, json.EncodeDateTime)
		}
	}
	{
		e.FieldStart("status")
		s.Status.Encode(e)
	}
	{
		if s.StatusDetails.Set {
			e.FieldStart("statusDetails")
			s.StatusDetails.Encode(e)
		}
	}
}

var jsonFieldsNameOfQueryTokensResponseItem = [9]string{
	0: "referenceNumber",
	1: "authorIdentifier",
	2: "contextIdentifier",
	3: "description",
	4: "requestedPermissions",
	5: "dateCreated",
	6: "lastUseDate",
	7: "status",
	8: "statusDetails",
}

// Decode decodes QueryTokensResponseItem from json.
func (s *QueryTokensResponseItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode QueryTokensResponseItem to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "referenceNumber":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ReferenceNumber.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"referenceNumber\"")
			}
		case "authorIdentifier":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.AuthorIdentifier.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"authorIdentifier\"")
			}
		case "contextIdentifier":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.ContextIdentifier.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"contextIdentifier\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "requestedPermissions":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				s.RequestedPermissions = make([]TokenPermissionType, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem TokenPermissionType
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.RequestedPermissions = append(s.RequestedPermissions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requestedPermissions\"")
			}
		case "dateCreated":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.DateCreated = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dateCreated\"")
			}
		case "lastUseDate":
			if err := func() error {
				s.LastUseDate.Reset()
				if err := s.LastUseDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastUseDate\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "statusDetails":
			if err := func() error {
				s.StatusDetails.Reset()
				if err := s.StatusDetails.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusDetails\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode QueryTokensResponseItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b10111111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfQueryTokensResponseItem) {
					name = jsonFieldsNameOfQueryTokensResponseItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *QueryTokensResponseItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *QueryTokensResponseItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes QueryType as json.
func (s QueryType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes QueryType from json.
func (s *QueryType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode QueryType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch QueryType(v) {
	case QueryTypeGranted:
		*s = QueryTypeGranted
	case QueryTypeReceived:
		*s = QueryTypeReceived
	default:
		*s = QueryType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s QueryType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *QueryType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReferenceNumber as json.
func (s ReferenceNumber) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes ReferenceNumber from json.
func (s *ReferenceNumber) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReferenceNumber to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReferenceNumber(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ReferenceNumber) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReferenceNumber) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RetrieveCertificatesListItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RetrieveCertificatesListItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("certificate")
		e.Base64(s.Certificate)
	}
	{
		e.FieldStart("certificateName")
		e.Str(s.CertificateName)
	}
	{
		e.FieldStart("certificateSerialNumber")
		e.Str(s.CertificateSerialNumber)
	}
	{
		e.FieldStart("certificateType")
		s.CertificateType.Encode(e)
	}
}

var jsonFieldsNameOfRetrieveCertificatesListItem = [4]string{
	0: "certificate",
	1: "certificateName",
	2: "certificateSerialNumber",
	3: "certificateType",
}

// Decode decodes RetrieveCertificatesListItem from json.
func (s *RetrieveCertificatesListItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RetrieveCertificatesListItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "certificate":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Base64()
				s.Certificate = []byte(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"certificate\"")
			}
		case "certificateName":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.CertificateName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"certificateName\"")
			}
		case "certificateSerialNumber":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.CertificateSerialNumber = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"certificateSerialNumber\"")
			}
		case "certificateType":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.CertificateType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"certificateType\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RetrieveCertificatesListItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRetrieveCertificatesListItem) {
					name = jsonFieldsNameOfRetrieveCertificatesListItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RetrieveCertificatesListItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RetrieveCertificatesListItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RetrieveCertificatesRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RetrieveCertificatesRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("certificateSerialNumbers")
		e.ArrStart()
		for _, elem := range s.CertificateSerialNumbers {
			e.Str(elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfRetrieveCertificatesRequest = [1]string{
	0: "certificateSerialNumbers",
}

// Decode decodes RetrieveCertificatesRequest from json.
func (s *RetrieveCertificatesRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RetrieveCertificatesRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "certificateSerialNumbers":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.CertificateSerialNumbers = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.CertificateSerialNumbers = append(s.CertificateSerialNumbers, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"certificateSerialNumbers\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RetrieveCertificatesRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRetrieveCertificatesRequest) {
					name = jsonFieldsNameOfRetrieveCertificatesRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RetrieveCertificatesRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RetrieveCertificatesRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RetrieveCertificatesResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RetrieveCertificatesResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("certificates")
		e.ArrStart()
		for _, elem := range s.Certificates {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfRetrieveCertificatesResponse = [1]string{
	0: "certificates",
}

// Decode decodes RetrieveCertificatesResponse from json.
func (s *RetrieveCertificatesResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RetrieveCertificatesResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "certificates":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Certificates = make([]RetrieveCertificatesListItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem RetrieveCertificatesListItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Certificates = append(s.Certificates, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"certificates\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RetrieveCertificatesResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRetrieveCertificatesResponse) {
					name = jsonFieldsNameOfRetrieveCertificatesResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RetrieveCertificatesResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RetrieveCertificatesResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RevokeCertificateRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RevokeCertificateRequest) encodeFields(e *jx.Encoder) {
	{
		if s.RevocationReason.Set {
			e.FieldStart("revocationReason")
			s.RevocationReason.Encode(e)
		}
	}
}

var jsonFieldsNameOfRevokeCertificateRequest = [1]string{
	0: "revocationReason",
}

// Decode decodes RevokeCertificateRequest from json.
func (s *RevokeCertificateRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RevokeCertificateRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "revocationReason":
			if err := func() error {
				s.RevocationReason.Reset()
				if err := s.RevocationReason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"revocationReason\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RevokeCertificateRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RevokeCertificateRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RevokeCertificateRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SendInvoiceRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SendInvoiceRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("invoiceHash")
		s.InvoiceHash.Encode(e)
	}
	{
		e.FieldStart("invoiceSize")
		e.Int64(s.InvoiceSize)
	}
	{
		e.FieldStart("encryptedInvoiceHash")
		s.EncryptedInvoiceHash.Encode(e)
	}
	{
		e.FieldStart("encryptedInvoiceSize")
		e.Int64(s.EncryptedInvoiceSize)
	}
	{
		e.FieldStart("encryptedInvoiceContent")
		e.Base64(s.EncryptedInvoiceContent)
	}
	{
		if s.OfflineMode.Set {
			e.FieldStart("offlineMode")
			s.OfflineMode.Encode(e)
		}
	}
	{
		if s.HashOfCorrectedInvoice.Set {
			e.FieldStart("hashOfCorrectedInvoice")
			s.HashOfCorrectedInvoice.Encode(e)
		}
	}
}

var jsonFieldsNameOfSendInvoiceRequest = [7]string{
	0: "invoiceHash",
	1: "invoiceSize",
	2: "encryptedInvoiceHash",
	3: "encryptedInvoiceSize",
	4: "encryptedInvoiceContent",
	5: "offlineMode",
	6: "hashOfCorrectedInvoice",
}

// Decode decodes SendInvoiceRequest from json.
func (s *SendInvoiceRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SendInvoiceRequest to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "invoiceHash":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.InvoiceHash.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"invoiceHash\"")
			}
		case "invoiceSize":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int64()
				s.InvoiceSize = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"invoiceSize\"")
			}
		case "encryptedInvoiceHash":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.EncryptedInvoiceHash.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"encryptedInvoiceHash\"")
			}
		case "encryptedInvoiceSize":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int64()
				s.EncryptedInvoiceSize = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"encryptedInvoiceSize\"")
			}
		case "encryptedInvoiceContent":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Base64()
				s.EncryptedInvoiceContent = []byte(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"encryptedInvoiceContent\"")
			}
		case "offlineMode":
			if err := func() error {
				s.OfflineMode.Reset()
				if err := s.OfflineMode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"offlineMode\"")
			}
		case "hashOfCorrectedInvoice":
			if err := func() error {
				s.HashOfCorrectedInvoice.Reset()
				if err := s.HashOfCorrectedInvoice.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hashOfCorrectedInvoice\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SendInvoiceRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSendInvoiceRequest) {
					name = jsonFieldsNameOfSendInvoiceRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SendInvoiceRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SendInvoiceRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SendInvoiceResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SendInvoiceResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("referenceNumber")
		s.ReferenceNumber.Encode(e)
	}
}

var jsonFieldsNameOfSendInvoiceResponse = [1]string{
	0: "referenceNumber",
}

// Decode decodes SendInvoiceResponse from json.
func (s *SendInvoiceResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SendInvoiceResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "referenceNumber":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ReferenceNumber.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"referenceNumber\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SendInvoiceResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSendInvoiceResponse) {
					name = jsonFieldsNameOfSendInvoiceResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SendInvoiceResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SendInvoiceResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SessionInvoiceStatusResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SessionInvoiceStatusResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("ordinalNumber")
		e.Int32(s.OrdinalNumber)
	}
	{
		if s.InvoiceNumber.Set {
			e.FieldStart("invoiceNumber")
			s.InvoiceNumber.Encode(e)
		}
	}
	{
		if s.KsefNumber.Set {
			e.FieldStart("ksefNumber")
			s.KsefNumber.Encode(e)
		}
	}
	{
		e.FieldStart("referenceNumber")
		s.ReferenceNumber.Encode(e)
	}
	{
		e.FieldStart("invoiceHash")
		s.InvoiceHash.Encode(e)
	}
	{
		if s.InvoiceFileName.Set {
			e.FieldStart("invoiceFileName")
			s.InvoiceFileName.Encode(e)
		}
	}
	{
		if s.AcquisitionDate.Set {
			e.FieldStart("acquisitionDate")
			s.AcquisitionDate.Encode(e, json.EncodeDateTime)
		}
	}
	{
		e.FieldStart("invoicingDate")
		json.EncodeDateTime(e, s.InvoicingDate)
	}
	{
		if s.PermanentStorageDate.Set {
			e.FieldStart("permanentStorageDate")
			s.PermanentStorageDate.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpoDownloadUrl.Set {
			e.FieldStart("upoDownloadUrl")
			s.UpoDownloadUrl.Encode(e)
		}
	}
	{
		if s.UpoDownloadUrlExpirationDate.Set {
			e.FieldStart("upoDownloadUrlExpirationDate")
			s.UpoDownloadUrlExpirationDate.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.InvoicingMode.Set {
			e.FieldStart("invoicingMode")
			s.InvoicingMode.Encode(e)
		}
	}
	{
		e.FieldStart("status")
		s.Status.Encode(e)
	}
}

var jsonFieldsNameOfSessionInvoiceStatusResponse = [13]string{
	0:  "ordinalNumber",
	1:  "invoiceNumber",
	2:  "ksefNumber",
	3:  "referenceNumber",
	4:  "invoiceHash",
	5:  "invoiceFileName",
	6:  "acquisitionDate",
	7:  "invoicingDate",
	8:  "permanentStorageDate",
	9:  "upoDownloadUrl",
	10: "upoDownloadUrlExpirationDate",
	11: "invoicingMode",
	12: "status",
}

// Decode decodes SessionInvoiceStatusResponse from json.
func (s *SessionInvoiceStatusResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SessionInvoiceStatusResponse to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ordinalNumber":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.OrdinalNumber = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ordinalNumber\"")
			}
		case "invoiceNumber":
			if err := func() error {
				s.InvoiceNumber.Reset()
				if err := s.InvoiceNumber.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"invoiceNumber\"")
			}
		case "ksefNumber":
			if err := func() error {
				s.KsefNumber.Reset()
				if err := s.KsefNumber.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ksefNumber\"")
			}
		case "referenceNumber":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.ReferenceNumber.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"referenceNumber\"")
			}
		case "invoiceHash":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.InvoiceHash.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"invoiceHash\"")
			}
		case "invoiceFileName":
			if err := func() error {
				s.InvoiceFileName.Reset()
				if err := s.InvoiceFileName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"invoiceFileName\"")
			}
		case "acquisitionDate":
			if err := func() error {
				s.AcquisitionDate.Reset()
				if err := s.AcquisitionDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"acquisitionDate\"")
			}
		case "invoicingDate":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.InvoicingDate = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"invoicingDate\"")
			}
		case "permanentStorageDate":
			if err := func() error {
				s.PermanentStorageDate.Reset()
				if err := s.PermanentStorageDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"permanentStorageDate\"")
			}
		case "upoDownloadUrl":
			if err := func() error {
				s.UpoDownloadUrl.Reset()
				if err := s.UpoDownloadUrl.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"upoDownloadUrl\"")
			}
		case "upoDownloadUrlExpirationDate":
			if err := func() error {
				s.UpoDownloadUrlExpirationDate.Reset()
				if err := s.UpoDownloadUrlExpirationDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"upoDownloadUrlExpirationDate\"")
			}
		case "invoicingMode":
			if err := func() error {
				s.InvoicingMode.Reset()
				if err := s.InvoicingMode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"invoicingMode\"")
			}
		case "status":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SessionInvoiceStatusResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b10011001,
		0b00010000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSessionInvoiceStatusResponse) {
					name = jsonFieldsNameOfSessionInvoiceStatusResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SessionInvoiceStatusResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SessionInvoiceStatusResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SessionInvoicesResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SessionInvoicesResponse) encodeFields(e *jx.Encoder) {
	{
		if s.ContinuationToken.Set {
			e.FieldStart("continuationToken")
			s.ContinuationToken.Encode(e)
		}
	}
	{
		e.FieldStart("invoices")
		e.ArrStart()
		for _, elem := range s.Invoices {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfSessionInvoicesResponse = [2]string{
	0: "continuationToken",
	1: "invoices",
}

// Decode decodes SessionInvoicesResponse from json.
func (s *SessionInvoicesResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SessionInvoicesResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "continuationToken":
			if err := func() error {
				s.ContinuationToken.Reset()
				if err := s.ContinuationToken.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"continuationToken\"")
			}
		case "invoices":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Invoices = make([]SessionInvoiceStatusResponse, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SessionInvoiceStatusResponse
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Invoices = append(s.Invoices, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"invoices\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SessionInvoicesResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSessionInvoicesResponse) {
					name = jsonFieldsNameOfSessionInvoicesResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SessionInvoicesResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SessionInvoicesResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SessionStatusResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SessionStatusResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("status")
		s.Status.Encode(e)
	}
	{
		if s.ValidUntil.Set {
			e.FieldStart("validUntil")
			s.ValidUntil.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Upo.Set {
			e.FieldStart("upo")
			s.Upo.Encode(e)
		}
	}
	{
		if s.InvoiceCount.Set {
			e.FieldStart("invoiceCount")
			s.InvoiceCount.Encode(e)
		}
	}
	{
		if s.SuccessfulInvoiceCount.Set {
			e.FieldStart("successfulInvoiceCount")
			s.SuccessfulInvoiceCount.Encode(e)
		}
	}
	{
		if s.FailedInvoiceCount.Set {
			e.FieldStart("failedInvoiceCount")
			s.FailedInvoiceCount.Encode(e)
		}
	}
}

var jsonFieldsNameOfSessionStatusResponse = [6]string{
	0: "status",
	1: "validUntil",
	2: "upo",
	3: "invoiceCount",
	4: "successfulInvoiceCount",
	5: "failedInvoiceCount",
}

// Decode decodes SessionStatusResponse from json.
func (s *SessionStatusResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SessionStatusResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "status":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "validUntil":
			if err := func() error {
				s.ValidUntil.Reset()
				if err := s.ValidUntil.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"validUntil\"")
			}
		case "upo":
			if err := func() error {
				s.Upo.Reset()
				if err := s.Upo.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"upo\"")
			}
		case "invoiceCount":
			if err := func() error {
				s.InvoiceCount.Reset()
				if err := s.InvoiceCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"invoiceCount\"")
			}
		case "successfulInvoiceCount":
			if err := func() error {
				s.SuccessfulInvoiceCount.Reset()
				if err := s.SuccessfulInvoiceCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"successfulInvoiceCount\"")
			}
		case "failedInvoiceCount":
			if err := func() error {
				s.FailedInvoiceCount.Reset()
				if err := s.FailedInvoiceCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"failedInvoiceCount\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SessionStatusResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSessionStatusResponse) {
					name = jsonFieldsNameOfSessionStatusResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SessionStatusResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SessionStatusResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SessionsQueryResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SessionsQueryResponse) encodeFields(e *jx.Encoder) {
	{
		if s.ContinuationToken.Set {
			e.FieldStart("continuationToken")
			s.ContinuationToken.Encode(e)
		}
	}
	{
		e.FieldStart("sessions")
		e.ArrStart()
		for _, elem := range s.Sessions {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfSessionsQueryResponse = [2]string{
	0: "continuationToken",
	1: "sessions",
}

// Decode decodes SessionsQueryResponse from json.
func (s *SessionsQueryResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SessionsQueryResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "continuationToken":
			if err := func() error {
				s.ContinuationToken.Reset()
				if err := s.ContinuationToken.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"continuationToken\"")
			}
		case "sessions":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Sessions = make([]SessionsQueryResponseItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SessionsQueryResponseItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Sessions = append(s.Sessions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sessions\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SessionsQueryResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSessionsQueryResponse) {
					name = jsonFieldsNameOfSessionsQueryResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SessionsQueryResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SessionsQueryResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SessionsQueryResponseItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SessionsQueryResponseItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("referenceNumber")
		s.ReferenceNumber.Encode(e)
	}
	{
		e.FieldStart("status")
		s.Status.Encode(e)
	}
	{
		e.FieldStart("dateCreated")
		json.EncodeDateTime(e, s.DateCreated)
	}
	{
		e.FieldStart("dateUpdated")
		json.EncodeDateTime(e, s.DateUpdated)
	}
	{
		if s.ValidUntil.Set {
			e.FieldStart("validUntil")
			s.ValidUntil.Encode(e, json.EncodeDateTime)
		}
	}
	{
		e.FieldStart("totalInvoiceCount")
		e.Int32(s.TotalInvoiceCount)
	}
	{
		e.FieldStart("successfulInvoiceCount")
		e.Int32(s.SuccessfulInvoiceCount)
	}
	{
		e.FieldStart("failedInvoiceCount")
		e.Int32(s.FailedInvoiceCount)
	}
}

var jsonFieldsNameOfSessionsQueryResponseItem = [8]string{
	0: "referenceNumber",
	1: "status",
	2: "dateCreated",
	3: "dateUpdated",
	4: "validUntil",
	5: "totalInvoiceCount",
	6: "successfulInvoiceCount",
	7: "failedInvoiceCount",
}

// Decode decodes SessionsQueryResponseItem from json.
func (s *SessionsQueryResponseItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SessionsQueryResponseItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "referenceNumber":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ReferenceNumber.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"referenceNumber\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "dateCreated":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.DateCreated = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dateCreated\"")
			}
		case "dateUpdated":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.DateUpdated = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dateUpdated\"")
			}
		case "validUntil":
			if err := func() error {
				s.ValidUntil.Reset()
				if err := s.ValidUntil.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"validUntil\"")
			}
		case "totalInvoiceCount":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int32()
				s.TotalInvoiceCount = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalInvoiceCount\"")
			}
		case "successfulInvoiceCount":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int32()
				s.SuccessfulInvoiceCount = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"successfulInvoiceCount\"")
			}
		case "failedInvoiceCount":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Int32()
				s.FailedInvoiceCount = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"failedInvoiceCount\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SessionsQueryResponseItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b11101111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSessionsQueryResponseItem) {
					name = jsonFieldsNameOfSessionsQueryResponseItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SessionsQueryResponseItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SessionsQueryResponseItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SetRateLimitsRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SetRateLimitsRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("rateLimits")
		s.RateLimits.Encode(e)
	}
}

var jsonFieldsNameOfSetRateLimitsRequest = [1]string{
	0: "rateLimits",
}

// Decode decodes SetRateLimitsRequest from json.
func (s *SetRateLimitsRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SetRateLimitsRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "rateLimits":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.RateLimits.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rateLimits\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SetRateLimitsRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSetRateLimitsRequest) {
					name = jsonFieldsNameOfSetRateLimitsRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SetRateLimitsRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SetRateLimitsRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SetSessionLimitsRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SetSessionLimitsRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("onlineSession")
		s.OnlineSession.Encode(e)
	}
	{
		e.FieldStart("batchSession")
		s.BatchSession.Encode(e)
	}
}

var jsonFieldsNameOfSetSessionLimitsRequest = [2]string{
	0: "onlineSession",
	1: "batchSession",
}

// Decode decodes SetSessionLimitsRequest from json.
func (s *SetSessionLimitsRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SetSessionLimitsRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "onlineSession":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.OnlineSession.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"onlineSession\"")
			}
		case "batchSession":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.BatchSession.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"batchSession\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SetSessionLimitsRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSetSessionLimitsRequest) {
					name = jsonFieldsNameOfSetSessionLimitsRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SetSessionLimitsRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SetSessionLimitsRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SetSubjectLimitsRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SetSubjectLimitsRequest) encodeFields(e *jx.Encoder) {
	{
		if s.SubjectIdentifierType.Set {
			e.FieldStart("subjectIdentifierType")
			s.SubjectIdentifierType.Encode(e)
		}
	}
	{
		if s.Enrollment.Set {
			e.FieldStart("enrollment")
			s.Enrollment.Encode(e)
		}
	}
	{
		if s.Certificate.Set {
			e.FieldStart("certificate")
			s.Certificate.Encode(e)
		}
	}
}

var jsonFieldsNameOfSetSubjectLimitsRequest = [3]string{
	0: "subjectIdentifierType",
	1: "enrollment",
	2: "certificate",
}

// Decode decodes SetSubjectLimitsRequest from json.
func (s *SetSubjectLimitsRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SetSubjectLimitsRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "subjectIdentifierType":
			if err := func() error {
				s.SubjectIdentifierType.Reset()
				if err := s.SubjectIdentifierType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subjectIdentifierType\"")
			}
		case "enrollment":
			if err := func() error {
				s.Enrollment.Reset()
				if err := s.Enrollment.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enrollment\"")
			}
		case "certificate":
			if err := func() error {
				s.Certificate.Reset()
				if err := s.Certificate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"certificate\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SetSubjectLimitsRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SetSubjectLimitsRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SetSubjectLimitsRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Sha256HashBase64 as json.
func (s Sha256HashBase64) Encode(e *jx.Encoder) {
	unwrapped := []byte(s)

	e.Base64(unwrapped)
}

// Decode decodes Sha256HashBase64 from json.
func (s *Sha256HashBase64) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Sha256HashBase64 to nil")
	}
	var unwrapped []byte
	if err := func() error {
		v, err := d.Base64()
		unwrapped = []byte(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = Sha256HashBase64(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s Sha256HashBase64) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Sha256HashBase64) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *StatusInfo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *StatusInfo) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Int32(s.Code)
	}
	{
		e.FieldStart("description")
		e.Str(s.Description)
	}
	{
		if s.Details.Set {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfStatusInfo = [3]string{
	0: "code",
	1: "description",
	2: "details",
}

// Decode decodes StatusInfo from json.
func (s *StatusInfo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StatusInfo to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Code = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "details":
			if err := func() error {
				s.Details.Reset()
				if err := s.Details.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode StatusInfo")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfStatusInfo) {
					name = jsonFieldsNameOfStatusInfo[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *StatusInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StatusInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SubjectCreateRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SubjectCreateRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("subjectNip")
		s.SubjectNip.Encode(e)
	}
	{
		e.FieldStart("subjectType")
		s.SubjectType.Encode(e)
	}
	{
		if s.Subunits.Set {
			e.FieldStart("subunits")
			s.Subunits.Encode(e)
		}
	}
	{
		e.FieldStart("description")
		e.Str(s.Description)
	}
	{
		if s.CreatedDate.Set {
			e.FieldStart("createdDate")
			s.CreatedDate.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfSubjectCreateRequest = [5]string{
	0: "subjectNip",
	1: "subjectType",
	2: "subunits",
	3: "description",
	4: "createdDate",
}

// Decode decodes SubjectCreateRequest from json.
func (s *SubjectCreateRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SubjectCreateRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "subjectNip":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.SubjectNip.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subjectNip\"")
			}
		case "subjectType":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.SubjectType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subjectType\"")
			}
		case "subunits":
			if err := func() error {
				s.Subunits.Reset()
				if err := s.Subunits.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subunits\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "createdDate":
			if err := func() error {
				s.CreatedDate.Reset()
				if err := s.CreatedDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdDate\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SubjectCreateRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSubjectCreateRequest) {
					name = jsonFieldsNameOfSubjectCreateRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SubjectCreateRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SubjectCreateRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SubjectIdentifierType as json.
func (s SubjectIdentifierType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SubjectIdentifierType from json.
func (s *SubjectIdentifierType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SubjectIdentifierType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SubjectIdentifierType(v) {
	case SubjectIdentifierTypeNip:
		*s = SubjectIdentifierTypeNip
	case SubjectIdentifierTypePesel:
		*s = SubjectIdentifierTypePesel
	case SubjectIdentifierTypeFingerprint:
		*s = SubjectIdentifierTypeFingerprint
	case SubjectIdentifierTypeToken:
		*s = SubjectIdentifierTypeToken
	default:
		*s = SubjectIdentifierType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SubjectIdentifierType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SubjectIdentifierType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SubjectRemoveRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SubjectRemoveRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("subjectNip")
		s.SubjectNip.Encode(e)
	}
}

var jsonFieldsNameOfSubjectRemoveRequest = [1]string{
	0: "subjectNip",
}

// Decode decodes SubjectRemoveRequest from json.
func (s *SubjectRemoveRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SubjectRemoveRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "subjectNip":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.SubjectNip.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subjectNip\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SubjectRemoveRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSubjectRemoveRequest) {
					name = jsonFieldsNameOfSubjectRemoveRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SubjectRemoveRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SubjectRemoveRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SubjectType as json.
func (s SubjectType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SubjectType from json.
func (s *SubjectType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SubjectType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SubjectType(v) {
	case SubjectTypeEnforcementAuthority:
		*s = SubjectTypeEnforcementAuthority
	case SubjectTypeVatGroup:
		*s = SubjectTypeVatGroup
	case SubjectTypeJST:
		*s = SubjectTypeJST
	default:
		*s = SubjectType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SubjectType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SubjectType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SubordinateEntityRole) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SubordinateEntityRole) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("subordinateEntityIdentifier")
		s.SubordinateEntityIdentifier.Encode(e)
	}
	{
		e.FieldStart("role")
		s.Role.Encode(e)
	}
	{
		e.FieldStart("description")
		e.Str(s.Description)
	}
	{
		e.FieldStart("startDate")
		json.EncodeDateTime(e, s.StartDate)
	}
}

var jsonFieldsNameOfSubordinateEntityRole = [4]string{
	0: "subordinateEntityIdentifier",
	1: "role",
	2: "description",
	3: "startDate",
}

// Decode decodes SubordinateEntityRole from json.
func (s *SubordinateEntityRole) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SubordinateEntityRole to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "subordinateEntityIdentifier":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.SubordinateEntityIdentifier.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subordinateEntityIdentifier\"")
			}
		case "role":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Role.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"role\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "startDate":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.StartDate = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"startDate\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SubordinateEntityRole")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSubordinateEntityRole) {
					name = jsonFieldsNameOfSubordinateEntityRole[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SubordinateEntityRole) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SubordinateEntityRole) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SubordinateEntityRoleType as json.
func (s SubordinateEntityRoleType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SubordinateEntityRoleType from json.
func (s *SubordinateEntityRoleType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SubordinateEntityRoleType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SubordinateEntityRoleType(v) {
	case SubordinateEntityRoleTypeLocalGovernmentSubUnit:
		*s = SubordinateEntityRoleTypeLocalGovernmentSubUnit
	case SubordinateEntityRoleTypeVatGroupSubUnit:
		*s = SubordinateEntityRoleTypeVatGroupSubUnit
	default:
		*s = SubordinateEntityRoleType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SubordinateEntityRoleType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SubordinateEntityRoleType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SubordinateEntityRolesQueryRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SubordinateEntityRolesQueryRequest) encodeFields(e *jx.Encoder) {
	{
		if s.SubordinateEntityIdentifier.Set {
			e.FieldStart("subordinateEntityIdentifier")
			s.SubordinateEntityIdentifier.Encode(e)
		}
	}
}

var jsonFieldsNameOfSubordinateEntityRolesQueryRequest = [1]string{
	0: "subordinateEntityIdentifier",
}

// Decode decodes SubordinateEntityRolesQueryRequest from json.
func (s *SubordinateEntityRolesQueryRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SubordinateEntityRolesQueryRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "subordinateEntityIdentifier":
			if err := func() error {
				s.SubordinateEntityIdentifier.Reset()
				if err := s.SubordinateEntityIdentifier.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subordinateEntityIdentifier\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SubordinateEntityRolesQueryRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SubordinateEntityRolesQueryRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SubordinateEntityRolesQueryRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SubordinateRoleSubordinateEntityIdentifier) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SubordinateRoleSubordinateEntityIdentifier) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("value")
		e.Str(s.Value)
	}
}

var jsonFieldsNameOfSubordinateRoleSubordinateEntityIdentifier = [2]string{
	0: "type",
	1: "value",
}

// Decode decodes SubordinateRoleSubordinateEntityIdentifier from json.
func (s *SubordinateRoleSubordinateEntityIdentifier) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SubordinateRoleSubordinateEntityIdentifier to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "value":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Value = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SubordinateRoleSubordinateEntityIdentifier")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSubordinateRoleSubordinateEntityIdentifier) {
					name = jsonFieldsNameOfSubordinateRoleSubordinateEntityIdentifier[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SubordinateRoleSubordinateEntityIdentifier) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SubordinateRoleSubordinateEntityIdentifier) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SubordinateRoleSubordinateEntityIdentifierType as json.
func (s SubordinateRoleSubordinateEntityIdentifierType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SubordinateRoleSubordinateEntityIdentifierType from json.
func (s *SubordinateRoleSubordinateEntityIdentifierType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SubordinateRoleSubordinateEntityIdentifierType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SubordinateRoleSubordinateEntityIdentifierType(v) {
	case SubordinateRoleSubordinateEntityIdentifierTypeNip:
		*s = SubordinateRoleSubordinateEntityIdentifierTypeNip
	default:
		*s = SubordinateRoleSubordinateEntityIdentifierType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SubordinateRoleSubordinateEntityIdentifierType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SubordinateRoleSubordinateEntityIdentifierType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Subunit) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Subunit) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("subjectNip")
		s.SubjectNip.Encode(e)
	}
	{
		e.FieldStart("description")
		e.Str(s.Description)
	}
}

var jsonFieldsNameOfSubunit = [2]string{
	0: "subjectNip",
	1: "description",
}

// Decode decodes Subunit from json.
func (s *Subunit) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Subunit to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "subjectNip":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.SubjectNip.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subjectNip\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Subunit")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSubunit) {
					name = jsonFieldsNameOfSubunit[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Subunit) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Subunit) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SubunitPermission) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SubunitPermission) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		s.ID.Encode(e)
	}
	{
		e.FieldStart("authorizedIdentifier")
		s.AuthorizedIdentifier.Encode(e)
	}
	{
		e.FieldStart("subunitIdentifier")
		s.SubunitIdentifier.Encode(e)
	}
	{
		e.FieldStart("authorIdentifier")
		s.AuthorIdentifier.Encode(e)
	}
	{
		e.FieldStart("permissionScope")
		s.PermissionScope.Encode(e)
	}
	{
		e.FieldStart("description")
		e.Str(s.Description)
	}
	{
		if s.SubunitName.Set {
			e.FieldStart("subunitName")
			s.SubunitName.Encode(e)
		}
	}
	{
		e.FieldStart("startDate")
		json.EncodeDateTime(e, s.StartDate)
	}
}

var jsonFieldsNameOfSubunitPermission = [8]string{
	0: "id",
	1: "authorizedIdentifier",
	2: "subunitIdentifier",
	3: "authorIdentifier",
	4: "permissionScope",
	5: "description",
	6: "subunitName",
	7: "startDate",
}

// Decode decodes SubunitPermission from json.
func (s *SubunitPermission) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SubunitPermission to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "authorizedIdentifier":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.AuthorizedIdentifier.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"authorizedIdentifier\"")
			}
		case "subunitIdentifier":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.SubunitIdentifier.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subunitIdentifier\"")
			}
		case "authorIdentifier":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.AuthorIdentifier.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"authorIdentifier\"")
			}
		case "permissionScope":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.PermissionScope.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"permissionScope\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "subunitName":
			if err := func() error {
				s.SubunitName.Reset()
				if err := s.SubunitName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subunitName\"")
			}
		case "startDate":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.StartDate = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"startDate\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SubunitPermission")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b10111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSubunitPermission) {
					name = jsonFieldsNameOfSubunitPermission[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SubunitPermission) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SubunitPermission) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SubunitPermissionScope as json.
func (s SubunitPermissionScope) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SubunitPermissionScope from json.
func (s *SubunitPermissionScope) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SubunitPermissionScope to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SubunitPermissionScope(v) {
	case SubunitPermissionScopeCredentialsManage:
		*s = SubunitPermissionScopeCredentialsManage
	default:
		*s = SubunitPermissionScope(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SubunitPermissionScope) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SubunitPermissionScope) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SubunitPermissionsAuthorIdentifier) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SubunitPermissionsAuthorIdentifier) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("value")
		e.Str(s.Value)
	}
}

var jsonFieldsNameOfSubunitPermissionsAuthorIdentifier = [2]string{
	0: "type",
	1: "value",
}

// Decode decodes SubunitPermissionsAuthorIdentifier from json.
func (s *SubunitPermissionsAuthorIdentifier) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SubunitPermissionsAuthorIdentifier to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "value":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Value = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SubunitPermissionsAuthorIdentifier")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSubunitPermissionsAuthorIdentifier) {
					name = jsonFieldsNameOfSubunitPermissionsAuthorIdentifier[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SubunitPermissionsAuthorIdentifier) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SubunitPermissionsAuthorIdentifier) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SubunitPermissionsAuthorIdentifierType as json.
func (s SubunitPermissionsAuthorIdentifierType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SubunitPermissionsAuthorIdentifierType from json.
func (s *SubunitPermissionsAuthorIdentifierType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SubunitPermissionsAuthorIdentifierType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SubunitPermissionsAuthorIdentifierType(v) {
	case SubunitPermissionsAuthorIdentifierTypeNip:
		*s = SubunitPermissionsAuthorIdentifierTypeNip
	case SubunitPermissionsAuthorIdentifierTypePesel:
		*s = SubunitPermissionsAuthorIdentifierTypePesel
	case SubunitPermissionsAuthorIdentifierTypeFingerprint:
		*s = SubunitPermissionsAuthorIdentifierTypeFingerprint
	default:
		*s = SubunitPermissionsAuthorIdentifierType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SubunitPermissionsAuthorIdentifierType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SubunitPermissionsAuthorIdentifierType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SubunitPermissionsAuthorizedIdentifier) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SubunitPermissionsAuthorizedIdentifier) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("value")
		e.Str(s.Value)
	}
}

var jsonFieldsNameOfSubunitPermissionsAuthorizedIdentifier = [2]string{
	0: "type",
	1: "value",
}

// Decode decodes SubunitPermissionsAuthorizedIdentifier from json.
func (s *SubunitPermissionsAuthorizedIdentifier) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SubunitPermissionsAuthorizedIdentifier to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "value":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Value = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SubunitPermissionsAuthorizedIdentifier")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSubunitPermissionsAuthorizedIdentifier) {
					name = jsonFieldsNameOfSubunitPermissionsAuthorizedIdentifier[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SubunitPermissionsAuthorizedIdentifier) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SubunitPermissionsAuthorizedIdentifier) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SubunitPermissionsContextIdentifier) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SubunitPermissionsContextIdentifier) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("value")
		e.Str(s.Value)
	}
}

var jsonFieldsNameOfSubunitPermissionsContextIdentifier = [2]string{
	0: "type",
	1: "value",
}

// Decode decodes SubunitPermissionsContextIdentifier from json.
func (s *SubunitPermissionsContextIdentifier) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SubunitPermissionsContextIdentifier to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "value":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Value = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SubunitPermissionsContextIdentifier")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSubunitPermissionsContextIdentifier) {
					name = jsonFieldsNameOfSubunitPermissionsContextIdentifier[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SubunitPermissionsContextIdentifier) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SubunitPermissionsContextIdentifier) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SubunitPermissionsContextIdentifierType as json.
func (s SubunitPermissionsContextIdentifierType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SubunitPermissionsContextIdentifierType from json.
func (s *SubunitPermissionsContextIdentifierType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SubunitPermissionsContextIdentifierType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SubunitPermissionsContextIdentifierType(v) {
	case SubunitPermissionsContextIdentifierTypeInternalId:
		*s = SubunitPermissionsContextIdentifierTypeInternalId
	case SubunitPermissionsContextIdentifierTypeNip:
		*s = SubunitPermissionsContextIdentifierTypeNip
	default:
		*s = SubunitPermissionsContextIdentifierType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SubunitPermissionsContextIdentifierType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SubunitPermissionsContextIdentifierType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SubunitPermissionsGrantRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SubunitPermissionsGrantRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("subjectIdentifier")
		s.SubjectIdentifier.Encode(e)
	}
	{
		e.FieldStart("contextIdentifier")
		s.ContextIdentifier.Encode(e)
	}
	{
		e.FieldStart("description")
		e.Str(s.Description)
	}
	{
		if s.SubunitName.Set {
			e.FieldStart("subunitName")
			s.SubunitName.Encode(e)
		}
	}
}

var jsonFieldsNameOfSubunitPermissionsGrantRequest = [4]string{
	0: "subjectIdentifier",
	1: "contextIdentifier",
	2: "description",
	3: "subunitName",
}

// Decode decodes SubunitPermissionsGrantRequest from json.
func (s *SubunitPermissionsGrantRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SubunitPermissionsGrantRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "subjectIdentifier":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.SubjectIdentifier.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subjectIdentifier\"")
			}
		case "contextIdentifier":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.ContextIdentifier.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"contextIdentifier\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "subunitName":
			if err := func() error {
				s.SubunitName.Reset()
				if err := s.SubunitName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subunitName\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SubunitPermissionsGrantRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSubunitPermissionsGrantRequest) {
					name = jsonFieldsNameOfSubunitPermissionsGrantRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SubunitPermissionsGrantRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SubunitPermissionsGrantRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SubunitPermissionsQueryRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SubunitPermissionsQueryRequest) encodeFields(e *jx.Encoder) {
	{
		if s.SubunitIdentifier.Set {
			e.FieldStart("subunitIdentifier")
			s.SubunitIdentifier.Encode(e)
		}
	}
}

var jsonFieldsNameOfSubunitPermissionsQueryRequest = [1]string{
	0: "subunitIdentifier",
}

// Decode decodes SubunitPermissionsQueryRequest from json.
func (s *SubunitPermissionsQueryRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SubunitPermissionsQueryRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "subunitIdentifier":
			if err := func() error {
				s.SubunitIdentifier.Reset()
				if err := s.SubunitIdentifier.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subunitIdentifier\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SubunitPermissionsQueryRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SubunitPermissionsQueryRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SubunitPermissionsQueryRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SubunitPermissionsSubjectIdentifier) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SubunitPermissionsSubjectIdentifier) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("value")
		e.Str(s.Value)
	}
}

var jsonFieldsNameOfSubunitPermissionsSubjectIdentifier = [2]string{
	0: "type",
	1: "value",
}

// Decode decodes SubunitPermissionsSubjectIdentifier from json.
func (s *SubunitPermissionsSubjectIdentifier) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SubunitPermissionsSubjectIdentifier to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "value":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Value = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SubunitPermissionsSubjectIdentifier")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSubunitPermissionsSubjectIdentifier) {
					name = jsonFieldsNameOfSubunitPermissionsSubjectIdentifier[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SubunitPermissionsSubjectIdentifier) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SubunitPermissionsSubjectIdentifier) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SubunitPermissionsSubjectIdentifierType as json.
func (s SubunitPermissionsSubjectIdentifierType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SubunitPermissionsSubjectIdentifierType from json.
func (s *SubunitPermissionsSubjectIdentifierType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SubunitPermissionsSubjectIdentifierType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SubunitPermissionsSubjectIdentifierType(v) {
	case SubunitPermissionsSubjectIdentifierTypeNip:
		*s = SubunitPermissionsSubjectIdentifierTypeNip
	case SubunitPermissionsSubjectIdentifierTypePesel:
		*s = SubunitPermissionsSubjectIdentifierTypePesel
	case SubunitPermissionsSubjectIdentifierTypeFingerprint:
		*s = SubunitPermissionsSubjectIdentifierTypeFingerprint
	default:
		*s = SubunitPermissionsSubjectIdentifierType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SubunitPermissionsSubjectIdentifierType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SubunitPermissionsSubjectIdentifierType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SubunitPermissionsSubunitIdentifier) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SubunitPermissionsSubunitIdentifier) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("value")
		e.Str(s.Value)
	}
}

var jsonFieldsNameOfSubunitPermissionsSubunitIdentifier = [2]string{
	0: "type",
	1: "value",
}

// Decode decodes SubunitPermissionsSubunitIdentifier from json.
func (s *SubunitPermissionsSubunitIdentifier) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SubunitPermissionsSubunitIdentifier to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "value":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Value = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SubunitPermissionsSubunitIdentifier")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSubunitPermissionsSubunitIdentifier) {
					name = jsonFieldsNameOfSubunitPermissionsSubunitIdentifier[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SubunitPermissionsSubunitIdentifier) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SubunitPermissionsSubunitIdentifier) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SubunitPermissionsSubunitIdentifierType as json.
func (s SubunitPermissionsSubunitIdentifierType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SubunitPermissionsSubunitIdentifierType from json.
func (s *SubunitPermissionsSubunitIdentifierType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SubunitPermissionsSubunitIdentifierType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SubunitPermissionsSubunitIdentifierType(v) {
	case SubunitPermissionsSubunitIdentifierTypeInternalId:
		*s = SubunitPermissionsSubunitIdentifierTypeInternalId
	case SubunitPermissionsSubunitIdentifierTypeNip:
		*s = SubunitPermissionsSubunitIdentifierTypeNip
	default:
		*s = SubunitPermissionsSubunitIdentifierType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SubunitPermissionsSubunitIdentifierType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SubunitPermissionsSubunitIdentifierType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TestDataAuthorizedIdentifier) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TestDataAuthorizedIdentifier) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("value")
		e.Str(s.Value)
	}
}

var jsonFieldsNameOfTestDataAuthorizedIdentifier = [2]string{
	0: "type",
	1: "value",
}

// Decode decodes TestDataAuthorizedIdentifier from json.
func (s *TestDataAuthorizedIdentifier) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TestDataAuthorizedIdentifier to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "value":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Value = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TestDataAuthorizedIdentifier")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTestDataAuthorizedIdentifier) {
					name = jsonFieldsNameOfTestDataAuthorizedIdentifier[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TestDataAuthorizedIdentifier) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TestDataAuthorizedIdentifier) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TestDataAuthorizedIdentifierType as json.
func (s TestDataAuthorizedIdentifierType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TestDataAuthorizedIdentifierType from json.
func (s *TestDataAuthorizedIdentifierType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TestDataAuthorizedIdentifierType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TestDataAuthorizedIdentifierType(v) {
	case TestDataAuthorizedIdentifierTypeNip:
		*s = TestDataAuthorizedIdentifierTypeNip
	case TestDataAuthorizedIdentifierTypePesel:
		*s = TestDataAuthorizedIdentifierTypePesel
	case TestDataAuthorizedIdentifierTypeFingerprint:
		*s = TestDataAuthorizedIdentifierTypeFingerprint
	default:
		*s = TestDataAuthorizedIdentifierType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TestDataAuthorizedIdentifierType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TestDataAuthorizedIdentifierType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TestDataContextIdentifier) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TestDataContextIdentifier) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("value")
		e.Str(s.Value)
	}
}

var jsonFieldsNameOfTestDataContextIdentifier = [2]string{
	0: "type",
	1: "value",
}

// Decode decodes TestDataContextIdentifier from json.
func (s *TestDataContextIdentifier) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TestDataContextIdentifier to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "value":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Value = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TestDataContextIdentifier")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTestDataContextIdentifier) {
					name = jsonFieldsNameOfTestDataContextIdentifier[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TestDataContextIdentifier) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TestDataContextIdentifier) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TestDataContextIdentifierType as json.
func (s TestDataContextIdentifierType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TestDataContextIdentifierType from json.
func (s *TestDataContextIdentifierType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TestDataContextIdentifierType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TestDataContextIdentifierType(v) {
	case TestDataContextIdentifierTypeNip:
		*s = TestDataContextIdentifierTypeNip
	default:
		*s = TestDataContextIdentifierType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TestDataContextIdentifierType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TestDataContextIdentifierType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TestDataPermission) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TestDataPermission) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("description")
		e.Str(s.Description)
	}
	{
		e.FieldStart("permissionType")
		s.PermissionType.Encode(e)
	}
}

var jsonFieldsNameOfTestDataPermission = [2]string{
	0: "description",
	1: "permissionType",
}

// Decode decodes TestDataPermission from json.
func (s *TestDataPermission) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TestDataPermission to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "description":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "permissionType":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.PermissionType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"permissionType\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TestDataPermission")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTestDataPermission) {
					name = jsonFieldsNameOfTestDataPermission[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TestDataPermission) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TestDataPermission) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TestDataPermissionType as json.
func (s TestDataPermissionType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TestDataPermissionType from json.
func (s *TestDataPermissionType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TestDataPermissionType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TestDataPermissionType(v) {
	case TestDataPermissionTypeInvoiceRead:
		*s = TestDataPermissionTypeInvoiceRead
	case TestDataPermissionTypeInvoiceWrite:
		*s = TestDataPermissionTypeInvoiceWrite
	case TestDataPermissionTypeIntrospection:
		*s = TestDataPermissionTypeIntrospection
	case TestDataPermissionTypeCredentialsRead:
		*s = TestDataPermissionTypeCredentialsRead
	case TestDataPermissionTypeCredentialsManage:
		*s = TestDataPermissionTypeCredentialsManage
	case TestDataPermissionTypeEnforcementOperations:
		*s = TestDataPermissionTypeEnforcementOperations
	case TestDataPermissionTypeSubunitManage:
		*s = TestDataPermissionTypeSubunitManage
	default:
		*s = TestDataPermissionType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TestDataPermissionType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TestDataPermissionType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TestDataPermissionsGrantRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TestDataPermissionsGrantRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("contextIdentifier")
		s.ContextIdentifier.Encode(e)
	}
	{
		e.FieldStart("authorizedIdentifier")
		s.AuthorizedIdentifier.Encode(e)
	}
	{
		e.FieldStart("permissions")
		e.ArrStart()
		for _, elem := range s.Permissions {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfTestDataPermissionsGrantRequest = [3]string{
	0: "contextIdentifier",
	1: "authorizedIdentifier",
	2: "permissions",
}

// Decode decodes TestDataPermissionsGrantRequest from json.
func (s *TestDataPermissionsGrantRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TestDataPermissionsGrantRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "contextIdentifier":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ContextIdentifier.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"contextIdentifier\"")
			}
		case "authorizedIdentifier":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.AuthorizedIdentifier.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"authorizedIdentifier\"")
			}
		case "permissions":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.Permissions = make([]TestDataPermission, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem TestDataPermission
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Permissions = append(s.Permissions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"permissions\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TestDataPermissionsGrantRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTestDataPermissionsGrantRequest) {
					name = jsonFieldsNameOfTestDataPermissionsGrantRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TestDataPermissionsGrantRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TestDataPermissionsGrantRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TestDataPermissionsRevokeRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TestDataPermissionsRevokeRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("contextIdentifier")
		s.ContextIdentifier.Encode(e)
	}
	{
		e.FieldStart("authorizedIdentifier")
		s.AuthorizedIdentifier.Encode(e)
	}
}

var jsonFieldsNameOfTestDataPermissionsRevokeRequest = [2]string{
	0: "contextIdentifier",
	1: "authorizedIdentifier",
}

// Decode decodes TestDataPermissionsRevokeRequest from json.
func (s *TestDataPermissionsRevokeRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TestDataPermissionsRevokeRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "contextIdentifier":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ContextIdentifier.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"contextIdentifier\"")
			}
		case "authorizedIdentifier":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.AuthorizedIdentifier.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"authorizedIdentifier\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TestDataPermissionsRevokeRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTestDataPermissionsRevokeRequest) {
					name = jsonFieldsNameOfTestDataPermissionsRevokeRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TestDataPermissionsRevokeRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TestDataPermissionsRevokeRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ThirdSubjectIdentifierType as json.
func (s ThirdSubjectIdentifierType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ThirdSubjectIdentifierType from json.
func (s *ThirdSubjectIdentifierType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ThirdSubjectIdentifierType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ThirdSubjectIdentifierType(v) {
	case ThirdSubjectIdentifierTypeNip:
		*s = ThirdSubjectIdentifierTypeNip
	case ThirdSubjectIdentifierTypeInternalId:
		*s = ThirdSubjectIdentifierTypeInternalId
	case ThirdSubjectIdentifierTypeVatUe:
		*s = ThirdSubjectIdentifierTypeVatUe
	case ThirdSubjectIdentifierTypeOther:
		*s = ThirdSubjectIdentifierTypeOther
	case ThirdSubjectIdentifierTypeNone:
		*s = ThirdSubjectIdentifierTypeNone
	default:
		*s = ThirdSubjectIdentifierType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ThirdSubjectIdentifierType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ThirdSubjectIdentifierType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TokenAuthorIdentifierType as json.
func (s TokenAuthorIdentifierType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TokenAuthorIdentifierType from json.
func (s *TokenAuthorIdentifierType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TokenAuthorIdentifierType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TokenAuthorIdentifierType(v) {
	case TokenAuthorIdentifierTypeNip:
		*s = TokenAuthorIdentifierTypeNip
	case TokenAuthorIdentifierTypePesel:
		*s = TokenAuthorIdentifierTypePesel
	case TokenAuthorIdentifierTypeFingerprint:
		*s = TokenAuthorIdentifierTypeFingerprint
	default:
		*s = TokenAuthorIdentifierType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TokenAuthorIdentifierType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TokenAuthorIdentifierType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TokenAuthorIdentifierTypeIdentifier) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TokenAuthorIdentifierTypeIdentifier) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("value")
		e.Str(s.Value)
	}
}

var jsonFieldsNameOfTokenAuthorIdentifierTypeIdentifier = [2]string{
	0: "type",
	1: "value",
}

// Decode decodes TokenAuthorIdentifierTypeIdentifier from json.
func (s *TokenAuthorIdentifierTypeIdentifier) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TokenAuthorIdentifierTypeIdentifier to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "value":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Value = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TokenAuthorIdentifierTypeIdentifier")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTokenAuthorIdentifierTypeIdentifier) {
					name = jsonFieldsNameOfTokenAuthorIdentifierTypeIdentifier[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TokenAuthorIdentifierTypeIdentifier) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TokenAuthorIdentifierTypeIdentifier) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TokenContextIdentifierType as json.
func (s TokenContextIdentifierType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TokenContextIdentifierType from json.
func (s *TokenContextIdentifierType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TokenContextIdentifierType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TokenContextIdentifierType(v) {
	case TokenContextIdentifierTypeNip:
		*s = TokenContextIdentifierTypeNip
	case TokenContextIdentifierTypeInternalId:
		*s = TokenContextIdentifierTypeInternalId
	case TokenContextIdentifierTypeNipVatUe:
		*s = TokenContextIdentifierTypeNipVatUe
	case TokenContextIdentifierTypePeppolId:
		*s = TokenContextIdentifierTypePeppolId
	default:
		*s = TokenContextIdentifierType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TokenContextIdentifierType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TokenContextIdentifierType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TokenContextIdentifierTypeIdentifier) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TokenContextIdentifierTypeIdentifier) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("value")
		e.Str(s.Value)
	}
}

var jsonFieldsNameOfTokenContextIdentifierTypeIdentifier = [2]string{
	0: "type",
	1: "value",
}

// Decode decodes TokenContextIdentifierTypeIdentifier from json.
func (s *TokenContextIdentifierTypeIdentifier) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TokenContextIdentifierTypeIdentifier to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "value":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Value = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TokenContextIdentifierTypeIdentifier")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTokenContextIdentifierTypeIdentifier) {
					name = jsonFieldsNameOfTokenContextIdentifierTypeIdentifier[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TokenContextIdentifierTypeIdentifier) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TokenContextIdentifierTypeIdentifier) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TokenInfo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TokenInfo) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("token")
		e.Str(s.Token)
	}
	{
		e.FieldStart("validUntil")
		json.EncodeDateTime(e, s.ValidUntil)
	}
}

var jsonFieldsNameOfTokenInfo = [2]string{
	0: "token",
	1: "validUntil",
}

// Decode decodes TokenInfo from json.
func (s *TokenInfo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TokenInfo to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "token":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Token = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"token\"")
			}
		case "validUntil":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.ValidUntil = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"validUntil\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TokenInfo")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTokenInfo) {
					name = jsonFieldsNameOfTokenInfo[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TokenInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TokenInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TokenPermissionType as json.
func (s TokenPermissionType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TokenPermissionType from json.
func (s *TokenPermissionType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TokenPermissionType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TokenPermissionType(v) {
	case TokenPermissionTypeInvoiceRead:
		*s = TokenPermissionTypeInvoiceRead
	case TokenPermissionTypeInvoiceWrite:
		*s = TokenPermissionTypeInvoiceWrite
	case TokenPermissionTypeCredentialsRead:
		*s = TokenPermissionTypeCredentialsRead
	case TokenPermissionTypeCredentialsManage:
		*s = TokenPermissionTypeCredentialsManage
	case TokenPermissionTypeSubunitManage:
		*s = TokenPermissionTypeSubunitManage
	case TokenPermissionTypeEnforcementOperations:
		*s = TokenPermissionTypeEnforcementOperations
	default:
		*s = TokenPermissionType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TokenPermissionType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TokenPermissionType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TokenStatusResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TokenStatusResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("referenceNumber")
		s.ReferenceNumber.Encode(e)
	}
	{
		e.FieldStart("authorIdentifier")
		s.AuthorIdentifier.Encode(e)
	}
	{
		e.FieldStart("contextIdentifier")
		s.ContextIdentifier.Encode(e)
	}
	{
		e.FieldStart("description")
		e.Str(s.Description)
	}
	{
		e.FieldStart("requestedPermissions")
		e.ArrStart()
		for _, elem := range s.RequestedPermissions {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("dateCreated")
		json.EncodeDateTime(e, s.DateCreated)
	}
	{
		if s.LastUseDate.Set {
			e.FieldStart("lastUseDate")
			s.LastUseDate.Encode(e, json.EncodeDateTime)
		}
	}
	{
		e.FieldStart("status")
		s.Status.Encode(e)
	}
	{
		if s.StatusDetails.Set {
			e.FieldStart("statusDetails")
			s.StatusDetails.Encode(e)
		}
	}
}

var jsonFieldsNameOfTokenStatusResponse = [9]string{
	0: "referenceNumber",
	1: "authorIdentifier",
	2: "contextIdentifier",
	3: "description",
	4: "requestedPermissions",
	5: "dateCreated",
	6: "lastUseDate",
	7: "status",
	8: "statusDetails",
}

// Decode decodes TokenStatusResponse from json.
func (s *TokenStatusResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TokenStatusResponse to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "referenceNumber":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ReferenceNumber.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"referenceNumber\"")
			}
		case "authorIdentifier":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.AuthorIdentifier.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"authorIdentifier\"")
			}
		case "contextIdentifier":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.ContextIdentifier.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"contextIdentifier\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "requestedPermissions":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				s.RequestedPermissions = make([]TokenPermissionType, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem TokenPermissionType
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.RequestedPermissions = append(s.RequestedPermissions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requestedPermissions\"")
			}
		case "dateCreated":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.DateCreated = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dateCreated\"")
			}
		case "lastUseDate":
			if err := func() error {
				s.LastUseDate.Reset()
				if err := s.LastUseDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastUseDate\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "statusDetails":
			if err := func() error {
				s.StatusDetails.Reset()
				if err := s.StatusDetails.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusDetails\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TokenStatusResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b10111111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTokenStatusResponse) {
					name = jsonFieldsNameOfTokenStatusResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TokenStatusResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TokenStatusResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpoPageResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpoPageResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("referenceNumber")
		s.ReferenceNumber.Encode(e)
	}
	{
		e.FieldStart("downloadUrl")
		json.EncodeURI(e, s.DownloadUrl)
	}
	{
		e.FieldStart("downloadUrlExpirationDate")
		json.EncodeDateTime(e, s.DownloadUrlExpirationDate)
	}
}

var jsonFieldsNameOfUpoPageResponse = [3]string{
	0: "referenceNumber",
	1: "downloadUrl",
	2: "downloadUrlExpirationDate",
}

// Decode decodes UpoPageResponse from json.
func (s *UpoPageResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpoPageResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "referenceNumber":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ReferenceNumber.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"referenceNumber\"")
			}
		case "downloadUrl":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.DownloadUrl = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"downloadUrl\"")
			}
		case "downloadUrlExpirationDate":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.DownloadUrlExpirationDate = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"downloadUrlExpirationDate\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpoPageResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpoPageResponse) {
					name = jsonFieldsNameOfUpoPageResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpoPageResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpoPageResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("pages")
		e.ArrStart()
		for _, elem := range s.Pages {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfUpoResponse = [1]string{
	0: "pages",
}

// Decode decodes UpoResponse from json.
func (s *UpoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "pages":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Pages = make([]UpoPageResponse, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem UpoPageResponse
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Pages = append(s.Pages, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pages\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpoResponse) {
					name = jsonFieldsNameOfUpoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}
