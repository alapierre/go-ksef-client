// Code generated by ogen, DO NOT EDIT.

package api

import (
	"context"
	"net/url"
	"strings"

	"github.com/go-faster/errors"
	"github.com/ogen-go/ogen/conv"
	ht "github.com/ogen-go/ogen/http"
	"github.com/ogen-go/ogen/ogenerrors"
	"github.com/ogen-go/ogen/uri"
)

func trimTrailingSlashes(u *url.URL) {
	u.Path = strings.TrimRight(u.Path, "/")
	u.RawPath = strings.TrimRight(u.RawPath, "/")
}

// Invoker invokes operations described by OpenAPI v3 specification.
type Invoker interface {
	// APIV2AuthChallengePost invokes POST /api/v2/auth/challenge operation.
	//
	// Generuje unikalny challenge wymagany w kolejnym kroku operacji uwierzytelnienia.
	//
	// POST /api/v2/auth/challenge
	APIV2AuthChallengePost(ctx context.Context) (APIV2AuthChallengePostRes, error)
	// APIV2AuthKsefTokenPost invokes POST /api/v2/auth/ksef-token operation.
	//
	// Rozpoczyna operację uwierzytelniania z wykorzystaniem wcześniej wygenerowanego tokena KSeF.
	// Token KSeF wraz z timestampem ze wcześniej wygenerowanego challenge'a (w formacie
	// ```token|timestamp```) powinien zostać zaszyfrowany dedykowanym do tego celu kluczem publicznym.
	// - Timestamp powinien zostać przekazany jako **liczba milisekund od 1 stycznia 1970 roku (Unix
	// timestamp)**.
	// - Algorytm szyfrowania: **RSA-OAEP (z użyciem SHA-256 jako funkcji skrótu)**.
	//
	// POST /api/v2/auth/ksef-token
	APIV2AuthKsefTokenPost(ctx context.Context, request OptInitTokenAuthenticationRequest) (APIV2AuthKsefTokenPostRes, error)
	// APIV2AuthReferenceNumberGet invokes GET /api/v2/auth/{referenceNumber} operation.
	//
	// Sprawdza bieżący status operacji uwierzytelniania dla podanego tokena.
	// Sposób uwierzytelnienia: `AuthenticationToken` otrzymany przy rozpoczęciu operacji
	// uwierzytelniania.
	//
	// GET /api/v2/auth/{referenceNumber}
	APIV2AuthReferenceNumberGet(ctx context.Context, params APIV2AuthReferenceNumberGetParams) (APIV2AuthReferenceNumberGetRes, error)
	// APIV2AuthSessionsCurrentDelete invokes DELETE /api/v2/auth/sessions/current operation.
	//
	// Unieważnia sesję powiązaną z tokenem użytym do wywołania tej operacji.
	// Unieważnienie sesji sprawia, że powiązany z nią refresh token przestaje działać i nie można
	// już za jego pomocą uzyskać kolejnych access tokenów.
	// **Aktywne access tokeny działają do czasu minięcia ich termin ważności.**
	// Sposób uwierzytelnienia: `RefreshToken` lub `AccessToken`.
	//
	// DELETE /api/v2/auth/sessions/current
	APIV2AuthSessionsCurrentDelete(ctx context.Context) (APIV2AuthSessionsCurrentDeleteRes, error)
	// APIV2AuthSessionsGet invokes GET /api/v2/auth/sessions operation.
	//
	// Zwraca listę aktywnych sesji uwierzytelnienia.
	// **Sortowanie:**
	// - startDate (Desc).
	//
	// GET /api/v2/auth/sessions
	APIV2AuthSessionsGet(ctx context.Context, params APIV2AuthSessionsGetParams) (APIV2AuthSessionsGetRes, error)
	// APIV2AuthSessionsReferenceNumberDelete invokes DELETE /api/v2/auth/sessions/{referenceNumber} operation.
	//
	// Unieważnia sesję o podanym numerze referencyjnym.
	// Unieważnienie sesji sprawia, że powiązany z nią refresh token przestaje działać i nie można
	// już za jego pomocą uzyskać kolejnych access tokenów.
	// **Aktywne access tokeny działają do czasu minięcia ich termin ważności.**.
	//
	// DELETE /api/v2/auth/sessions/{referenceNumber}
	APIV2AuthSessionsReferenceNumberDelete(ctx context.Context, params APIV2AuthSessionsReferenceNumberDeleteParams) (APIV2AuthSessionsReferenceNumberDeleteRes, error)
	// APIV2AuthTokenRedeemPost invokes POST /api/v2/auth/token/redeem operation.
	//
	// Pobiera parę tokenów (access token i refresh token) wygenerowanych w ramach pozytywnie
	// zakończonego procesu uwierzytelniania.
	// **Tokeny można pobrać tylko raz.**
	// Sposób uwierzytelnienia: `AuthenticationToken` otrzymany przy rozpoczęciu operacji
	// uwierzytelniania.
	//
	// POST /api/v2/auth/token/redeem
	APIV2AuthTokenRedeemPost(ctx context.Context) (APIV2AuthTokenRedeemPostRes, error)
	// APIV2AuthTokenRefreshPost invokes POST /api/v2/auth/token/refresh operation.
	//
	// Generuje nowy token dostępu na podstawie ważnego refresh tokena.
	// Sposób uwierzytelnienia: `RefreshToken`.
	//
	// POST /api/v2/auth/token/refresh
	APIV2AuthTokenRefreshPost(ctx context.Context) (APIV2AuthTokenRefreshPostRes, error)
	// APIV2AuthXadesSignaturePost invokes POST /api/v2/auth/xades-signature operation.
	//
	// Rozpoczyna operację uwierzytelniania za pomocą dokumentu XML podpisanego podpisem elektronicznym
	// XAdES.
	// > Więcej informacji:
	// > - [Przygotowanie dokumentu XML](https://github.com/CIRFMF/ksef-docs/blob/main/uwierzytelnianie.
	// md#1-przygotowanie-dokumentu-xml-authtokenrequest)
	// > - [Podpis dokumentu XML](https://github.com/CIRFMF/ksef-docs/blob/main/uwierzytelnianie.
	// md#2-podpisanie-dokumentu-xades)
	// > - [Schemat XSD](/docs/v2/schemas/authv2.xsd).
	//
	// POST /api/v2/auth/xades-signature
	APIV2AuthXadesSignaturePost(ctx context.Context, request APIV2AuthXadesSignaturePostReq, params APIV2AuthXadesSignaturePostParams) (APIV2AuthXadesSignaturePostRes, error)
	// APIV2CertificatesCertificateSerialNumberRevokePost invokes POST /api/v2/certificates/{certificateSerialNumber}/revoke operation.
	//
	// Unieważnia certyfikat o podanym numerze seryjnym.
	//
	// POST /api/v2/certificates/{certificateSerialNumber}/revoke
	APIV2CertificatesCertificateSerialNumberRevokePost(ctx context.Context, request OptRevokeCertificateRequest, params APIV2CertificatesCertificateSerialNumberRevokePostParams) (APIV2CertificatesCertificateSerialNumberRevokePostRes, error)
	// APIV2CertificatesEnrollmentsDataGet invokes GET /api/v2/certificates/enrollments/data operation.
	//
	// Zwraca dane wymagane do przygotowania wniosku certyfikacyjnego PKCS#10.
	// Dane te są zwracane na podstawie certyfikatu użytego w procesie uwierzytelnienia i identyfikują
	// podmiot, który składa wniosek o certyfikat.
	// > Więcej informacji:
	// > - [Pobranie danych do wniosku certyfikacyjnego](https://github.
	// com/CIRFMF/ksef-docs/blob/main/certyfikaty-KSeF.md#2-pobranie-danych-do-wniosku-certyfikacyjnego)
	// > - [Przygotowanie wniosku](https://github.com/CIRFMF/ksef-docs/blob/main/certyfikaty-KSeF.
	// md#3-przygotowanie-csr-certificate-signing-request).
	//
	// GET /api/v2/certificates/enrollments/data
	APIV2CertificatesEnrollmentsDataGet(ctx context.Context) (APIV2CertificatesEnrollmentsDataGetRes, error)
	// APIV2CertificatesEnrollmentsPost invokes POST /api/v2/certificates/enrollments operation.
	//
	// Przyjmuje wniosek certyfikacyjny i rozpoczyna jego przetwarzanie.
	// Dozwolone typy kluczy prywatnych:
	// - RSA (OID: 1.2.840.113549.1.1.1), długość klucza równa 2048 bitów,
	// - EC (klucze oparte na krzywych eliptycznych, OID: 1.2.840.10045.2.1), krzywa NIST P-256
	// (secp256r1)
	// Zalecane jest stosowanie kluczy EC.
	// Dozwolone algorytmy podpisu:
	// - RSA PKCS#1 v1.5,
	// - RSA PSS,
	// - ECDSA (format podpisu zgodny z RFC 3279)
	// Dozwolone funkcje skrótu użyte do podpisu CSR:
	// - SHA1,
	// - SHA256,
	// - SHA384,
	// - SHA512
	// > Więcej informacji:
	// > - [Wysłanie wniosku certyfikacyjnego](https://github.
	// com/CIRFMF/ksef-docs/blob/main/certyfikaty-KSeF.md#4-wys%C5%82anie-wniosku-certyfikacyjnego).
	//
	// POST /api/v2/certificates/enrollments
	APIV2CertificatesEnrollmentsPost(ctx context.Context, request OptEnrollCertificateRequest) (APIV2CertificatesEnrollmentsPostRes, error)
	// APIV2CertificatesEnrollmentsReferenceNumberGet invokes GET /api/v2/certificates/enrollments/{referenceNumber} operation.
	//
	// Zwraca informacje o statusie wniosku certyfikacyjnego.
	//
	// GET /api/v2/certificates/enrollments/{referenceNumber}
	APIV2CertificatesEnrollmentsReferenceNumberGet(ctx context.Context, params APIV2CertificatesEnrollmentsReferenceNumberGetParams) (APIV2CertificatesEnrollmentsReferenceNumberGetRes, error)
	// APIV2CertificatesLimitsGet invokes GET /api/v2/certificates/limits operation.
	//
	// Zwraca informacje o limitach certyfikatów oraz informacje czy użytkownik może zawnioskować o
	// certyfikat KSeF.
	//
	// GET /api/v2/certificates/limits
	APIV2CertificatesLimitsGet(ctx context.Context) (APIV2CertificatesLimitsGetRes, error)
	// APIV2CertificatesQueryPost invokes POST /api/v2/certificates/query operation.
	//
	// Zwraca listę certyfikatów spełniających podane kryteria wyszukiwania.
	// W przypadku braku podania kryteriów wyszukiwania zwrócona zostanie nieprzefiltrowana lista.
	// **Sortowanie:**
	// - requestDate (Desc).
	//
	// POST /api/v2/certificates/query
	APIV2CertificatesQueryPost(ctx context.Context, request OptQueryCertificatesRequest, params APIV2CertificatesQueryPostParams) (APIV2CertificatesQueryPostRes, error)
	// APIV2CertificatesRetrievePost invokes POST /api/v2/certificates/retrieve operation.
	//
	// Zwraca certyfikaty o podanych numerach seryjnych w formacie DER zakodowanym w Base64.
	//
	// POST /api/v2/certificates/retrieve
	APIV2CertificatesRetrievePost(ctx context.Context, request OptRetrieveCertificatesRequest) (APIV2CertificatesRetrievePostRes, error)
	// APIV2InvoicesExportsPost invokes POST /api/v2/invoices/exports operation.
	//
	// Rozpoczyna asynchroniczny proces wyszukiwania faktur w systemie KSeF na podstawie przekazanych
	// filtrów oraz przygotowania ich w formie zaszyfrowanej paczki.
	// Wymagane jest przekazanie informacji o szyfrowaniu w polu <b>Encryption</b>, które służą do
	// zabezpieczenia przygotowanej paczki z fakturami.
	// Maksymalnie można uruchomić 10 równoczesnych eksportów w zalogowanym kontekście.
	// System pobiera faktury rosnąco według daty określonej w filtrze (Invoicing, Issue,
	// PermanentStorage) i dodaje je do paczki aż do osiągnięcia jednego z poniższych limitów:
	// * Limit liczby faktur: 10 000 sztuk
	// * Limit rozmiaru danych(skompresowanych): 1GB
	// Paczka eksportu zawiera dodatkowy plik z metadanymi faktur w formacie JSON (`_metadata.json`).
	// Zawartość pliku to
	// obiekt z tablicą <b>invoices</b>, gdzie każdy element jest obiektem typu <b>InvoiceMetadata</b>
	// (taki jak zwracany przez endpoint `POST /invoices/query/metadata`).
	// <b>Plik z metadanymi(_metadata.json) nie jest wliczany do limitów algorytmu budowania paczki</b>.
	// `Do realizacji pobierania przyrostowego należy stosować filtrowanie po dacie PermanentStorage`.
	// **Sortowanie:**
	// - permanentStorageDate | invoicingDate | issueDate (Asc) - pole wybierane na podstawie filtrów
	// **Wymagane uprawnienia**: `InvoiceRead`.
	//
	// POST /api/v2/invoices/exports
	APIV2InvoicesExportsPost(ctx context.Context, request OptInvoiceExportRequest) (APIV2InvoicesExportsPostRes, error)
	// APIV2InvoicesExportsReferenceNumberGet invokes GET /api/v2/invoices/exports/{referenceNumber} operation.
	//
	// Paczka faktur jest dzielona na części o maksymalnym rozmiarze 50 MB. Każda część jest
	// zaszyfrowana algorytmem AES-256-CBC z dopełnieniem PKCS#7, przy użyciu klucza symetrycznego
	// przekazanego podczas inicjowania eksportu.
	// W przypadku ucięcia wyniku eksportu z powodu przekroczenia limitów, zwracana jest flaga
	// <b>IsTruncated = true</b> oraz odpowiednia data, którą należy wykorzystać do wykonania
	// kolejnego eksportu, aż do momentu, gdy flaga <b>IsTruncated = false</b>.
	// **Sortowanie:**
	// - permanentStorageDate | invoicingDate | issueDate (Asc) - pole wybierane na podstawie filtrów
	// **Wymagane uprawnienia**: `InvoiceRead`.
	//
	// GET /api/v2/invoices/exports/{referenceNumber}
	APIV2InvoicesExportsReferenceNumberGet(ctx context.Context, params APIV2InvoicesExportsReferenceNumberGetParams) (APIV2InvoicesExportsReferenceNumberGetRes, error)
	// APIV2InvoicesKsefKsefNumberGet invokes GET /api/v2/invoices/ksef/{ksefNumber} operation.
	//
	// Zwraca fakturę o podanym numerze KSeF.
	// **Wymagane uprawnienia**: `InvoiceRead`.
	//
	// GET /api/v2/invoices/ksef/{ksefNumber}
	APIV2InvoicesKsefKsefNumberGet(ctx context.Context, params APIV2InvoicesKsefKsefNumberGetParams) (APIV2InvoicesKsefKsefNumberGetRes, error)
	// APIV2InvoicesQueryMetadataPost invokes POST /api/v2/invoices/query/metadata operation.
	//
	// Zwraca metadane faktur spełniających filtry.
	// Limit techniczny: ≤ 10 000 rekordów na zestaw filtrów, po jego osiągnięciu <b>isTruncated =
	// true</b> i należy ponownie ustawić <b>dateRange</b>, używając ostatniej daty z wyników (tj.
	// ustawić from/to - w zależności od kierunku sortowania, od daty ostatniego zwróconego rekordu)
	// oraz wyzerować <b>pageOffset</b>.
	// `Do scenariusza przyrostowego należy używać daty PermanentStorage oraz kolejność sortowania
	// Asc`.
	// <b>Scenariusz pobierania przyrostowego (skrót):</b>
	// * Gdy <b>hasMore = false</b>, należy zakończyć,
	// * Gdy <b>hasMore = true</b> i <b>isTruncated = false</b>, należy zwiększyć <b>pageOffset</b>,
	// * Gdy <b>hasMore = true</b> i <b>isTruncated = true</b>, należy zawęzić <b>dateRange</b>
	// (ustawić from od daty ostatniego rekordu), wyzerować <b>pageOffset</b> i kontynuować
	// **Sortowanie:**
	// - permanentStorageDate | invoicingDate | issueDate (Asc | Desc) - pole wybierane na podstawie
	// filtrów
	// **Wymagane uprawnienia**: `InvoiceRead`.
	//
	// POST /api/v2/invoices/query/metadata
	APIV2InvoicesQueryMetadataPost(ctx context.Context, request OptInvoiceQueryFilters, params APIV2InvoicesQueryMetadataPostParams) (APIV2InvoicesQueryMetadataPostRes, error)
	// APIV2LimitsContextGet invokes GET /api/v2/limits/context operation.
	//
	// Zwraca wartości aktualnie obowiązujących limitów dla bieżącego kontekstu.
	//
	// GET /api/v2/limits/context
	APIV2LimitsContextGet(ctx context.Context) (APIV2LimitsContextGetRes, error)
	// APIV2LimitsSubjectGet invokes GET /api/v2/limits/subject operation.
	//
	// Zwraca wartoście aktualnie obowiązujących limitów dla bieżącego podmiotu.
	//
	// GET /api/v2/limits/subject
	APIV2LimitsSubjectGet(ctx context.Context) (APIV2LimitsSubjectGetRes, error)
	// APIV2PeppolQueryGet invokes GET /api/v2/peppol/query operation.
	//
	// Zwraca listę dostawców usług Peppol zarejestrowanych w systemie.
	// **Sortowanie:**
	// - dateCreated (Desc).
	//
	// GET /api/v2/peppol/query
	APIV2PeppolQueryGet(ctx context.Context, params APIV2PeppolQueryGetParams) (APIV2PeppolQueryGetRes, error)
	// APIV2PermissionsAttachmentsStatusGet invokes GET /api/v2/permissions/attachments/status operation.
	//
	// Sprawdzenie czy obecny kontekst posiada zgodę na wystawianie faktur z załącznikiem.
	// **Wymagane uprawnienia**: `CredentialsManage`, `CredentialsRead`.
	//
	// GET /api/v2/permissions/attachments/status
	APIV2PermissionsAttachmentsStatusGet(ctx context.Context) (APIV2PermissionsAttachmentsStatusGetRes, error)
	// APIV2PermissionsAuthorizationsGrantsPermissionIdDelete invokes DELETE /api/v2/permissions/authorizations/grants/{permissionId} operation.
	//
	// Metoda pozwala na odebranie uprawnienia podmiotowego o wskazanym identyfikatorze.
	// Wymagane jest wcześniejsze odczytanie uprawnień w celu uzyskania
	// identyfikatora uprawnienia, które ma zostać odebrane.
	// > Więcej informacji:
	// > - [Odbieranie uprawnień](https://github.com/CIRFMF/ksef-docs/blob/main/uprawnienia.
	// md#odebranie-uprawnie%C5%84-podmiotowych)
	// **Wymagane uprawnienia**: `CredentialsManage`.
	//
	// DELETE /api/v2/permissions/authorizations/grants/{permissionId}
	APIV2PermissionsAuthorizationsGrantsPermissionIdDelete(ctx context.Context, params APIV2PermissionsAuthorizationsGrantsPermissionIdDeleteParams) (APIV2PermissionsAuthorizationsGrantsPermissionIdDeleteRes, error)
	// APIV2PermissionsAuthorizationsGrantsPost invokes POST /api/v2/permissions/authorizations/grants operation.
	//
	// Metoda pozwala na nadanie jednego z uprawnień podmiotowych do obsługi podmiotu kontekstu
	// podmiotowi wskazanemu w żądaniu.
	// > Więcej informacji:
	// > - [Nadawanie uprawnień](https://github.com/CIRFMF/ksef-docs/blob/main/uprawnienia.
	// md#nadanie-uprawnie%C5%84-podmiotowych)
	// **Wymagane uprawnienia**: `CredentialsManage`.
	//
	// POST /api/v2/permissions/authorizations/grants
	APIV2PermissionsAuthorizationsGrantsPost(ctx context.Context, request OptEntityAuthorizationPermissionsGrantRequest) (APIV2PermissionsAuthorizationsGrantsPostRes, error)
	// APIV2PermissionsCommonGrantsPermissionIdDelete invokes DELETE /api/v2/permissions/common/grants/{permissionId} operation.
	//
	// Metoda pozwala na odebranie uprawnienia o wskazanym identyfikatorze.
	// Wymagane jest wcześniejsze odczytanie uprawnień w celu uzyskania
	// identyfikatora uprawnienia, które ma zostać odebrane.
	// > Więcej informacji:
	// > - [Odbieranie uprawnień](https://github.com/CIRFMF/ksef-docs/blob/main/uprawnienia.
	// md#odebranie-uprawnie%C5%84)
	// **Wymagane uprawnienia**: `CredentialsManage`, `VatUeManage`, `SubunitManage`.
	//
	// DELETE /api/v2/permissions/common/grants/{permissionId}
	APIV2PermissionsCommonGrantsPermissionIdDelete(ctx context.Context, params APIV2PermissionsCommonGrantsPermissionIdDeleteParams) (APIV2PermissionsCommonGrantsPermissionIdDeleteRes, error)
	// APIV2PermissionsEntitiesGrantsPost invokes POST /api/v2/permissions/entities/grants operation.
	//
	// Metoda pozwala na nadanie podmiotowi wskazanemu w żądaniu uprawnień do obsługi faktur podmiotu
	// kontekstu.
	// W żądaniu określane są nadawane uprawnienia ze zbioru:
	// - **InvoiceWrite** – wystawianie faktur
	// - **InvoiceRead** – przeglądanie faktur
	// Metoda pozwala na wybór dowolnej kombinacji powyższych uprawnień.
	// Dla każdego uprawnienia może być ustawiona flaga **canDelegate**, mówiąca o możliwości jego
	// dalszego przekazywania poprzez nadawanie w sposób pośredni.
	// > Więcej informacji:
	// > - [Nadawanie uprawnień](https://github.com/CIRFMF/ksef-docs/blob/main/uprawnienia.
	// md#nadanie-podmiotom-uprawnie%C5%84-do-obs%C5%82ugi-faktur)
	// **Wymagane uprawnienia**: `CredentialsManage`.
	//
	// POST /api/v2/permissions/entities/grants
	APIV2PermissionsEntitiesGrantsPost(ctx context.Context, request OptEntityPermissionsGrantRequest) (APIV2PermissionsEntitiesGrantsPostRes, error)
	// APIV2PermissionsEuEntitiesAdministrationGrantsPost invokes POST /api/v2/permissions/eu-entities/administration/grants operation.
	//
	// Metoda pozwala na nadanie wskazanemu w żądaniu podmiotowi lub osobie fizycznej uprawnień
	// administratora w kontekście złożonym z identyfikatora NIP podmiotu kontekstu bieżącego oraz
	// numeru VAT UE podmiotu unijnego wskazanego w żądaniu.
	// Wraz z utworzeniem administratora podmiotu unijnego tworzony jest kontekst złożony składający
	// się z numeru NIP podmiotu kontekstu logowania oraz wskazanego numeru identyfikacyjnego VAT UE
	// podmiotu unijnego.
	// W żądaniu podaje się również nazwę i adres podmiotu unijnego.
	// Jedynym sposobem identyfikacji uprawnianego jest odcisk palca certyfikatu kwalifikowanego:
	// - certyfikat podpisu elektronicznego dla osób fizycznych
	// - certyfikat pieczęci elektronicznej dla podmiotów
	// Uprawnienia administratora podmiotu unijnego obejmują:
	// - **VatEuManage** – zarządzanie uprawnieniami w ramach podmiotu unijnego
	// - **InvoiceWrite** – wystawianie faktur
	// - **InvoiceRead** – przeglądanie faktur
	// - **Introspection** – przeglądanie historii sesji
	// Metoda automatycznie nadaje wszystkie powyższe uprawnienia, bez konieczności ich wskazywania w
	// żądaniu.
	// > Więcej informacji:
	// > - [Nadawanie uprawnień](https://github.com/CIRFMF/ksef-docs/blob/main/uprawnienia.
	// md#nadanie-uprawnie%C5%84-administratora-podmiotu-unijnego)
	// **Wymagane uprawnienia**: `CredentialsManage`.
	//
	// POST /api/v2/permissions/eu-entities/administration/grants
	APIV2PermissionsEuEntitiesAdministrationGrantsPost(ctx context.Context, request OptEuEntityAdministrationPermissionsGrantRequest) (APIV2PermissionsEuEntitiesAdministrationGrantsPostRes, error)
	// APIV2PermissionsEuEntitiesGrantsPost invokes POST /api/v2/permissions/eu-entities/grants operation.
	//
	// Metoda pozwala na nadanie wskazanemu w żądaniu podmiotowi lub osobie fizycznej uprawnień do
	// wystawiania i/lub przeglądania faktur w kontekście złożonym kontekstu bieżącego.
	// Jedynym sposobem identyfikacji uprawnianego jest odcisk palca certyfikatu kwalifikowanego:
	// - certyfikat podpisu elektronicznego dla osób fizycznych
	// - certyfikat pieczęci elektronicznej dla podmiotów
	// W żądaniu określane są nadawane uprawnienia ze zbioru:
	// - **InvoiceWrite** – wystawianie faktur
	// - **InvoiceRead** – przeglądanie faktur
	// Metoda pozwala na wybór dowolnej kombinacji powyższych uprawnień.
	// > Więcej informacji:
	// > - [Nadawanie uprawnień](https://github.com/CIRFMF/ksef-docs/blob/main/uprawnienia.
	// md#nadanie-uprawnie%C5%84-reprezentanta-podmiotu-unijnego)
	// **Wymagane uprawnienia**: `VatUeManage`.
	//
	// POST /api/v2/permissions/eu-entities/grants
	APIV2PermissionsEuEntitiesGrantsPost(ctx context.Context, request OptEuEntityPermissionsGrantRequest) (APIV2PermissionsEuEntitiesGrantsPostRes, error)
	// APIV2PermissionsIndirectGrantsPost invokes POST /api/v2/permissions/indirect/grants operation.
	//
	// Metoda pozwala na nadanie w sposób pośredni osobie wskazanej w żądaniu uprawnień do obsługi
	// faktur innego podmiotu – klienta.
	// Może to być jedna z możliwości:
	// - nadanie uprawnień generalnych – do obsługi wszystkich klientów
	// - nadanie uprawnień selektywnych – do obsługi wskazanego klienta
	// Uprawnienie selektywne może być nadane wyłącznie wtedy, gdy klient nadał wcześniej
	// podmiotowi bieżącego kontekstu dowolne uprawnienie z prawem do jego dalszego przekazywania
	// (patrz [POST /api/v2/permissions/entities/grants](/docs/v2/index.
	// html#tag/Nadawanie-uprawnien/paths/~1api~1v2~1permissions~1entities~1grants/post)).
	// W żądaniu określane są nadawane uprawnienia ze zbioru:
	// - **InvoiceWrite** – wystawianie faktur
	// - **InvoiceRead** – przeglądanie faktur
	// Metoda pozwala na wybór dowolnej kombinacji powyższych uprawnień.
	// > Więcej informacji:
	// > - [Nadawanie uprawnień](https://github.com/CIRFMF/ksef-docs/blob/main/uprawnienia.
	// md#nadanie-uprawnie%C5%84-w-spos%C3%B3b-po%C5%9Bredni)
	// **Wymagane uprawnienia**: `CredentialsManage`.
	//
	// POST /api/v2/permissions/indirect/grants
	APIV2PermissionsIndirectGrantsPost(ctx context.Context, request OptIndirectPermissionsGrantRequest) (APIV2PermissionsIndirectGrantsPostRes, error)
	// APIV2PermissionsOperationsReferenceNumberGet invokes GET /api/v2/permissions/operations/{referenceNumber} operation.
	//
	// Zwraca status operacji asynchronicznej związanej z nadaniem lub odebraniem uprawnień.
	//
	// GET /api/v2/permissions/operations/{referenceNumber}
	APIV2PermissionsOperationsReferenceNumberGet(ctx context.Context, params APIV2PermissionsOperationsReferenceNumberGetParams) (APIV2PermissionsOperationsReferenceNumberGetRes, error)
	// APIV2PermissionsPersonsGrantsPost invokes POST /api/v2/permissions/persons/grants operation.
	//
	// Metoda pozwala na nadanie osobie wskazanej w żądaniu uprawnień do pracy w KSeF
	// w kontekście bieżącym.
	// W żądaniu określane są nadawane uprawnienia ze zbioru:
	// - **InvoiceWrite** – wystawianie faktur,
	// - **InvoiceRead** – przeglądanie faktur,
	// - **CredentialsManage** – zarządzanie uprawnieniami,
	// - **CredentialsRead** – przeglądanie uprawnień,
	// - **Introspection** – przeglądanie historii sesji i generowanie UPO,
	// - **SubunitManage** – zarządzanie jednostkami podrzędnymi,
	// - **EnforcementOperations** – wykonywanie operacji egzekucyjnych.
	// Metoda pozwala na wybór dowolnej kombinacji powyższych uprawnień.
	// Uprawnienie **EnforcementOperations** może być nadane wyłącznie wtedy,
	// gdy podmiot kontekstu ma rolę **EnforcementAuthority** (organ egzekucyjny)
	// lub **CourtBailiff** (komornik sądowy).
	// > Więcej informacji:
	// > - [Nadawanie uprawnień](https://github.com/CIRFMF/ksef-docs/blob/main/uprawnienia.
	// md#nadawanie-uprawnie%C5%84-osobom-fizycznym-do-pracy-w-ksef)
	// **Wymagane uprawnienia**: `CredentialsManage`.
	//
	// POST /api/v2/permissions/persons/grants
	APIV2PermissionsPersonsGrantsPost(ctx context.Context, request OptPersonPermissionsGrantRequest) (APIV2PermissionsPersonsGrantsPostRes, error)
	// APIV2PermissionsQueryAuthorizationsGrantsPost invokes POST /api/v2/permissions/query/authorizations/grants operation.
	//
	// Metoda pozwala na odczytanie uprawnień podmiotowych:
	// - otrzymanych przez podmiot bieżącego kontekstu
	// - nadanych przez podmiot bieżącego kontekstu
	// Wybór listy nadanych lub otrzymanych uprawnień odbywa się przy użyciu parametru **queryType**.
	// Uprawnienia zwracane przez operację obejmują:
	// - **SelfInvoicing** – wystawianie faktur w trybie samofakturowania
	// - **TaxRepresentative** – wykonywanie operacji przedstawiciela podatkowego
	// - **RRInvoicing** – wystawianie faktur VAT RR
	// - **PefInvoicing** – wystawianie faktur PEF
	// Odpowiedź może być filtrowana na podstawie następujących parametrów:
	// - **authorizingIdentifier** – identyfikator podmiotu uprawniającego (stosowane przy queryType =
	// Received)
	// - **authorizedIdentifier** – identyfikator podmiotu uprawnionego (stosowane przy queryType =
	// Granted)
	// - **permissionTypes** – lista rodzajów wyszukiwanych uprawnień
	// #### Stronicowanie wyników
	// Zapytanie zwraca **jedną stronę wyników** o numerze i rozmiarze podanym w ścieżce.
	// - Przy pierwszym wywołaniu należy ustawić parametr `pageOffset = 0`.
	// - Jeżeli dostępna jest kolejna strona wyników, w odpowiedzi pojawi się flaga **`hasMore`**.
	// - W takim przypadku można wywołać zapytanie ponownie z kolejnym numerem strony.
	// > Więcej informacji:
	// > - [Pobieranie listy uprawnień](https://github.com/CIRFMF/ksef-docs/blob/main/uprawnienia.
	// md#pobranie-listy-uprawnie%C5%84-podmiotowych-do-obs%C5%82ugi-faktur)
	// **Sortowanie:**
	// - startDate (Desc)
	// **Wymagane uprawnienia**: `CredentialsManage`, `CredentialsRead`.
	//
	// POST /api/v2/permissions/query/authorizations/grants
	APIV2PermissionsQueryAuthorizationsGrantsPost(ctx context.Context, request OptEntityAuthorizationPermissionsQueryRequest, params APIV2PermissionsQueryAuthorizationsGrantsPostParams) (APIV2PermissionsQueryAuthorizationsGrantsPostRes, error)
	// APIV2PermissionsQueryEntitiesRolesGet invokes GET /api/v2/permissions/query/entities/roles operation.
	//
	// Metoda pozwala na **odczytanie listy ról podmiotu bieżącego kontekstu logowania**.
	// #### Role podmiotów zwracane przez operację:
	// - **CourtBailiff** – komornik sądowy
	// - **EnforcementAuthority** – organ egzekucyjny
	// - **LocalGovernmentUnit** – nadrzędna JST
	// - **LocalGovernmentSubUnit** – podrzędne JST
	// - **VatGroupUnit** – grupa VAT
	// - **VatGroupSubUnit** – członek grupy VAT
	// #### Stronicowanie wyników
	// Zapytanie zwraca **jedną stronę wyników** o numerze i rozmiarze podanym w ścieżce.
	// - Przy pierwszym wywołaniu należy ustawić parametr `pageOffset = 0`.
	// - Jeżeli dostępna jest kolejna strona wyników, w odpowiedzi pojawi się flaga **`hasMore`**.
	// - W takim przypadku można wywołać zapytanie ponownie z kolejnym numerem strony.
	// > Więcej informacji:
	// > - [Pobieranie listy ról](https://github.com/CIRFMF/ksef-docs/blob/main/uprawnienia.
	// md#pobranie-listy-r%C3%B3l-podmiotu)
	// **Sortowanie:**
	// - startDate (Desc)
	// **Wymagane uprawnienia**: `CredentialsManage`, `CredentialsRead`.
	//
	// GET /api/v2/permissions/query/entities/roles
	APIV2PermissionsQueryEntitiesRolesGet(ctx context.Context, params APIV2PermissionsQueryEntitiesRolesGetParams) (APIV2PermissionsQueryEntitiesRolesGetRes, error)
	// APIV2PermissionsQueryEuEntitiesGrantsPost invokes POST /api/v2/permissions/query/eu-entities/grants operation.
	//
	// Metoda pozwala na odczytanie uprawnień administratorów lub reprezentantów podmiotów unijnych:
	// - Jeżeli kontekstem logowania jest NIP, możliwe jest odczytanie uprawnień administratorów
	// podmiotów unijnych powiązanych z podmiotem bieżącego kontekstu, czyli takich, dla których
	// pierwszy człon kontekstu złożonego jest równy NIP-owi kontekstu logowania.
	// - Jeżeli kontekst logowania jest złożony (NIP-VAT UE), możliwe jest pobranie wszystkich
	// uprawnień administratorów i reprezentantów podmiotu w bieżącym kontekście złożonym.
	// Uprawnienia zwracane przez operację obejmują:
	// - **VatUeManage** – zarządzanie uprawnieniami w ramach podmiotu unijnego
	// - **InvoiceWrite** – wystawianie faktur
	// - **InvoiceRead** – przeglądanie faktur
	// - **Introspection** – przeglądanie historii sesji
	// Odpowiedź może być filtrowana na podstawie następujących parametrów:
	// - **vatUeIdentifier** – identyfikator podmiotu unijnego
	// - **authorizedFingerprintIdentifier** – odcisk palca certyfikatu uprawnionej osoby lub podmiotu
	// - **permissionTypes** – lista rodzajów wyszukiwanych uprawnień
	// #### Stronicowanie wyników
	// Zapytanie zwraca **jedną stronę wyników** o numerze i rozmiarze podanym w ścieżce.
	// - Przy pierwszym wywołaniu należy ustawić parametr `pageOffset = 0`.
	// - Jeżeli dostępna jest kolejna strona wyników, w odpowiedzi pojawi się flaga **`hasMore`**.
	// - W takim przypadku można wywołać zapytanie ponownie z kolejnym numerem strony.
	// > Więcej informacji:
	// > - [Pobieranie listy uprawnień](https://github.com/CIRFMF/ksef-docs/blob/main/uprawnienia.
	// md#pobranie-listy-uprawnie%C5%84-administrator%C3%B3w-lub-reprezentant%C3%B3w-podmiot%C3%B3w-unijnych-uprawnionych-do-samofakturowania)
	// **Sortowanie:**
	// - startDate (Desc)
	// **Wymagane uprawnienia**: `CredentialsManage`, `CredentialsRead`, `VatUeManage`.
	//
	// POST /api/v2/permissions/query/eu-entities/grants
	APIV2PermissionsQueryEuEntitiesGrantsPost(ctx context.Context, request OptEuEntityPermissionsQueryRequest, params APIV2PermissionsQueryEuEntitiesGrantsPostParams) (APIV2PermissionsQueryEuEntitiesGrantsPostRes, error)
	// APIV2PermissionsQueryPersonalGrantsPost invokes POST /api/v2/permissions/query/personal/grants operation.
	//
	// Metoda pozwala na odczytanie własnych uprawnień uwierzytelnionego klienta API w bieżącym
	// kontekście logowania.
	// W odpowiedzi przekazywane są następujące uprawnienia:
	// - nadane w sposób bezpośredni w bieżącym kontekście
	// - nadane przez podmiot nadrzędny
	// - nadane w sposób pośredni, jeżeli podmiot kontekstu logowania jest w uprawnieniu pośrednikiem
	// lub podmiotem docelowym
	// - nadane podmiotowi do obsługi faktur przez inny podmiot, jeśli podmiot uwierzytelniony ma w
	// bieżącym kontekście uprawnienia właścicielskie
	// Uprawnienia zwracane przez operację obejmują:
	// - **CredentialsManage** – zarządzanie uprawnieniami
	// - **CredentialsRead** – przeglądanie uprawnień
	// - **InvoiceWrite** – wystawianie faktur
	// - **InvoiceRead** – przeglądanie faktur
	// - **Introspection** – przeglądanie historii sesji
	// - **SubunitManage** – zarządzanie podmiotami podrzędnymi
	// - **EnforcementOperations** – wykonywanie operacji egzekucyjnych
	// - **VatEuManage** – zarządzanie uprawnieniami w ramach podmiotu unijnego
	// Odpowiedź może być filtrowana na podstawie następujących parametrów:
	// - **contextIdentifier** – identyfikator podmiotu, który nadał uprawnienie do obsługi faktur
	// - **targetIdentifier** – identyfikator podmiotu docelowego dla uprawnień nadanych pośrednio
	// - **permissionTypes** – lista rodzajów wyszukiwanych uprawnień
	// - **permissionState** – status uprawnienia
	// #### Stronicowanie wyników
	// Zapytanie zwraca **jedną stronę wyników** o numerze i rozmiarze podanym w ścieżce.
	// - Przy pierwszym wywołaniu należy ustawić parametr `pageOffset = 0`.
	// - Jeżeli dostępna jest kolejna strona wyników, w odpowiedzi pojawi się flaga **`hasMore`**.
	// - W takim przypadku można wywołać zapytanie ponownie z kolejnym numerem strony.
	// > Więcej informacji:
	// > - [Pobieranie listy uprawnień](https://github.com/CIRFMF/ksef-docs/blob/main/uprawnienia.
	// md#pobranie-listy-w%C5%82asnych-uprawnie%C5%84)
	// **Sortowanie:**
	// - startDate (Desc).
	//
	// POST /api/v2/permissions/query/personal/grants
	APIV2PermissionsQueryPersonalGrantsPost(ctx context.Context, request OptPersonalPermissionsQueryRequest, params APIV2PermissionsQueryPersonalGrantsPostParams) (APIV2PermissionsQueryPersonalGrantsPostRes, error)
	// APIV2PermissionsQueryPersonsGrantsPost invokes POST /api/v2/permissions/query/persons/grants operation.
	//
	// Metoda pozwala na odczytanie uprawnień nadanych osobie fizycznej lub podmiotowi.
	// Lista pobranych uprawnień może być dwóch rodzajów:
	// - Lista wszystkich uprawnień obowiązujących w bieżącym kontekście logowania (używana, gdy
	// administrator chce przejrzeć uprawnienia wszystkich użytkowników w bieżącym kontekście)
	// - Lista wszystkich uprawnień nadanych w bieżącym kontekście przez uwierzytelnionego klienta
	// API (używana, gdy administrator chce przejrzeć listę nadanych przez siebie uprawnień w
	// bieżącym kontekście)
	// Dla pierwszej listy (obowiązujących uprawnień) w odpowiedzi przekazywane są:
	// - osoby i podmioty mogące pracować w bieżącym kontekście z wyjątkiem osób uprawnionych w
	// sposób pośredni
	// - osoby uprawnione w sposób pośredni przez podmiot bieżącego kontekstu
	// Dla drugiej listy (nadanych uprawnień) w odpowiedzi przekazywane są:
	// - uprawnienia nadane w sposób bezpośredni do pracy w bieżącym kontekście lub w kontekście
	// jednostek podrzędnych
	// - uprawnienia nadane w sposób pośredni do obsługi klientów podmiotu bieżącego kontekstu
	// Uprawnienia zwracane przez operację obejmują:
	// - **CredentialsManage** – zarządzanie uprawnieniami
	// - **CredentialsRead** – przeglądanie uprawnień
	// - **InvoiceWrite** – wystawianie faktur
	// - **InvoiceRead** – przeglądanie faktur
	// - **Introspection** – przeglądanie historii sesji
	// - **SubunitManage** – zarządzanie podmiotami podrzędnymi
	// - **EnforcementOperations** – wykonywanie operacji egzekucyjnych
	// Odpowiedź może być filtrowana na podstawie parametrów:
	// - **authorIdentifier** – identyfikator osoby, która nadała uprawnienie
	// - **authorizedIdentifier** – identyfikator osoby lub podmiotu uprawnionego
	// - **targetIdentifier** – identyfikator podmiotu docelowego dla uprawnień nadanych pośrednio
	// - **permissionTypes** – lista rodzajów wyszukiwanych uprawnień
	// - **permissionState** – status uprawnienia
	// - **queryType** – typ zapytania określający, która z dwóch list ma zostać zwrócona
	// #### Stronicowanie wyników
	// Zapytanie zwraca **jedną stronę wyników** o numerze i rozmiarze podanym w ścieżce.
	// - Przy pierwszym wywołaniu należy ustawić parametr `pageOffset = 0`.
	// - Jeżeli dostępna jest kolejna strona wyników, w odpowiedzi pojawi się flaga **`hasMore`**.
	// - W takim przypadku można wywołać zapytanie ponownie z kolejnym numerem strony.
	// > Więcej informacji:
	// > - [Pobieranie listy uprawnień](https://github.com/CIRFMF/ksef-docs/blob/main/uprawnienia.
	// md#pobranie-listy-uprawnie%C5%84-do-pracy-w-ksef-nadanych-osobom-fizycznym-lub-podmiotom)
	// **Sortowanie:**
	// - startDate (Desc)
	// **Wymagane uprawnienia**: `CredentialsManage`, `CredentialsRead`, `SubunitManage`.
	//
	// POST /api/v2/permissions/query/persons/grants
	APIV2PermissionsQueryPersonsGrantsPost(ctx context.Context, request OptPersonPermissionsQueryRequest, params APIV2PermissionsQueryPersonsGrantsPostParams) (APIV2PermissionsQueryPersonsGrantsPostRes, error)
	// APIV2PermissionsQuerySubordinateEntitiesRolesPost invokes POST /api/v2/permissions/query/subordinate-entities/roles operation.
	//
	// Metoda pozwala na odczytanie listy podmiotów podrzędnych,
	// jeżeli podmiot bieżącego kontekstu ma rolę podmiotu nadrzędnego:
	// - **nadrzędna JST** – odczytywane są podrzędne JST,
	// - **grupa VAT** – odczytywane są podmioty będące członkami grupy VAT.
	// Role podmiotów zwracane przez operację obejmują:
	// - **LocalGovernmentSubUnit** – podrzędne JST,
	// - **VatGroupSubUnit** – członek grupy VAT.
	// Odpowiedź może być filtrowana według parametru:
	// - **subordinateEntityIdentifier** – identyfikator podmiotu podrzędnego.
	// #### Stronicowanie wyników
	// Zapytanie zwraca **jedną stronę wyników** o numerze i rozmiarze podanym w ścieżce.
	// - Przy pierwszym wywołaniu należy ustawić parametr `pageOffset = 0`.
	// - Jeżeli dostępna jest kolejna strona wyników, w odpowiedzi pojawi się flaga **`hasMore`**.
	// - W takim przypadku można wywołać zapytanie ponownie z kolejnym numerem strony.
	// > Więcej informacji:
	// > - [Pobieranie listy podmiotów podrzędnych](https://github.
	// com/CIRFMF/ksef-docs/blob/main/uprawnienia.md#pobranie-listy-podmiot%C3%B3w-podrz%C4%99dnych)
	// **Sortowanie:**
	// - startDate (Desc)
	// **Wymagane uprawnienia**: `CredentialsManage`, `CredentialsRead`, `SubunitManage`.
	//
	// POST /api/v2/permissions/query/subordinate-entities/roles
	APIV2PermissionsQuerySubordinateEntitiesRolesPost(ctx context.Context, request OptSubordinateEntityRolesQueryRequest, params APIV2PermissionsQuerySubordinateEntitiesRolesPostParams) (APIV2PermissionsQuerySubordinateEntitiesRolesPostRes, error)
	// APIV2PermissionsQuerySubunitsGrantsPost invokes POST /api/v2/permissions/query/subunits/grants operation.
	//
	// Metoda pozwala na odczytanie uprawnień do zarządzania uprawnieniami nadanych administratorom:
	// - jednostek podrzędnych identyfikowanych identyfikatorem wewnętrznym
	// - podmiotów podrzędnych (podrzędnych JST lub członków grupy VAT) identyfikowanych przez NIP
	// Lista zwraca wyłącznie uprawnienia do zarządzania uprawnieniami nadane z kontekstu bieżącego
	// (z podmiotu nadrzędnego).
	// Nie są odczytywane uprawnienia nadane przez administratorów jednostek podrzędnych wewnątrz
	// tych jednostek.
	// Odpowiedź może być filtrowana na podstawie parametru:
	// - **subunitIdentifier** – identyfikator jednostki lub podmiotu podrzędnego
	// #### Stronicowanie wyników
	// Zapytanie zwraca **jedną stronę wyników** o numerze i rozmiarze podanym w ścieżce.
	// - Przy pierwszym wywołaniu należy ustawić parametr `pageOffset = 0`.
	// - Jeżeli dostępna jest kolejna strona wyników, w odpowiedzi pojawi się flaga **`hasMore`**.
	// - W takim przypadku można wywołać zapytanie ponownie z kolejnym numerem strony.
	// > Więcej informacji:
	// > - [Pobieranie listy uprawnień](https://github.com/CIRFMF/ksef-docs/blob/main/uprawnienia.
	// md#pobranie-listy-uprawnie%C5%84-administrator%C3%B3w-jednostek-i-podmiot%C3%B3w-podrz%C4%99dnych)
	// **Sortowanie:**
	// - startDate (Desc)
	// **Wymagane uprawnienia**: `CredentialsManage`, `CredentialsRead`, `SubunitManage`.
	//
	// POST /api/v2/permissions/query/subunits/grants
	APIV2PermissionsQuerySubunitsGrantsPost(ctx context.Context, request OptSubunitPermissionsQueryRequest, params APIV2PermissionsQuerySubunitsGrantsPostParams) (APIV2PermissionsQuerySubunitsGrantsPostRes, error)
	// APIV2PermissionsSubunitsGrantsPost invokes POST /api/v2/permissions/subunits/grants operation.
	//
	// Metoda pozwala na nadanie wskazanemu w żądaniu podmiotowi lub osobie fizycznej uprawnień
	// administratora w kontekście:
	// - wskazanego NIP podmiotu podrzędnego – wyłącznie jeżeli podmiot bieżącego kontekstu
	// logowania ma rolę podmiotu nadrzędnego:
	// - **LocalGovernmentUnit**
	// - **VatGroupUnit**
	// - wskazanego lub utworzonego identyfikatora wewnętrznego
	// Wraz z utworzeniem administratora jednostki podrzędnej tworzony jest identyfikator wewnętrzny
	// składający się z numeru NIP podmiotu kontekstu logowania oraz 5 cyfr unikalnie
	// identyfikujących jednostkę wewnętrzną.
	// W żądaniu podaje się również nazwę tej jednostki.
	// Uprawnienia administratora jednostki podrzędnej obejmują:
	// - **CredentialsManage** – zarządzanie uprawnieniami
	// Metoda automatycznie nadaje powyższe uprawnienie, bez konieczności podawania go w żądaniu.
	// > Więcej informacji:
	// > - [Nadawanie uprawnień](https://github.com/CIRFMF/ksef-docs/blob/main/uprawnienia.
	// md#nadanie-uprawnie%C5%84-administratora-podmiotu-podrz%C4%99dnego)
	// **Wymagane uprawnienia**: `SubunitManage`.
	//
	// POST /api/v2/permissions/subunits/grants
	APIV2PermissionsSubunitsGrantsPost(ctx context.Context, request OptSubunitPermissionsGrantRequest) (APIV2PermissionsSubunitsGrantsPostRes, error)
	// APIV2RateLimitsGet invokes GET /api/v2/rate-limits operation.
	//
	// Zwraca wartości aktualnie obowiązujących limitów ilości żądań przesyłanych do API.
	//
	// GET /api/v2/rate-limits
	APIV2RateLimitsGet(ctx context.Context) (APIV2RateLimitsGetRes, error)
	// APIV2SecurityPublicKeyCertificatesGet invokes GET /api/v2/security/public-key-certificates operation.
	//
	// Zwraca informacje o kluczach publicznych używanych do szyfrowania danych przesyłanych do systemu
	// KSeF.
	//
	// GET /api/v2/security/public-key-certificates
	APIV2SecurityPublicKeyCertificatesGet(ctx context.Context) (APIV2SecurityPublicKeyCertificatesGetRes, error)
	// APIV2SessionsBatchPost invokes POST /api/v2/sessions/batch operation.
	//
	// Otwiera sesję do wysyłki wsadowej faktur. Należy przekazać schemat wysyłanych faktur,
	// informacje o paczce faktur oraz informacje o kluczu używanym do szyfrowania.
	// > Więcej informacji:
	// > - [Przygotwanie paczki faktur](https://github.com/CIRFMF/ksef-docs/blob/main/sesja-wsadowa.md)
	// > - [Klucz publiczny Ministersta Finansów](/docs/v2/index.html#tag/Certyfikaty-klucza-publicznego)
	// **Wymagane uprawnienia**: `InvoiceWrite`.
	//
	// POST /api/v2/sessions/batch
	APIV2SessionsBatchPost(ctx context.Context, request OptOpenBatchSessionRequest) (APIV2SessionsBatchPostRes, error)
	// APIV2SessionsBatchReferenceNumberClosePost invokes POST /api/v2/sessions/batch/{referenceNumber}/close operation.
	//
	// Zamyka sesję wsadową, rozpoczyna procesowanie paczki faktur i generowanie UPO dla prawidłowych
	// faktur oraz zbiorczego UPO dla sesji.
	// **Wymagane uprawnienia**: `InvoiceWrite`.
	//
	// POST /api/v2/sessions/batch/{referenceNumber}/close
	APIV2SessionsBatchReferenceNumberClosePost(ctx context.Context, params APIV2SessionsBatchReferenceNumberClosePostParams) (APIV2SessionsBatchReferenceNumberClosePostRes, error)
	// APIV2SessionsGet invokes GET /api/v2/sessions operation.
	//
	// Zwraca listę sesji spełniających podane kryteria wyszukiwania.
	// **Sortowanie:**
	// - dateCreated (Desc)
	// **Wymagane uprawnienia**:
	// - `Introspection` – pozwala pobrać wszystkie sesje w bieżącym kontekście uwierzytelnienia
	// `(ContextIdentifier)`.
	// - `InvoiceWrite` – pozwala pobrać wyłącznie sesje utworzone przez podmiot uwierzytelniający,
	// czyli podmiot inicjujący uwierzytelnienie.
	//
	// GET /api/v2/sessions
	APIV2SessionsGet(ctx context.Context, params APIV2SessionsGetParams) (APIV2SessionsGetRes, error)
	// APIV2SessionsOnlinePost invokes POST /api/v2/sessions/online operation.
	//
	// Otwiera sesję do wysyłki pojedynczych faktur. Należy przekazać schemat wysyłanych faktur oraz
	// informacje o kluczu używanym do szyfrowania.
	// > Więcej informacji:
	// > - [Otwarcie sesji interaktywnej](https://github.
	// com/CIRFMF/ksef-docs/blob/main/sesja-interaktywna.md#1-otwarcie-sesji)
	// > - [Klucz publiczny Ministersta Finansów](/docs/v2/index.html#tag/Certyfikaty-klucza-publicznego)
	// **Wymagane uprawnienia**: `InvoiceWrite`, `PefInvoiceWrite`.
	//
	// POST /api/v2/sessions/online
	APIV2SessionsOnlinePost(ctx context.Context, request OptOpenOnlineSessionRequest) (APIV2SessionsOnlinePostRes, error)
	// APIV2SessionsOnlineReferenceNumberClosePost invokes POST /api/v2/sessions/online/{referenceNumber}/close operation.
	//
	// Zamyka sesję interaktywną i rozpoczyna generowanie zbiorczego UPO dla sesji.
	// **Wymagane uprawnienia**: `InvoiceWrite`, `PefInvoiceWrite`.
	//
	// POST /api/v2/sessions/online/{referenceNumber}/close
	APIV2SessionsOnlineReferenceNumberClosePost(ctx context.Context, params APIV2SessionsOnlineReferenceNumberClosePostParams) (APIV2SessionsOnlineReferenceNumberClosePostRes, error)
	// APIV2SessionsOnlineReferenceNumberInvoicesPost invokes POST /api/v2/sessions/online/{referenceNumber}/invoices operation.
	//
	// Przyjmuje zaszyfrowaną fakturę oraz jej metadane i rozpoczyna jej przetwarzanie.
	// > Więcej informacji:
	// > - [Wysłanie faktury](https://github.com/CIRFMF/ksef-docs/blob/main/sesja-interaktywna.
	// md#2-wys%C5%82anie-faktury)
	// **Wymagane uprawnienia**: `InvoiceWrite`, `PefInvoiceWrite`.
	//
	// POST /api/v2/sessions/online/{referenceNumber}/invoices
	APIV2SessionsOnlineReferenceNumberInvoicesPost(ctx context.Context, request OptSendInvoiceRequest, params APIV2SessionsOnlineReferenceNumberInvoicesPostParams) (APIV2SessionsOnlineReferenceNumberInvoicesPostRes, error)
	// APIV2SessionsReferenceNumberGet invokes GET /api/v2/sessions/{referenceNumber} operation.
	//
	// Sprawdza bieżący status sesji o podanym numerze referencyjnym.
	// **Wymagane uprawnienia**: `InvoiceWrite`, `Introspection`, `PefInvoiceWrite`.
	//
	// GET /api/v2/sessions/{referenceNumber}
	APIV2SessionsReferenceNumberGet(ctx context.Context, params APIV2SessionsReferenceNumberGetParams) (APIV2SessionsReferenceNumberGetRes, error)
	// APIV2SessionsReferenceNumberInvoicesFailedGet invokes GET /api/v2/sessions/{referenceNumber}/invoices/failed operation.
	//
	// Zwraca listę niepoprawnie przetworzonych faktur przesłanych w sesji wraz z ich statusami.
	// **Wymagane uprawnienia**: `InvoiceWrite`, `Introspection`, `PefInvoiceWrite`.
	//
	// GET /api/v2/sessions/{referenceNumber}/invoices/failed
	APIV2SessionsReferenceNumberInvoicesFailedGet(ctx context.Context, params APIV2SessionsReferenceNumberInvoicesFailedGetParams) (APIV2SessionsReferenceNumberInvoicesFailedGetRes, error)
	// APIV2SessionsReferenceNumberInvoicesGet invokes GET /api/v2/sessions/{referenceNumber}/invoices operation.
	//
	// Zwraca listę faktur przesłanych w sesji wraz z ich statusami, oraz informacje na temat ilości
	// poprawnie i niepoprawnie przetworzonych faktur.
	// **Wymagane uprawnienia**: `InvoiceWrite`, `Introspection`, `PefInvoiceWrite`.
	//
	// GET /api/v2/sessions/{referenceNumber}/invoices
	APIV2SessionsReferenceNumberInvoicesGet(ctx context.Context, params APIV2SessionsReferenceNumberInvoicesGetParams) (APIV2SessionsReferenceNumberInvoicesGetRes, error)
	// APIV2SessionsReferenceNumberInvoicesInvoiceReferenceNumberGet invokes GET /api/v2/sessions/{referenceNumber}/invoices/{invoiceReferenceNumber} operation.
	//
	// Zwraca fakturę przesłaną w sesji wraz ze statusem.
	// **Wymagane uprawnienia**: `InvoiceWrite`, `Introspection`, `PefInvoiceWrite`.
	//
	// GET /api/v2/sessions/{referenceNumber}/invoices/{invoiceReferenceNumber}
	APIV2SessionsReferenceNumberInvoicesInvoiceReferenceNumberGet(ctx context.Context, params APIV2SessionsReferenceNumberInvoicesInvoiceReferenceNumberGetParams) (APIV2SessionsReferenceNumberInvoicesInvoiceReferenceNumberGetRes, error)
	// APIV2SessionsReferenceNumberInvoicesInvoiceReferenceNumberUpoGet invokes GET /api/v2/sessions/{referenceNumber}/invoices/{invoiceReferenceNumber}/upo operation.
	//
	// Zwraca UPO faktury przesłanego w sesji na podstawie jego numeru KSeF.
	// **Wymagane uprawnienia**: `InvoiceWrite`, `Introspection`, `PefInvoiceWrite`.
	//
	// GET /api/v2/sessions/{referenceNumber}/invoices/{invoiceReferenceNumber}/upo
	APIV2SessionsReferenceNumberInvoicesInvoiceReferenceNumberUpoGet(ctx context.Context, params APIV2SessionsReferenceNumberInvoicesInvoiceReferenceNumberUpoGetParams) (APIV2SessionsReferenceNumberInvoicesInvoiceReferenceNumberUpoGetRes, error)
	// APIV2SessionsReferenceNumberInvoicesKsefKsefNumberUpoGet invokes GET /api/v2/sessions/{referenceNumber}/invoices/ksef/{ksefNumber}/upo operation.
	//
	// Zwraca UPO faktury przesłanego w sesji na podstawie jego numeru KSeF.
	// **Wymagane uprawnienia**: `InvoiceWrite`, `Introspection`, `PefInvoiceWrite`.
	//
	// GET /api/v2/sessions/{referenceNumber}/invoices/ksef/{ksefNumber}/upo
	APIV2SessionsReferenceNumberInvoicesKsefKsefNumberUpoGet(ctx context.Context, params APIV2SessionsReferenceNumberInvoicesKsefKsefNumberUpoGetParams) (APIV2SessionsReferenceNumberInvoicesKsefKsefNumberUpoGetRes, error)
	// APIV2SessionsReferenceNumberUpoUpoReferenceNumberGet invokes GET /api/v2/sessions/{referenceNumber}/upo/{upoReferenceNumber} operation.
	//
	// Zwraca XML zawierający zbiorcze UPO dla sesji.
	// **Wymagane uprawnienia**: `InvoiceWrite`, `Introspection`, `PefInvoiceWrite`.
	//
	// GET /api/v2/sessions/{referenceNumber}/upo/{upoReferenceNumber}
	APIV2SessionsReferenceNumberUpoUpoReferenceNumberGet(ctx context.Context, params APIV2SessionsReferenceNumberUpoUpoReferenceNumberGetParams) (APIV2SessionsReferenceNumberUpoUpoReferenceNumberGetRes, error)
	// APIV2TestdataAttachmentPost invokes POST /api/v2/testdata/attachment operation.
	//
	// Dodaje możliwość wysyłania faktur z załącznikiem przez wskazany podmiot.
	//
	// POST /api/v2/testdata/attachment
	APIV2TestdataAttachmentPost(ctx context.Context, request OptAttachmentPermissionGrantRequest) (APIV2TestdataAttachmentPostRes, error)
	// APIV2TestdataAttachmentRevokePost invokes POST /api/v2/testdata/attachment/revoke operation.
	//
	// Odbiera możliwość wysyłania faktur z załącznikiem przez wskazany podmiot.
	//
	// POST /api/v2/testdata/attachment/revoke
	APIV2TestdataAttachmentRevokePost(ctx context.Context, request OptAttachmentPermissionRevokeRequest) (APIV2TestdataAttachmentRevokePostRes, error)
	// APIV2TestdataLimitsContextSessionDelete invokes DELETE /api/v2/testdata/limits/context/session operation.
	//
	// Przywraca wartości aktualnie obowiązujących limitów sesji dla bieżącego kontekstu do
	// wartości domyślnych. **Tylko na środowiskach testowych.**.
	//
	// DELETE /api/v2/testdata/limits/context/session
	APIV2TestdataLimitsContextSessionDelete(ctx context.Context) (APIV2TestdataLimitsContextSessionDeleteRes, error)
	// APIV2TestdataLimitsContextSessionPost invokes POST /api/v2/testdata/limits/context/session operation.
	//
	// Zmienia wartości aktualnie obowiązujących limitów sesji dla bieżącego kontekstu. **Tylko na
	// środowiskach testowych.**.
	//
	// POST /api/v2/testdata/limits/context/session
	APIV2TestdataLimitsContextSessionPost(ctx context.Context, request OptSetSessionLimitsRequest) (APIV2TestdataLimitsContextSessionPostRes, error)
	// APIV2TestdataLimitsSubjectCertificateDelete invokes DELETE /api/v2/testdata/limits/subject/certificate operation.
	//
	// Przywraca wartości aktualnie obowiązujących limitów certyfikatów dla bieżącego podmiotu do
	// wartości domyślnych. **Tylko na środowiskach testowych.**.
	//
	// DELETE /api/v2/testdata/limits/subject/certificate
	APIV2TestdataLimitsSubjectCertificateDelete(ctx context.Context) (APIV2TestdataLimitsSubjectCertificateDeleteRes, error)
	// APIV2TestdataLimitsSubjectCertificatePost invokes POST /api/v2/testdata/limits/subject/certificate operation.
	//
	// Zmienia wartości aktualnie obowiązujących limitów certyfikatów dla bieżącego podmiotu.
	// **Tylko na środowiskach testowych.**.
	//
	// POST /api/v2/testdata/limits/subject/certificate
	APIV2TestdataLimitsSubjectCertificatePost(ctx context.Context, request OptSetSubjectLimitsRequest) (APIV2TestdataLimitsSubjectCertificatePostRes, error)
	// APIV2TestdataPermissionsPost invokes POST /api/v2/testdata/permissions operation.
	//
	// Nadawanie uprawnień testowemu podmiotowi lub osobie fizycznej, a także w ich kontekście.
	//
	// POST /api/v2/testdata/permissions
	APIV2TestdataPermissionsPost(ctx context.Context, request OptTestDataPermissionsGrantRequest) (APIV2TestdataPermissionsPostRes, error)
	// APIV2TestdataPermissionsRevokePost invokes POST /api/v2/testdata/permissions/revoke operation.
	//
	// Odbieranie uprawnień nadanych testowemu podmiotowi lub osobie fizycznej, a także w ich
	// kontekście.
	//
	// POST /api/v2/testdata/permissions/revoke
	APIV2TestdataPermissionsRevokePost(ctx context.Context, request OptTestDataPermissionsRevokeRequest) (APIV2TestdataPermissionsRevokePostRes, error)
	// APIV2TestdataPersonPost invokes POST /api/v2/testdata/person operation.
	//
	// Tworzenie nowej osoby fizycznej, której system nadaje uprawnienia właścicielskie. Można
	// również określić, czy osoba ta jest komornikiem – wówczas otrzyma odpowiednie uprawnienie
	// egzekucyjne.
	//
	// POST /api/v2/testdata/person
	APIV2TestdataPersonPost(ctx context.Context, request OptPersonCreateRequest) (APIV2TestdataPersonPostRes, error)
	// APIV2TestdataPersonRemovePost invokes POST /api/v2/testdata/person/remove operation.
	//
	// Usuwanie testowej osoby fizycznej. System automatycznie odbierze jej wszystkie uprawnienia.
	//
	// POST /api/v2/testdata/person/remove
	APIV2TestdataPersonRemovePost(ctx context.Context, request OptPersonRemoveRequest) (APIV2TestdataPersonRemovePostRes, error)
	// APIV2TestdataRateLimitsDelete invokes DELETE /api/v2/testdata/rate-limits operation.
	//
	// Przywraca wartości aktualnie obowiązujących limitów żądań przesyłąnych do API dla
	// bieżącego kontekstu do wartości domyślnych. **Tylko na środowiskach testowych.**.
	//
	// DELETE /api/v2/testdata/rate-limits
	APIV2TestdataRateLimitsDelete(ctx context.Context) (APIV2TestdataRateLimitsDeleteRes, error)
	// APIV2TestdataRateLimitsPost invokes POST /api/v2/testdata/rate-limits operation.
	//
	// Zmienia wartości aktualnie obowiązujących limitów żądań przesyłąnych do API dla
	// bieżącego kontekstu. **Tylko na środowiskach testowych.**.
	//
	// POST /api/v2/testdata/rate-limits
	APIV2TestdataRateLimitsPost(ctx context.Context, request OptSetRateLimitsRequest) (APIV2TestdataRateLimitsPostRes, error)
	// APIV2TestdataSubjectPost invokes POST /api/v2/testdata/subject operation.
	//
	// Tworzenie nowego podmiotu testowego. W przypadku grupy VAT i JST istnieje możliwość stworzenia
	// jednostek podrzędnych. W wyniku takiego działania w systemie powstanie powiązanie między tymi
	// podmiotami.
	//
	// POST /api/v2/testdata/subject
	APIV2TestdataSubjectPost(ctx context.Context, request OptSubjectCreateRequest) (APIV2TestdataSubjectPostRes, error)
	// APIV2TestdataSubjectRemovePost invokes POST /api/v2/testdata/subject/remove operation.
	//
	// Usuwanie podmiotu testowego. W przypadku grupy VAT i JST usunięte zostaną również jednostki
	// podrzędne.
	//
	// POST /api/v2/testdata/subject/remove
	APIV2TestdataSubjectRemovePost(ctx context.Context, request OptSubjectRemoveRequest) (APIV2TestdataSubjectRemovePostRes, error)
	// APIV2TokensGet invokes GET /api/v2/tokens operation.
	//
	// **Sortowanie:**
	// - dateCreated (Desc).
	//
	// GET /api/v2/tokens
	APIV2TokensGet(ctx context.Context, params APIV2TokensGetParams) (APIV2TokensGetRes, error)
	// APIV2TokensPost invokes POST /api/v2/tokens operation.
	//
	// Zwraca token, który może być użyty do uwierzytelniania się w KSeF.
	// Token może być generowany tylko w kontekście NIP lub identyfikatora wewnętrznego. Jest
	// zwracany tylko raz. Zaczyna być aktywny w momencie gdy jego status zmieni się na `Active`.
	//
	// POST /api/v2/tokens
	APIV2TokensPost(ctx context.Context, request OptGenerateTokenRequest) (APIV2TokensPostRes, error)
	// APIV2TokensReferenceNumberDelete invokes DELETE /api/v2/tokens/{referenceNumber} operation.
	//
	// Unieważniony token nie pozwoli już na uwierzytelnienie się za jego pomocą. Unieważnienie nie
	// może zostać cofnięte.
	//
	// DELETE /api/v2/tokens/{referenceNumber}
	APIV2TokensReferenceNumberDelete(ctx context.Context, params APIV2TokensReferenceNumberDeleteParams) (APIV2TokensReferenceNumberDeleteRes, error)
	// APIV2TokensReferenceNumberGet invokes GET /api/v2/tokens/{referenceNumber} operation.
	//
	// Pobranie statusu tokena.
	//
	// GET /api/v2/tokens/{referenceNumber}
	APIV2TokensReferenceNumberGet(ctx context.Context, params APIV2TokensReferenceNumberGetParams) (APIV2TokensReferenceNumberGetRes, error)
}

// Client implements OAS client.
type Client struct {
	serverURL *url.URL
	sec       SecuritySource
	baseClient
}

// NewClient initializes new Client defined by OAS.
func NewClient(serverURL string, sec SecuritySource, opts ...ClientOption) (*Client, error) {
	u, err := url.Parse(serverURL)
	if err != nil {
		return nil, err
	}
	trimTrailingSlashes(u)

	c, err := newClientConfig(opts...).baseClient()
	if err != nil {
		return nil, err
	}
	return &Client{
		serverURL:  u,
		sec:        sec,
		baseClient: c,
	}, nil
}

type serverURLKey struct{}

// WithServerURL sets context key to override server URL.
func WithServerURL(ctx context.Context, u *url.URL) context.Context {
	return context.WithValue(ctx, serverURLKey{}, u)
}

func (c *Client) requestURL(ctx context.Context) *url.URL {
	u, ok := ctx.Value(serverURLKey{}).(*url.URL)
	if !ok {
		return c.serverURL
	}
	return u
}

// APIV2AuthChallengePost invokes POST /api/v2/auth/challenge operation.
//
// Generuje unikalny challenge wymagany w kolejnym kroku operacji uwierzytelnienia.
//
// POST /api/v2/auth/challenge
func (c *Client) APIV2AuthChallengePost(ctx context.Context) (APIV2AuthChallengePostRes, error) {
	res, err := c.sendAPIV2AuthChallengePost(ctx)
	return res, err
}

func (c *Client) sendAPIV2AuthChallengePost(ctx context.Context) (res APIV2AuthChallengePostRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/v2/auth/challenge"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAPIV2AuthChallengePostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// APIV2AuthKsefTokenPost invokes POST /api/v2/auth/ksef-token operation.
//
// Rozpoczyna operację uwierzytelniania z wykorzystaniem wcześniej wygenerowanego tokena KSeF.
// Token KSeF wraz z timestampem ze wcześniej wygenerowanego challenge'a (w formacie
// ```token|timestamp```) powinien zostać zaszyfrowany dedykowanym do tego celu kluczem publicznym.
// - Timestamp powinien zostać przekazany jako **liczba milisekund od 1 stycznia 1970 roku (Unix
// timestamp)**.
// - Algorytm szyfrowania: **RSA-OAEP (z użyciem SHA-256 jako funkcji skrótu)**.
//
// POST /api/v2/auth/ksef-token
func (c *Client) APIV2AuthKsefTokenPost(ctx context.Context, request OptInitTokenAuthenticationRequest) (APIV2AuthKsefTokenPostRes, error) {
	res, err := c.sendAPIV2AuthKsefTokenPost(ctx, request)
	return res, err
}

func (c *Client) sendAPIV2AuthKsefTokenPost(ctx context.Context, request OptInitTokenAuthenticationRequest) (res APIV2AuthKsefTokenPostRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/v2/auth/ksef-token"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAPIV2AuthKsefTokenPostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAPIV2AuthKsefTokenPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// APIV2AuthReferenceNumberGet invokes GET /api/v2/auth/{referenceNumber} operation.
//
// Sprawdza bieżący status operacji uwierzytelniania dla podanego tokena.
// Sposób uwierzytelnienia: `AuthenticationToken` otrzymany przy rozpoczęciu operacji
// uwierzytelniania.
//
// GET /api/v2/auth/{referenceNumber}
func (c *Client) APIV2AuthReferenceNumberGet(ctx context.Context, params APIV2AuthReferenceNumberGetParams) (APIV2AuthReferenceNumberGetRes, error) {
	res, err := c.sendAPIV2AuthReferenceNumberGet(ctx, params)
	return res, err
}

func (c *Client) sendAPIV2AuthReferenceNumberGet(ctx context.Context, params APIV2AuthReferenceNumberGetParams) (res APIV2AuthReferenceNumberGetRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/api/v2/auth/"
	{
		// Encode "referenceNumber" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "referenceNumber",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.ReferenceNumber); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearer(ctx, APIV2AuthReferenceNumberGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAPIV2AuthReferenceNumberGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// APIV2AuthSessionsCurrentDelete invokes DELETE /api/v2/auth/sessions/current operation.
//
// Unieważnia sesję powiązaną z tokenem użytym do wywołania tej operacji.
// Unieważnienie sesji sprawia, że powiązany z nią refresh token przestaje działać i nie można
// już za jego pomocą uzyskać kolejnych access tokenów.
// **Aktywne access tokeny działają do czasu minięcia ich termin ważności.**
// Sposób uwierzytelnienia: `RefreshToken` lub `AccessToken`.
//
// DELETE /api/v2/auth/sessions/current
func (c *Client) APIV2AuthSessionsCurrentDelete(ctx context.Context) (APIV2AuthSessionsCurrentDeleteRes, error) {
	res, err := c.sendAPIV2AuthSessionsCurrentDelete(ctx)
	return res, err
}

func (c *Client) sendAPIV2AuthSessionsCurrentDelete(ctx context.Context) (res APIV2AuthSessionsCurrentDeleteRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/v2/auth/sessions/current"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearer(ctx, APIV2AuthSessionsCurrentDeleteOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAPIV2AuthSessionsCurrentDeleteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// APIV2AuthSessionsGet invokes GET /api/v2/auth/sessions operation.
//
// Zwraca listę aktywnych sesji uwierzytelnienia.
// **Sortowanie:**
// - startDate (Desc).
//
// GET /api/v2/auth/sessions
func (c *Client) APIV2AuthSessionsGet(ctx context.Context, params APIV2AuthSessionsGetParams) (APIV2AuthSessionsGetRes, error) {
	res, err := c.sendAPIV2AuthSessionsGet(ctx, params)
	return res, err
}

func (c *Client) sendAPIV2AuthSessionsGet(ctx context.Context, params APIV2AuthSessionsGetParams) (res APIV2AuthSessionsGetRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/v2/auth/sessions"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "pageSize" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "pageSize",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "x-continuation-token",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XContinuationToken.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearer(ctx, APIV2AuthSessionsGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAPIV2AuthSessionsGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// APIV2AuthSessionsReferenceNumberDelete invokes DELETE /api/v2/auth/sessions/{referenceNumber} operation.
//
// Unieważnia sesję o podanym numerze referencyjnym.
// Unieważnienie sesji sprawia, że powiązany z nią refresh token przestaje działać i nie można
// już za jego pomocą uzyskać kolejnych access tokenów.
// **Aktywne access tokeny działają do czasu minięcia ich termin ważności.**.
//
// DELETE /api/v2/auth/sessions/{referenceNumber}
func (c *Client) APIV2AuthSessionsReferenceNumberDelete(ctx context.Context, params APIV2AuthSessionsReferenceNumberDeleteParams) (APIV2AuthSessionsReferenceNumberDeleteRes, error) {
	res, err := c.sendAPIV2AuthSessionsReferenceNumberDelete(ctx, params)
	return res, err
}

func (c *Client) sendAPIV2AuthSessionsReferenceNumberDelete(ctx context.Context, params APIV2AuthSessionsReferenceNumberDeleteParams) (res APIV2AuthSessionsReferenceNumberDeleteRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/api/v2/auth/sessions/"
	{
		// Encode "referenceNumber" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "referenceNumber",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.ReferenceNumber); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearer(ctx, APIV2AuthSessionsReferenceNumberDeleteOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAPIV2AuthSessionsReferenceNumberDeleteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// APIV2AuthTokenRedeemPost invokes POST /api/v2/auth/token/redeem operation.
//
// Pobiera parę tokenów (access token i refresh token) wygenerowanych w ramach pozytywnie
// zakończonego procesu uwierzytelniania.
// **Tokeny można pobrać tylko raz.**
// Sposób uwierzytelnienia: `AuthenticationToken` otrzymany przy rozpoczęciu operacji
// uwierzytelniania.
//
// POST /api/v2/auth/token/redeem
func (c *Client) APIV2AuthTokenRedeemPost(ctx context.Context) (APIV2AuthTokenRedeemPostRes, error) {
	res, err := c.sendAPIV2AuthTokenRedeemPost(ctx)
	return res, err
}

func (c *Client) sendAPIV2AuthTokenRedeemPost(ctx context.Context) (res APIV2AuthTokenRedeemPostRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/v2/auth/token/redeem"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearer(ctx, APIV2AuthTokenRedeemPostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAPIV2AuthTokenRedeemPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// APIV2AuthTokenRefreshPost invokes POST /api/v2/auth/token/refresh operation.
//
// Generuje nowy token dostępu na podstawie ważnego refresh tokena.
// Sposób uwierzytelnienia: `RefreshToken`.
//
// POST /api/v2/auth/token/refresh
func (c *Client) APIV2AuthTokenRefreshPost(ctx context.Context) (APIV2AuthTokenRefreshPostRes, error) {
	res, err := c.sendAPIV2AuthTokenRefreshPost(ctx)
	return res, err
}

func (c *Client) sendAPIV2AuthTokenRefreshPost(ctx context.Context) (res APIV2AuthTokenRefreshPostRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/v2/auth/token/refresh"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearer(ctx, APIV2AuthTokenRefreshPostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAPIV2AuthTokenRefreshPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// APIV2AuthXadesSignaturePost invokes POST /api/v2/auth/xades-signature operation.
//
// Rozpoczyna operację uwierzytelniania za pomocą dokumentu XML podpisanego podpisem elektronicznym
// XAdES.
// > Więcej informacji:
// > - [Przygotowanie dokumentu XML](https://github.com/CIRFMF/ksef-docs/blob/main/uwierzytelnianie.
// md#1-przygotowanie-dokumentu-xml-authtokenrequest)
// > - [Podpis dokumentu XML](https://github.com/CIRFMF/ksef-docs/blob/main/uwierzytelnianie.
// md#2-podpisanie-dokumentu-xades)
// > - [Schemat XSD](/docs/v2/schemas/authv2.xsd).
//
// POST /api/v2/auth/xades-signature
func (c *Client) APIV2AuthXadesSignaturePost(ctx context.Context, request APIV2AuthXadesSignaturePostReq, params APIV2AuthXadesSignaturePostParams) (APIV2AuthXadesSignaturePostRes, error) {
	res, err := c.sendAPIV2AuthXadesSignaturePost(ctx, request, params)
	return res, err
}

func (c *Client) sendAPIV2AuthXadesSignaturePost(ctx context.Context, request APIV2AuthXadesSignaturePostReq, params APIV2AuthXadesSignaturePostParams) (res APIV2AuthXadesSignaturePostRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/v2/auth/xades-signature"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "verifyCertificateChain" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "verifyCertificateChain",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.VerifyCertificateChain.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAPIV2AuthXadesSignaturePostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAPIV2AuthXadesSignaturePostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// APIV2CertificatesCertificateSerialNumberRevokePost invokes POST /api/v2/certificates/{certificateSerialNumber}/revoke operation.
//
// Unieważnia certyfikat o podanym numerze seryjnym.
//
// POST /api/v2/certificates/{certificateSerialNumber}/revoke
func (c *Client) APIV2CertificatesCertificateSerialNumberRevokePost(ctx context.Context, request OptRevokeCertificateRequest, params APIV2CertificatesCertificateSerialNumberRevokePostParams) (APIV2CertificatesCertificateSerialNumberRevokePostRes, error) {
	res, err := c.sendAPIV2CertificatesCertificateSerialNumberRevokePost(ctx, request, params)
	return res, err
}

func (c *Client) sendAPIV2CertificatesCertificateSerialNumberRevokePost(ctx context.Context, request OptRevokeCertificateRequest, params APIV2CertificatesCertificateSerialNumberRevokePostParams) (res APIV2CertificatesCertificateSerialNumberRevokePostRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/api/v2/certificates/"
	{
		// Encode "certificateSerialNumber" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "certificateSerialNumber",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CertificateSerialNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/revoke"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAPIV2CertificatesCertificateSerialNumberRevokePostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearer(ctx, APIV2CertificatesCertificateSerialNumberRevokePostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAPIV2CertificatesCertificateSerialNumberRevokePostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// APIV2CertificatesEnrollmentsDataGet invokes GET /api/v2/certificates/enrollments/data operation.
//
// Zwraca dane wymagane do przygotowania wniosku certyfikacyjnego PKCS#10.
// Dane te są zwracane na podstawie certyfikatu użytego w procesie uwierzytelnienia i identyfikują
// podmiot, który składa wniosek o certyfikat.
// > Więcej informacji:
// > - [Pobranie danych do wniosku certyfikacyjnego](https://github.
// com/CIRFMF/ksef-docs/blob/main/certyfikaty-KSeF.md#2-pobranie-danych-do-wniosku-certyfikacyjnego)
// > - [Przygotowanie wniosku](https://github.com/CIRFMF/ksef-docs/blob/main/certyfikaty-KSeF.
// md#3-przygotowanie-csr-certificate-signing-request).
//
// GET /api/v2/certificates/enrollments/data
func (c *Client) APIV2CertificatesEnrollmentsDataGet(ctx context.Context) (APIV2CertificatesEnrollmentsDataGetRes, error) {
	res, err := c.sendAPIV2CertificatesEnrollmentsDataGet(ctx)
	return res, err
}

func (c *Client) sendAPIV2CertificatesEnrollmentsDataGet(ctx context.Context) (res APIV2CertificatesEnrollmentsDataGetRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/v2/certificates/enrollments/data"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearer(ctx, APIV2CertificatesEnrollmentsDataGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAPIV2CertificatesEnrollmentsDataGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// APIV2CertificatesEnrollmentsPost invokes POST /api/v2/certificates/enrollments operation.
//
// Przyjmuje wniosek certyfikacyjny i rozpoczyna jego przetwarzanie.
// Dozwolone typy kluczy prywatnych:
// - RSA (OID: 1.2.840.113549.1.1.1), długość klucza równa 2048 bitów,
// - EC (klucze oparte na krzywych eliptycznych, OID: 1.2.840.10045.2.1), krzywa NIST P-256
// (secp256r1)
// Zalecane jest stosowanie kluczy EC.
// Dozwolone algorytmy podpisu:
// - RSA PKCS#1 v1.5,
// - RSA PSS,
// - ECDSA (format podpisu zgodny z RFC 3279)
// Dozwolone funkcje skrótu użyte do podpisu CSR:
// - SHA1,
// - SHA256,
// - SHA384,
// - SHA512
// > Więcej informacji:
// > - [Wysłanie wniosku certyfikacyjnego](https://github.
// com/CIRFMF/ksef-docs/blob/main/certyfikaty-KSeF.md#4-wys%C5%82anie-wniosku-certyfikacyjnego).
//
// POST /api/v2/certificates/enrollments
func (c *Client) APIV2CertificatesEnrollmentsPost(ctx context.Context, request OptEnrollCertificateRequest) (APIV2CertificatesEnrollmentsPostRes, error) {
	res, err := c.sendAPIV2CertificatesEnrollmentsPost(ctx, request)
	return res, err
}

func (c *Client) sendAPIV2CertificatesEnrollmentsPost(ctx context.Context, request OptEnrollCertificateRequest) (res APIV2CertificatesEnrollmentsPostRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/v2/certificates/enrollments"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAPIV2CertificatesEnrollmentsPostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearer(ctx, APIV2CertificatesEnrollmentsPostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAPIV2CertificatesEnrollmentsPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// APIV2CertificatesEnrollmentsReferenceNumberGet invokes GET /api/v2/certificates/enrollments/{referenceNumber} operation.
//
// Zwraca informacje o statusie wniosku certyfikacyjnego.
//
// GET /api/v2/certificates/enrollments/{referenceNumber}
func (c *Client) APIV2CertificatesEnrollmentsReferenceNumberGet(ctx context.Context, params APIV2CertificatesEnrollmentsReferenceNumberGetParams) (APIV2CertificatesEnrollmentsReferenceNumberGetRes, error) {
	res, err := c.sendAPIV2CertificatesEnrollmentsReferenceNumberGet(ctx, params)
	return res, err
}

func (c *Client) sendAPIV2CertificatesEnrollmentsReferenceNumberGet(ctx context.Context, params APIV2CertificatesEnrollmentsReferenceNumberGetParams) (res APIV2CertificatesEnrollmentsReferenceNumberGetRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/api/v2/certificates/enrollments/"
	{
		// Encode "referenceNumber" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "referenceNumber",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.ReferenceNumber); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearer(ctx, APIV2CertificatesEnrollmentsReferenceNumberGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAPIV2CertificatesEnrollmentsReferenceNumberGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// APIV2CertificatesLimitsGet invokes GET /api/v2/certificates/limits operation.
//
// Zwraca informacje o limitach certyfikatów oraz informacje czy użytkownik może zawnioskować o
// certyfikat KSeF.
//
// GET /api/v2/certificates/limits
func (c *Client) APIV2CertificatesLimitsGet(ctx context.Context) (APIV2CertificatesLimitsGetRes, error) {
	res, err := c.sendAPIV2CertificatesLimitsGet(ctx)
	return res, err
}

func (c *Client) sendAPIV2CertificatesLimitsGet(ctx context.Context) (res APIV2CertificatesLimitsGetRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/v2/certificates/limits"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearer(ctx, APIV2CertificatesLimitsGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAPIV2CertificatesLimitsGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// APIV2CertificatesQueryPost invokes POST /api/v2/certificates/query operation.
//
// Zwraca listę certyfikatów spełniających podane kryteria wyszukiwania.
// W przypadku braku podania kryteriów wyszukiwania zwrócona zostanie nieprzefiltrowana lista.
// **Sortowanie:**
// - requestDate (Desc).
//
// POST /api/v2/certificates/query
func (c *Client) APIV2CertificatesQueryPost(ctx context.Context, request OptQueryCertificatesRequest, params APIV2CertificatesQueryPostParams) (APIV2CertificatesQueryPostRes, error) {
	res, err := c.sendAPIV2CertificatesQueryPost(ctx, request, params)
	return res, err
}

func (c *Client) sendAPIV2CertificatesQueryPost(ctx context.Context, request OptQueryCertificatesRequest, params APIV2CertificatesQueryPostParams) (res APIV2CertificatesQueryPostRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/v2/certificates/query"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "pageSize" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "pageSize",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "pageOffset" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "pageOffset",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageOffset.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAPIV2CertificatesQueryPostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearer(ctx, APIV2CertificatesQueryPostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAPIV2CertificatesQueryPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// APIV2CertificatesRetrievePost invokes POST /api/v2/certificates/retrieve operation.
//
// Zwraca certyfikaty o podanych numerach seryjnych w formacie DER zakodowanym w Base64.
//
// POST /api/v2/certificates/retrieve
func (c *Client) APIV2CertificatesRetrievePost(ctx context.Context, request OptRetrieveCertificatesRequest) (APIV2CertificatesRetrievePostRes, error) {
	res, err := c.sendAPIV2CertificatesRetrievePost(ctx, request)
	return res, err
}

func (c *Client) sendAPIV2CertificatesRetrievePost(ctx context.Context, request OptRetrieveCertificatesRequest) (res APIV2CertificatesRetrievePostRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/v2/certificates/retrieve"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAPIV2CertificatesRetrievePostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearer(ctx, APIV2CertificatesRetrievePostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAPIV2CertificatesRetrievePostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// APIV2InvoicesExportsPost invokes POST /api/v2/invoices/exports operation.
//
// Rozpoczyna asynchroniczny proces wyszukiwania faktur w systemie KSeF na podstawie przekazanych
// filtrów oraz przygotowania ich w formie zaszyfrowanej paczki.
// Wymagane jest przekazanie informacji o szyfrowaniu w polu <b>Encryption</b>, które służą do
// zabezpieczenia przygotowanej paczki z fakturami.
// Maksymalnie można uruchomić 10 równoczesnych eksportów w zalogowanym kontekście.
// System pobiera faktury rosnąco według daty określonej w filtrze (Invoicing, Issue,
// PermanentStorage) i dodaje je do paczki aż do osiągnięcia jednego z poniższych limitów:
// * Limit liczby faktur: 10 000 sztuk
// * Limit rozmiaru danych(skompresowanych): 1GB
// Paczka eksportu zawiera dodatkowy plik z metadanymi faktur w formacie JSON (`_metadata.json`).
// Zawartość pliku to
// obiekt z tablicą <b>invoices</b>, gdzie każdy element jest obiektem typu <b>InvoiceMetadata</b>
// (taki jak zwracany przez endpoint `POST /invoices/query/metadata`).
// <b>Plik z metadanymi(_metadata.json) nie jest wliczany do limitów algorytmu budowania paczki</b>.
// `Do realizacji pobierania przyrostowego należy stosować filtrowanie po dacie PermanentStorage`.
// **Sortowanie:**
// - permanentStorageDate | invoicingDate | issueDate (Asc) - pole wybierane na podstawie filtrów
// **Wymagane uprawnienia**: `InvoiceRead`.
//
// POST /api/v2/invoices/exports
func (c *Client) APIV2InvoicesExportsPost(ctx context.Context, request OptInvoiceExportRequest) (APIV2InvoicesExportsPostRes, error) {
	res, err := c.sendAPIV2InvoicesExportsPost(ctx, request)
	return res, err
}

func (c *Client) sendAPIV2InvoicesExportsPost(ctx context.Context, request OptInvoiceExportRequest) (res APIV2InvoicesExportsPostRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/v2/invoices/exports"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAPIV2InvoicesExportsPostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearer(ctx, APIV2InvoicesExportsPostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAPIV2InvoicesExportsPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// APIV2InvoicesExportsReferenceNumberGet invokes GET /api/v2/invoices/exports/{referenceNumber} operation.
//
// Paczka faktur jest dzielona na części o maksymalnym rozmiarze 50 MB. Każda część jest
// zaszyfrowana algorytmem AES-256-CBC z dopełnieniem PKCS#7, przy użyciu klucza symetrycznego
// przekazanego podczas inicjowania eksportu.
// W przypadku ucięcia wyniku eksportu z powodu przekroczenia limitów, zwracana jest flaga
// <b>IsTruncated = true</b> oraz odpowiednia data, którą należy wykorzystać do wykonania
// kolejnego eksportu, aż do momentu, gdy flaga <b>IsTruncated = false</b>.
// **Sortowanie:**
// - permanentStorageDate | invoicingDate | issueDate (Asc) - pole wybierane na podstawie filtrów
// **Wymagane uprawnienia**: `InvoiceRead`.
//
// GET /api/v2/invoices/exports/{referenceNumber}
func (c *Client) APIV2InvoicesExportsReferenceNumberGet(ctx context.Context, params APIV2InvoicesExportsReferenceNumberGetParams) (APIV2InvoicesExportsReferenceNumberGetRes, error) {
	res, err := c.sendAPIV2InvoicesExportsReferenceNumberGet(ctx, params)
	return res, err
}

func (c *Client) sendAPIV2InvoicesExportsReferenceNumberGet(ctx context.Context, params APIV2InvoicesExportsReferenceNumberGetParams) (res APIV2InvoicesExportsReferenceNumberGetRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/api/v2/invoices/exports/"
	{
		// Encode "referenceNumber" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "referenceNumber",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.ReferenceNumber); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearer(ctx, APIV2InvoicesExportsReferenceNumberGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAPIV2InvoicesExportsReferenceNumberGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// APIV2InvoicesKsefKsefNumberGet invokes GET /api/v2/invoices/ksef/{ksefNumber} operation.
//
// Zwraca fakturę o podanym numerze KSeF.
// **Wymagane uprawnienia**: `InvoiceRead`.
//
// GET /api/v2/invoices/ksef/{ksefNumber}
func (c *Client) APIV2InvoicesKsefKsefNumberGet(ctx context.Context, params APIV2InvoicesKsefKsefNumberGetParams) (APIV2InvoicesKsefKsefNumberGetRes, error) {
	res, err := c.sendAPIV2InvoicesKsefKsefNumberGet(ctx, params)
	return res, err
}

func (c *Client) sendAPIV2InvoicesKsefKsefNumberGet(ctx context.Context, params APIV2InvoicesKsefKsefNumberGetParams) (res APIV2InvoicesKsefKsefNumberGetRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/api/v2/invoices/ksef/"
	{
		// Encode "ksefNumber" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "ksefNumber",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.KsefNumber); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearer(ctx, APIV2InvoicesKsefKsefNumberGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAPIV2InvoicesKsefKsefNumberGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// APIV2InvoicesQueryMetadataPost invokes POST /api/v2/invoices/query/metadata operation.
//
// Zwraca metadane faktur spełniających filtry.
// Limit techniczny: ≤ 10 000 rekordów na zestaw filtrów, po jego osiągnięciu <b>isTruncated =
// true</b> i należy ponownie ustawić <b>dateRange</b>, używając ostatniej daty z wyników (tj.
// ustawić from/to - w zależności od kierunku sortowania, od daty ostatniego zwróconego rekordu)
// oraz wyzerować <b>pageOffset</b>.
// `Do scenariusza przyrostowego należy używać daty PermanentStorage oraz kolejność sortowania
// Asc`.
// <b>Scenariusz pobierania przyrostowego (skrót):</b>
// * Gdy <b>hasMore = false</b>, należy zakończyć,
// * Gdy <b>hasMore = true</b> i <b>isTruncated = false</b>, należy zwiększyć <b>pageOffset</b>,
// * Gdy <b>hasMore = true</b> i <b>isTruncated = true</b>, należy zawęzić <b>dateRange</b>
// (ustawić from od daty ostatniego rekordu), wyzerować <b>pageOffset</b> i kontynuować
// **Sortowanie:**
// - permanentStorageDate | invoicingDate | issueDate (Asc | Desc) - pole wybierane na podstawie
// filtrów
// **Wymagane uprawnienia**: `InvoiceRead`.
//
// POST /api/v2/invoices/query/metadata
func (c *Client) APIV2InvoicesQueryMetadataPost(ctx context.Context, request OptInvoiceQueryFilters, params APIV2InvoicesQueryMetadataPostParams) (APIV2InvoicesQueryMetadataPostRes, error) {
	res, err := c.sendAPIV2InvoicesQueryMetadataPost(ctx, request, params)
	return res, err
}

func (c *Client) sendAPIV2InvoicesQueryMetadataPost(ctx context.Context, request OptInvoiceQueryFilters, params APIV2InvoicesQueryMetadataPostParams) (res APIV2InvoicesQueryMetadataPostRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/v2/invoices/query/metadata"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "sortOrder" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sortOrder",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.SortOrder.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "pageOffset" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "pageOffset",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageOffset.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "pageSize" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "pageSize",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAPIV2InvoicesQueryMetadataPostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearer(ctx, APIV2InvoicesQueryMetadataPostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAPIV2InvoicesQueryMetadataPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// APIV2LimitsContextGet invokes GET /api/v2/limits/context operation.
//
// Zwraca wartości aktualnie obowiązujących limitów dla bieżącego kontekstu.
//
// GET /api/v2/limits/context
func (c *Client) APIV2LimitsContextGet(ctx context.Context) (APIV2LimitsContextGetRes, error) {
	res, err := c.sendAPIV2LimitsContextGet(ctx)
	return res, err
}

func (c *Client) sendAPIV2LimitsContextGet(ctx context.Context) (res APIV2LimitsContextGetRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/v2/limits/context"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearer(ctx, APIV2LimitsContextGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAPIV2LimitsContextGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// APIV2LimitsSubjectGet invokes GET /api/v2/limits/subject operation.
//
// Zwraca wartoście aktualnie obowiązujących limitów dla bieżącego podmiotu.
//
// GET /api/v2/limits/subject
func (c *Client) APIV2LimitsSubjectGet(ctx context.Context) (APIV2LimitsSubjectGetRes, error) {
	res, err := c.sendAPIV2LimitsSubjectGet(ctx)
	return res, err
}

func (c *Client) sendAPIV2LimitsSubjectGet(ctx context.Context) (res APIV2LimitsSubjectGetRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/v2/limits/subject"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearer(ctx, APIV2LimitsSubjectGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAPIV2LimitsSubjectGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// APIV2PeppolQueryGet invokes GET /api/v2/peppol/query operation.
//
// Zwraca listę dostawców usług Peppol zarejestrowanych w systemie.
// **Sortowanie:**
// - dateCreated (Desc).
//
// GET /api/v2/peppol/query
func (c *Client) APIV2PeppolQueryGet(ctx context.Context, params APIV2PeppolQueryGetParams) (APIV2PeppolQueryGetRes, error) {
	res, err := c.sendAPIV2PeppolQueryGet(ctx, params)
	return res, err
}

func (c *Client) sendAPIV2PeppolQueryGet(ctx context.Context, params APIV2PeppolQueryGetParams) (res APIV2PeppolQueryGetRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/v2/peppol/query"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "pageOffset" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "pageOffset",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageOffset.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "pageSize" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "pageSize",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAPIV2PeppolQueryGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// APIV2PermissionsAttachmentsStatusGet invokes GET /api/v2/permissions/attachments/status operation.
//
// Sprawdzenie czy obecny kontekst posiada zgodę na wystawianie faktur z załącznikiem.
// **Wymagane uprawnienia**: `CredentialsManage`, `CredentialsRead`.
//
// GET /api/v2/permissions/attachments/status
func (c *Client) APIV2PermissionsAttachmentsStatusGet(ctx context.Context) (APIV2PermissionsAttachmentsStatusGetRes, error) {
	res, err := c.sendAPIV2PermissionsAttachmentsStatusGet(ctx)
	return res, err
}

func (c *Client) sendAPIV2PermissionsAttachmentsStatusGet(ctx context.Context) (res APIV2PermissionsAttachmentsStatusGetRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/v2/permissions/attachments/status"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearer(ctx, APIV2PermissionsAttachmentsStatusGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAPIV2PermissionsAttachmentsStatusGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// APIV2PermissionsAuthorizationsGrantsPermissionIdDelete invokes DELETE /api/v2/permissions/authorizations/grants/{permissionId} operation.
//
// Metoda pozwala na odebranie uprawnienia podmiotowego o wskazanym identyfikatorze.
// Wymagane jest wcześniejsze odczytanie uprawnień w celu uzyskania
// identyfikatora uprawnienia, które ma zostać odebrane.
// > Więcej informacji:
// > - [Odbieranie uprawnień](https://github.com/CIRFMF/ksef-docs/blob/main/uprawnienia.
// md#odebranie-uprawnie%C5%84-podmiotowych)
// **Wymagane uprawnienia**: `CredentialsManage`.
//
// DELETE /api/v2/permissions/authorizations/grants/{permissionId}
func (c *Client) APIV2PermissionsAuthorizationsGrantsPermissionIdDelete(ctx context.Context, params APIV2PermissionsAuthorizationsGrantsPermissionIdDeleteParams) (APIV2PermissionsAuthorizationsGrantsPermissionIdDeleteRes, error) {
	res, err := c.sendAPIV2PermissionsAuthorizationsGrantsPermissionIdDelete(ctx, params)
	return res, err
}

func (c *Client) sendAPIV2PermissionsAuthorizationsGrantsPermissionIdDelete(ctx context.Context, params APIV2PermissionsAuthorizationsGrantsPermissionIdDeleteParams) (res APIV2PermissionsAuthorizationsGrantsPermissionIdDeleteRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/api/v2/permissions/authorizations/grants/"
	{
		// Encode "permissionId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "permissionId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.PermissionId); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearer(ctx, APIV2PermissionsAuthorizationsGrantsPermissionIdDeleteOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAPIV2PermissionsAuthorizationsGrantsPermissionIdDeleteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// APIV2PermissionsAuthorizationsGrantsPost invokes POST /api/v2/permissions/authorizations/grants operation.
//
// Metoda pozwala na nadanie jednego z uprawnień podmiotowych do obsługi podmiotu kontekstu
// podmiotowi wskazanemu w żądaniu.
// > Więcej informacji:
// > - [Nadawanie uprawnień](https://github.com/CIRFMF/ksef-docs/blob/main/uprawnienia.
// md#nadanie-uprawnie%C5%84-podmiotowych)
// **Wymagane uprawnienia**: `CredentialsManage`.
//
// POST /api/v2/permissions/authorizations/grants
func (c *Client) APIV2PermissionsAuthorizationsGrantsPost(ctx context.Context, request OptEntityAuthorizationPermissionsGrantRequest) (APIV2PermissionsAuthorizationsGrantsPostRes, error) {
	res, err := c.sendAPIV2PermissionsAuthorizationsGrantsPost(ctx, request)
	return res, err
}

func (c *Client) sendAPIV2PermissionsAuthorizationsGrantsPost(ctx context.Context, request OptEntityAuthorizationPermissionsGrantRequest) (res APIV2PermissionsAuthorizationsGrantsPostRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/v2/permissions/authorizations/grants"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAPIV2PermissionsAuthorizationsGrantsPostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearer(ctx, APIV2PermissionsAuthorizationsGrantsPostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAPIV2PermissionsAuthorizationsGrantsPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// APIV2PermissionsCommonGrantsPermissionIdDelete invokes DELETE /api/v2/permissions/common/grants/{permissionId} operation.
//
// Metoda pozwala na odebranie uprawnienia o wskazanym identyfikatorze.
// Wymagane jest wcześniejsze odczytanie uprawnień w celu uzyskania
// identyfikatora uprawnienia, które ma zostać odebrane.
// > Więcej informacji:
// > - [Odbieranie uprawnień](https://github.com/CIRFMF/ksef-docs/blob/main/uprawnienia.
// md#odebranie-uprawnie%C5%84)
// **Wymagane uprawnienia**: `CredentialsManage`, `VatUeManage`, `SubunitManage`.
//
// DELETE /api/v2/permissions/common/grants/{permissionId}
func (c *Client) APIV2PermissionsCommonGrantsPermissionIdDelete(ctx context.Context, params APIV2PermissionsCommonGrantsPermissionIdDeleteParams) (APIV2PermissionsCommonGrantsPermissionIdDeleteRes, error) {
	res, err := c.sendAPIV2PermissionsCommonGrantsPermissionIdDelete(ctx, params)
	return res, err
}

func (c *Client) sendAPIV2PermissionsCommonGrantsPermissionIdDelete(ctx context.Context, params APIV2PermissionsCommonGrantsPermissionIdDeleteParams) (res APIV2PermissionsCommonGrantsPermissionIdDeleteRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/api/v2/permissions/common/grants/"
	{
		// Encode "permissionId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "permissionId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.PermissionId); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearer(ctx, APIV2PermissionsCommonGrantsPermissionIdDeleteOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAPIV2PermissionsCommonGrantsPermissionIdDeleteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// APIV2PermissionsEntitiesGrantsPost invokes POST /api/v2/permissions/entities/grants operation.
//
// Metoda pozwala na nadanie podmiotowi wskazanemu w żądaniu uprawnień do obsługi faktur podmiotu
// kontekstu.
// W żądaniu określane są nadawane uprawnienia ze zbioru:
// - **InvoiceWrite** – wystawianie faktur
// - **InvoiceRead** – przeglądanie faktur
// Metoda pozwala na wybór dowolnej kombinacji powyższych uprawnień.
// Dla każdego uprawnienia może być ustawiona flaga **canDelegate**, mówiąca o możliwości jego
// dalszego przekazywania poprzez nadawanie w sposób pośredni.
// > Więcej informacji:
// > - [Nadawanie uprawnień](https://github.com/CIRFMF/ksef-docs/blob/main/uprawnienia.
// md#nadanie-podmiotom-uprawnie%C5%84-do-obs%C5%82ugi-faktur)
// **Wymagane uprawnienia**: `CredentialsManage`.
//
// POST /api/v2/permissions/entities/grants
func (c *Client) APIV2PermissionsEntitiesGrantsPost(ctx context.Context, request OptEntityPermissionsGrantRequest) (APIV2PermissionsEntitiesGrantsPostRes, error) {
	res, err := c.sendAPIV2PermissionsEntitiesGrantsPost(ctx, request)
	return res, err
}

func (c *Client) sendAPIV2PermissionsEntitiesGrantsPost(ctx context.Context, request OptEntityPermissionsGrantRequest) (res APIV2PermissionsEntitiesGrantsPostRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/v2/permissions/entities/grants"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAPIV2PermissionsEntitiesGrantsPostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearer(ctx, APIV2PermissionsEntitiesGrantsPostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAPIV2PermissionsEntitiesGrantsPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// APIV2PermissionsEuEntitiesAdministrationGrantsPost invokes POST /api/v2/permissions/eu-entities/administration/grants operation.
//
// Metoda pozwala na nadanie wskazanemu w żądaniu podmiotowi lub osobie fizycznej uprawnień
// administratora w kontekście złożonym z identyfikatora NIP podmiotu kontekstu bieżącego oraz
// numeru VAT UE podmiotu unijnego wskazanego w żądaniu.
// Wraz z utworzeniem administratora podmiotu unijnego tworzony jest kontekst złożony składający
// się z numeru NIP podmiotu kontekstu logowania oraz wskazanego numeru identyfikacyjnego VAT UE
// podmiotu unijnego.
// W żądaniu podaje się również nazwę i adres podmiotu unijnego.
// Jedynym sposobem identyfikacji uprawnianego jest odcisk palca certyfikatu kwalifikowanego:
// - certyfikat podpisu elektronicznego dla osób fizycznych
// - certyfikat pieczęci elektronicznej dla podmiotów
// Uprawnienia administratora podmiotu unijnego obejmują:
// - **VatEuManage** – zarządzanie uprawnieniami w ramach podmiotu unijnego
// - **InvoiceWrite** – wystawianie faktur
// - **InvoiceRead** – przeglądanie faktur
// - **Introspection** – przeglądanie historii sesji
// Metoda automatycznie nadaje wszystkie powyższe uprawnienia, bez konieczności ich wskazywania w
// żądaniu.
// > Więcej informacji:
// > - [Nadawanie uprawnień](https://github.com/CIRFMF/ksef-docs/blob/main/uprawnienia.
// md#nadanie-uprawnie%C5%84-administratora-podmiotu-unijnego)
// **Wymagane uprawnienia**: `CredentialsManage`.
//
// POST /api/v2/permissions/eu-entities/administration/grants
func (c *Client) APIV2PermissionsEuEntitiesAdministrationGrantsPost(ctx context.Context, request OptEuEntityAdministrationPermissionsGrantRequest) (APIV2PermissionsEuEntitiesAdministrationGrantsPostRes, error) {
	res, err := c.sendAPIV2PermissionsEuEntitiesAdministrationGrantsPost(ctx, request)
	return res, err
}

func (c *Client) sendAPIV2PermissionsEuEntitiesAdministrationGrantsPost(ctx context.Context, request OptEuEntityAdministrationPermissionsGrantRequest) (res APIV2PermissionsEuEntitiesAdministrationGrantsPostRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/v2/permissions/eu-entities/administration/grants"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAPIV2PermissionsEuEntitiesAdministrationGrantsPostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearer(ctx, APIV2PermissionsEuEntitiesAdministrationGrantsPostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAPIV2PermissionsEuEntitiesAdministrationGrantsPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// APIV2PermissionsEuEntitiesGrantsPost invokes POST /api/v2/permissions/eu-entities/grants operation.
//
// Metoda pozwala na nadanie wskazanemu w żądaniu podmiotowi lub osobie fizycznej uprawnień do
// wystawiania i/lub przeglądania faktur w kontekście złożonym kontekstu bieżącego.
// Jedynym sposobem identyfikacji uprawnianego jest odcisk palca certyfikatu kwalifikowanego:
// - certyfikat podpisu elektronicznego dla osób fizycznych
// - certyfikat pieczęci elektronicznej dla podmiotów
// W żądaniu określane są nadawane uprawnienia ze zbioru:
// - **InvoiceWrite** – wystawianie faktur
// - **InvoiceRead** – przeglądanie faktur
// Metoda pozwala na wybór dowolnej kombinacji powyższych uprawnień.
// > Więcej informacji:
// > - [Nadawanie uprawnień](https://github.com/CIRFMF/ksef-docs/blob/main/uprawnienia.
// md#nadanie-uprawnie%C5%84-reprezentanta-podmiotu-unijnego)
// **Wymagane uprawnienia**: `VatUeManage`.
//
// POST /api/v2/permissions/eu-entities/grants
func (c *Client) APIV2PermissionsEuEntitiesGrantsPost(ctx context.Context, request OptEuEntityPermissionsGrantRequest) (APIV2PermissionsEuEntitiesGrantsPostRes, error) {
	res, err := c.sendAPIV2PermissionsEuEntitiesGrantsPost(ctx, request)
	return res, err
}

func (c *Client) sendAPIV2PermissionsEuEntitiesGrantsPost(ctx context.Context, request OptEuEntityPermissionsGrantRequest) (res APIV2PermissionsEuEntitiesGrantsPostRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/v2/permissions/eu-entities/grants"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAPIV2PermissionsEuEntitiesGrantsPostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearer(ctx, APIV2PermissionsEuEntitiesGrantsPostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAPIV2PermissionsEuEntitiesGrantsPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// APIV2PermissionsIndirectGrantsPost invokes POST /api/v2/permissions/indirect/grants operation.
//
// Metoda pozwala na nadanie w sposób pośredni osobie wskazanej w żądaniu uprawnień do obsługi
// faktur innego podmiotu – klienta.
// Może to być jedna z możliwości:
// - nadanie uprawnień generalnych – do obsługi wszystkich klientów
// - nadanie uprawnień selektywnych – do obsługi wskazanego klienta
// Uprawnienie selektywne może być nadane wyłącznie wtedy, gdy klient nadał wcześniej
// podmiotowi bieżącego kontekstu dowolne uprawnienie z prawem do jego dalszego przekazywania
// (patrz [POST /api/v2/permissions/entities/grants](/docs/v2/index.
// html#tag/Nadawanie-uprawnien/paths/~1api~1v2~1permissions~1entities~1grants/post)).
// W żądaniu określane są nadawane uprawnienia ze zbioru:
// - **InvoiceWrite** – wystawianie faktur
// - **InvoiceRead** – przeglądanie faktur
// Metoda pozwala na wybór dowolnej kombinacji powyższych uprawnień.
// > Więcej informacji:
// > - [Nadawanie uprawnień](https://github.com/CIRFMF/ksef-docs/blob/main/uprawnienia.
// md#nadanie-uprawnie%C5%84-w-spos%C3%B3b-po%C5%9Bredni)
// **Wymagane uprawnienia**: `CredentialsManage`.
//
// POST /api/v2/permissions/indirect/grants
func (c *Client) APIV2PermissionsIndirectGrantsPost(ctx context.Context, request OptIndirectPermissionsGrantRequest) (APIV2PermissionsIndirectGrantsPostRes, error) {
	res, err := c.sendAPIV2PermissionsIndirectGrantsPost(ctx, request)
	return res, err
}

func (c *Client) sendAPIV2PermissionsIndirectGrantsPost(ctx context.Context, request OptIndirectPermissionsGrantRequest) (res APIV2PermissionsIndirectGrantsPostRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/v2/permissions/indirect/grants"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAPIV2PermissionsIndirectGrantsPostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearer(ctx, APIV2PermissionsIndirectGrantsPostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAPIV2PermissionsIndirectGrantsPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// APIV2PermissionsOperationsReferenceNumberGet invokes GET /api/v2/permissions/operations/{referenceNumber} operation.
//
// Zwraca status operacji asynchronicznej związanej z nadaniem lub odebraniem uprawnień.
//
// GET /api/v2/permissions/operations/{referenceNumber}
func (c *Client) APIV2PermissionsOperationsReferenceNumberGet(ctx context.Context, params APIV2PermissionsOperationsReferenceNumberGetParams) (APIV2PermissionsOperationsReferenceNumberGetRes, error) {
	res, err := c.sendAPIV2PermissionsOperationsReferenceNumberGet(ctx, params)
	return res, err
}

func (c *Client) sendAPIV2PermissionsOperationsReferenceNumberGet(ctx context.Context, params APIV2PermissionsOperationsReferenceNumberGetParams) (res APIV2PermissionsOperationsReferenceNumberGetRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/api/v2/permissions/operations/"
	{
		// Encode "referenceNumber" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "referenceNumber",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.ReferenceNumber); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearer(ctx, APIV2PermissionsOperationsReferenceNumberGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAPIV2PermissionsOperationsReferenceNumberGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// APIV2PermissionsPersonsGrantsPost invokes POST /api/v2/permissions/persons/grants operation.
//
// Metoda pozwala na nadanie osobie wskazanej w żądaniu uprawnień do pracy w KSeF
// w kontekście bieżącym.
// W żądaniu określane są nadawane uprawnienia ze zbioru:
// - **InvoiceWrite** – wystawianie faktur,
// - **InvoiceRead** – przeglądanie faktur,
// - **CredentialsManage** – zarządzanie uprawnieniami,
// - **CredentialsRead** – przeglądanie uprawnień,
// - **Introspection** – przeglądanie historii sesji i generowanie UPO,
// - **SubunitManage** – zarządzanie jednostkami podrzędnymi,
// - **EnforcementOperations** – wykonywanie operacji egzekucyjnych.
// Metoda pozwala na wybór dowolnej kombinacji powyższych uprawnień.
// Uprawnienie **EnforcementOperations** może być nadane wyłącznie wtedy,
// gdy podmiot kontekstu ma rolę **EnforcementAuthority** (organ egzekucyjny)
// lub **CourtBailiff** (komornik sądowy).
// > Więcej informacji:
// > - [Nadawanie uprawnień](https://github.com/CIRFMF/ksef-docs/blob/main/uprawnienia.
// md#nadawanie-uprawnie%C5%84-osobom-fizycznym-do-pracy-w-ksef)
// **Wymagane uprawnienia**: `CredentialsManage`.
//
// POST /api/v2/permissions/persons/grants
func (c *Client) APIV2PermissionsPersonsGrantsPost(ctx context.Context, request OptPersonPermissionsGrantRequest) (APIV2PermissionsPersonsGrantsPostRes, error) {
	res, err := c.sendAPIV2PermissionsPersonsGrantsPost(ctx, request)
	return res, err
}

func (c *Client) sendAPIV2PermissionsPersonsGrantsPost(ctx context.Context, request OptPersonPermissionsGrantRequest) (res APIV2PermissionsPersonsGrantsPostRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/v2/permissions/persons/grants"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAPIV2PermissionsPersonsGrantsPostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearer(ctx, APIV2PermissionsPersonsGrantsPostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAPIV2PermissionsPersonsGrantsPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// APIV2PermissionsQueryAuthorizationsGrantsPost invokes POST /api/v2/permissions/query/authorizations/grants operation.
//
// Metoda pozwala na odczytanie uprawnień podmiotowych:
// - otrzymanych przez podmiot bieżącego kontekstu
// - nadanych przez podmiot bieżącego kontekstu
// Wybór listy nadanych lub otrzymanych uprawnień odbywa się przy użyciu parametru **queryType**.
// Uprawnienia zwracane przez operację obejmują:
// - **SelfInvoicing** – wystawianie faktur w trybie samofakturowania
// - **TaxRepresentative** – wykonywanie operacji przedstawiciela podatkowego
// - **RRInvoicing** – wystawianie faktur VAT RR
// - **PefInvoicing** – wystawianie faktur PEF
// Odpowiedź może być filtrowana na podstawie następujących parametrów:
// - **authorizingIdentifier** – identyfikator podmiotu uprawniającego (stosowane przy queryType =
// Received)
// - **authorizedIdentifier** – identyfikator podmiotu uprawnionego (stosowane przy queryType =
// Granted)
// - **permissionTypes** – lista rodzajów wyszukiwanych uprawnień
// #### Stronicowanie wyników
// Zapytanie zwraca **jedną stronę wyników** o numerze i rozmiarze podanym w ścieżce.
// - Przy pierwszym wywołaniu należy ustawić parametr `pageOffset = 0`.
// - Jeżeli dostępna jest kolejna strona wyników, w odpowiedzi pojawi się flaga **`hasMore`**.
// - W takim przypadku można wywołać zapytanie ponownie z kolejnym numerem strony.
// > Więcej informacji:
// > - [Pobieranie listy uprawnień](https://github.com/CIRFMF/ksef-docs/blob/main/uprawnienia.
// md#pobranie-listy-uprawnie%C5%84-podmiotowych-do-obs%C5%82ugi-faktur)
// **Sortowanie:**
// - startDate (Desc)
// **Wymagane uprawnienia**: `CredentialsManage`, `CredentialsRead`.
//
// POST /api/v2/permissions/query/authorizations/grants
func (c *Client) APIV2PermissionsQueryAuthorizationsGrantsPost(ctx context.Context, request OptEntityAuthorizationPermissionsQueryRequest, params APIV2PermissionsQueryAuthorizationsGrantsPostParams) (APIV2PermissionsQueryAuthorizationsGrantsPostRes, error) {
	res, err := c.sendAPIV2PermissionsQueryAuthorizationsGrantsPost(ctx, request, params)
	return res, err
}

func (c *Client) sendAPIV2PermissionsQueryAuthorizationsGrantsPost(ctx context.Context, request OptEntityAuthorizationPermissionsQueryRequest, params APIV2PermissionsQueryAuthorizationsGrantsPostParams) (res APIV2PermissionsQueryAuthorizationsGrantsPostRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/v2/permissions/query/authorizations/grants"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "pageOffset" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "pageOffset",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageOffset.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "pageSize" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "pageSize",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAPIV2PermissionsQueryAuthorizationsGrantsPostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearer(ctx, APIV2PermissionsQueryAuthorizationsGrantsPostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAPIV2PermissionsQueryAuthorizationsGrantsPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// APIV2PermissionsQueryEntitiesRolesGet invokes GET /api/v2/permissions/query/entities/roles operation.
//
// Metoda pozwala na **odczytanie listy ról podmiotu bieżącego kontekstu logowania**.
// #### Role podmiotów zwracane przez operację:
// - **CourtBailiff** – komornik sądowy
// - **EnforcementAuthority** – organ egzekucyjny
// - **LocalGovernmentUnit** – nadrzędna JST
// - **LocalGovernmentSubUnit** – podrzędne JST
// - **VatGroupUnit** – grupa VAT
// - **VatGroupSubUnit** – członek grupy VAT
// #### Stronicowanie wyników
// Zapytanie zwraca **jedną stronę wyników** o numerze i rozmiarze podanym w ścieżce.
// - Przy pierwszym wywołaniu należy ustawić parametr `pageOffset = 0`.
// - Jeżeli dostępna jest kolejna strona wyników, w odpowiedzi pojawi się flaga **`hasMore`**.
// - W takim przypadku można wywołać zapytanie ponownie z kolejnym numerem strony.
// > Więcej informacji:
// > - [Pobieranie listy ról](https://github.com/CIRFMF/ksef-docs/blob/main/uprawnienia.
// md#pobranie-listy-r%C3%B3l-podmiotu)
// **Sortowanie:**
// - startDate (Desc)
// **Wymagane uprawnienia**: `CredentialsManage`, `CredentialsRead`.
//
// GET /api/v2/permissions/query/entities/roles
func (c *Client) APIV2PermissionsQueryEntitiesRolesGet(ctx context.Context, params APIV2PermissionsQueryEntitiesRolesGetParams) (APIV2PermissionsQueryEntitiesRolesGetRes, error) {
	res, err := c.sendAPIV2PermissionsQueryEntitiesRolesGet(ctx, params)
	return res, err
}

func (c *Client) sendAPIV2PermissionsQueryEntitiesRolesGet(ctx context.Context, params APIV2PermissionsQueryEntitiesRolesGetParams) (res APIV2PermissionsQueryEntitiesRolesGetRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/v2/permissions/query/entities/roles"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "pageOffset" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "pageOffset",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageOffset.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "pageSize" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "pageSize",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearer(ctx, APIV2PermissionsQueryEntitiesRolesGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAPIV2PermissionsQueryEntitiesRolesGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// APIV2PermissionsQueryEuEntitiesGrantsPost invokes POST /api/v2/permissions/query/eu-entities/grants operation.
//
// Metoda pozwala na odczytanie uprawnień administratorów lub reprezentantów podmiotów unijnych:
// - Jeżeli kontekstem logowania jest NIP, możliwe jest odczytanie uprawnień administratorów
// podmiotów unijnych powiązanych z podmiotem bieżącego kontekstu, czyli takich, dla których
// pierwszy człon kontekstu złożonego jest równy NIP-owi kontekstu logowania.
// - Jeżeli kontekst logowania jest złożony (NIP-VAT UE), możliwe jest pobranie wszystkich
// uprawnień administratorów i reprezentantów podmiotu w bieżącym kontekście złożonym.
// Uprawnienia zwracane przez operację obejmują:
// - **VatUeManage** – zarządzanie uprawnieniami w ramach podmiotu unijnego
// - **InvoiceWrite** – wystawianie faktur
// - **InvoiceRead** – przeglądanie faktur
// - **Introspection** – przeglądanie historii sesji
// Odpowiedź może być filtrowana na podstawie następujących parametrów:
// - **vatUeIdentifier** – identyfikator podmiotu unijnego
// - **authorizedFingerprintIdentifier** – odcisk palca certyfikatu uprawnionej osoby lub podmiotu
// - **permissionTypes** – lista rodzajów wyszukiwanych uprawnień
// #### Stronicowanie wyników
// Zapytanie zwraca **jedną stronę wyników** o numerze i rozmiarze podanym w ścieżce.
// - Przy pierwszym wywołaniu należy ustawić parametr `pageOffset = 0`.
// - Jeżeli dostępna jest kolejna strona wyników, w odpowiedzi pojawi się flaga **`hasMore`**.
// - W takim przypadku można wywołać zapytanie ponownie z kolejnym numerem strony.
// > Więcej informacji:
// > - [Pobieranie listy uprawnień](https://github.com/CIRFMF/ksef-docs/blob/main/uprawnienia.
// md#pobranie-listy-uprawnie%C5%84-administrator%C3%B3w-lub-reprezentant%C3%B3w-podmiot%C3%B3w-unijnych-uprawnionych-do-samofakturowania)
// **Sortowanie:**
// - startDate (Desc)
// **Wymagane uprawnienia**: `CredentialsManage`, `CredentialsRead`, `VatUeManage`.
//
// POST /api/v2/permissions/query/eu-entities/grants
func (c *Client) APIV2PermissionsQueryEuEntitiesGrantsPost(ctx context.Context, request OptEuEntityPermissionsQueryRequest, params APIV2PermissionsQueryEuEntitiesGrantsPostParams) (APIV2PermissionsQueryEuEntitiesGrantsPostRes, error) {
	res, err := c.sendAPIV2PermissionsQueryEuEntitiesGrantsPost(ctx, request, params)
	return res, err
}

func (c *Client) sendAPIV2PermissionsQueryEuEntitiesGrantsPost(ctx context.Context, request OptEuEntityPermissionsQueryRequest, params APIV2PermissionsQueryEuEntitiesGrantsPostParams) (res APIV2PermissionsQueryEuEntitiesGrantsPostRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/v2/permissions/query/eu-entities/grants"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "pageOffset" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "pageOffset",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageOffset.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "pageSize" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "pageSize",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAPIV2PermissionsQueryEuEntitiesGrantsPostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearer(ctx, APIV2PermissionsQueryEuEntitiesGrantsPostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAPIV2PermissionsQueryEuEntitiesGrantsPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// APIV2PermissionsQueryPersonalGrantsPost invokes POST /api/v2/permissions/query/personal/grants operation.
//
// Metoda pozwala na odczytanie własnych uprawnień uwierzytelnionego klienta API w bieżącym
// kontekście logowania.
// W odpowiedzi przekazywane są następujące uprawnienia:
// - nadane w sposób bezpośredni w bieżącym kontekście
// - nadane przez podmiot nadrzędny
// - nadane w sposób pośredni, jeżeli podmiot kontekstu logowania jest w uprawnieniu pośrednikiem
// lub podmiotem docelowym
// - nadane podmiotowi do obsługi faktur przez inny podmiot, jeśli podmiot uwierzytelniony ma w
// bieżącym kontekście uprawnienia właścicielskie
// Uprawnienia zwracane przez operację obejmują:
// - **CredentialsManage** – zarządzanie uprawnieniami
// - **CredentialsRead** – przeglądanie uprawnień
// - **InvoiceWrite** – wystawianie faktur
// - **InvoiceRead** – przeglądanie faktur
// - **Introspection** – przeglądanie historii sesji
// - **SubunitManage** – zarządzanie podmiotami podrzędnymi
// - **EnforcementOperations** – wykonywanie operacji egzekucyjnych
// - **VatEuManage** – zarządzanie uprawnieniami w ramach podmiotu unijnego
// Odpowiedź może być filtrowana na podstawie następujących parametrów:
// - **contextIdentifier** – identyfikator podmiotu, który nadał uprawnienie do obsługi faktur
// - **targetIdentifier** – identyfikator podmiotu docelowego dla uprawnień nadanych pośrednio
// - **permissionTypes** – lista rodzajów wyszukiwanych uprawnień
// - **permissionState** – status uprawnienia
// #### Stronicowanie wyników
// Zapytanie zwraca **jedną stronę wyników** o numerze i rozmiarze podanym w ścieżce.
// - Przy pierwszym wywołaniu należy ustawić parametr `pageOffset = 0`.
// - Jeżeli dostępna jest kolejna strona wyników, w odpowiedzi pojawi się flaga **`hasMore`**.
// - W takim przypadku można wywołać zapytanie ponownie z kolejnym numerem strony.
// > Więcej informacji:
// > - [Pobieranie listy uprawnień](https://github.com/CIRFMF/ksef-docs/blob/main/uprawnienia.
// md#pobranie-listy-w%C5%82asnych-uprawnie%C5%84)
// **Sortowanie:**
// - startDate (Desc).
//
// POST /api/v2/permissions/query/personal/grants
func (c *Client) APIV2PermissionsQueryPersonalGrantsPost(ctx context.Context, request OptPersonalPermissionsQueryRequest, params APIV2PermissionsQueryPersonalGrantsPostParams) (APIV2PermissionsQueryPersonalGrantsPostRes, error) {
	res, err := c.sendAPIV2PermissionsQueryPersonalGrantsPost(ctx, request, params)
	return res, err
}

func (c *Client) sendAPIV2PermissionsQueryPersonalGrantsPost(ctx context.Context, request OptPersonalPermissionsQueryRequest, params APIV2PermissionsQueryPersonalGrantsPostParams) (res APIV2PermissionsQueryPersonalGrantsPostRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/v2/permissions/query/personal/grants"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "pageOffset" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "pageOffset",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageOffset.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "pageSize" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "pageSize",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAPIV2PermissionsQueryPersonalGrantsPostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearer(ctx, APIV2PermissionsQueryPersonalGrantsPostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAPIV2PermissionsQueryPersonalGrantsPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// APIV2PermissionsQueryPersonsGrantsPost invokes POST /api/v2/permissions/query/persons/grants operation.
//
// Metoda pozwala na odczytanie uprawnień nadanych osobie fizycznej lub podmiotowi.
// Lista pobranych uprawnień może być dwóch rodzajów:
// - Lista wszystkich uprawnień obowiązujących w bieżącym kontekście logowania (używana, gdy
// administrator chce przejrzeć uprawnienia wszystkich użytkowników w bieżącym kontekście)
// - Lista wszystkich uprawnień nadanych w bieżącym kontekście przez uwierzytelnionego klienta
// API (używana, gdy administrator chce przejrzeć listę nadanych przez siebie uprawnień w
// bieżącym kontekście)
// Dla pierwszej listy (obowiązujących uprawnień) w odpowiedzi przekazywane są:
// - osoby i podmioty mogące pracować w bieżącym kontekście z wyjątkiem osób uprawnionych w
// sposób pośredni
// - osoby uprawnione w sposób pośredni przez podmiot bieżącego kontekstu
// Dla drugiej listy (nadanych uprawnień) w odpowiedzi przekazywane są:
// - uprawnienia nadane w sposób bezpośredni do pracy w bieżącym kontekście lub w kontekście
// jednostek podrzędnych
// - uprawnienia nadane w sposób pośredni do obsługi klientów podmiotu bieżącego kontekstu
// Uprawnienia zwracane przez operację obejmują:
// - **CredentialsManage** – zarządzanie uprawnieniami
// - **CredentialsRead** – przeglądanie uprawnień
// - **InvoiceWrite** – wystawianie faktur
// - **InvoiceRead** – przeglądanie faktur
// - **Introspection** – przeglądanie historii sesji
// - **SubunitManage** – zarządzanie podmiotami podrzędnymi
// - **EnforcementOperations** – wykonywanie operacji egzekucyjnych
// Odpowiedź może być filtrowana na podstawie parametrów:
// - **authorIdentifier** – identyfikator osoby, która nadała uprawnienie
// - **authorizedIdentifier** – identyfikator osoby lub podmiotu uprawnionego
// - **targetIdentifier** – identyfikator podmiotu docelowego dla uprawnień nadanych pośrednio
// - **permissionTypes** – lista rodzajów wyszukiwanych uprawnień
// - **permissionState** – status uprawnienia
// - **queryType** – typ zapytania określający, która z dwóch list ma zostać zwrócona
// #### Stronicowanie wyników
// Zapytanie zwraca **jedną stronę wyników** o numerze i rozmiarze podanym w ścieżce.
// - Przy pierwszym wywołaniu należy ustawić parametr `pageOffset = 0`.
// - Jeżeli dostępna jest kolejna strona wyników, w odpowiedzi pojawi się flaga **`hasMore`**.
// - W takim przypadku można wywołać zapytanie ponownie z kolejnym numerem strony.
// > Więcej informacji:
// > - [Pobieranie listy uprawnień](https://github.com/CIRFMF/ksef-docs/blob/main/uprawnienia.
// md#pobranie-listy-uprawnie%C5%84-do-pracy-w-ksef-nadanych-osobom-fizycznym-lub-podmiotom)
// **Sortowanie:**
// - startDate (Desc)
// **Wymagane uprawnienia**: `CredentialsManage`, `CredentialsRead`, `SubunitManage`.
//
// POST /api/v2/permissions/query/persons/grants
func (c *Client) APIV2PermissionsQueryPersonsGrantsPost(ctx context.Context, request OptPersonPermissionsQueryRequest, params APIV2PermissionsQueryPersonsGrantsPostParams) (APIV2PermissionsQueryPersonsGrantsPostRes, error) {
	res, err := c.sendAPIV2PermissionsQueryPersonsGrantsPost(ctx, request, params)
	return res, err
}

func (c *Client) sendAPIV2PermissionsQueryPersonsGrantsPost(ctx context.Context, request OptPersonPermissionsQueryRequest, params APIV2PermissionsQueryPersonsGrantsPostParams) (res APIV2PermissionsQueryPersonsGrantsPostRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/v2/permissions/query/persons/grants"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "pageOffset" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "pageOffset",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageOffset.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "pageSize" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "pageSize",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAPIV2PermissionsQueryPersonsGrantsPostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearer(ctx, APIV2PermissionsQueryPersonsGrantsPostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAPIV2PermissionsQueryPersonsGrantsPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// APIV2PermissionsQuerySubordinateEntitiesRolesPost invokes POST /api/v2/permissions/query/subordinate-entities/roles operation.
//
// Metoda pozwala na odczytanie listy podmiotów podrzędnych,
// jeżeli podmiot bieżącego kontekstu ma rolę podmiotu nadrzędnego:
// - **nadrzędna JST** – odczytywane są podrzędne JST,
// - **grupa VAT** – odczytywane są podmioty będące członkami grupy VAT.
// Role podmiotów zwracane przez operację obejmują:
// - **LocalGovernmentSubUnit** – podrzędne JST,
// - **VatGroupSubUnit** – członek grupy VAT.
// Odpowiedź może być filtrowana według parametru:
// - **subordinateEntityIdentifier** – identyfikator podmiotu podrzędnego.
// #### Stronicowanie wyników
// Zapytanie zwraca **jedną stronę wyników** o numerze i rozmiarze podanym w ścieżce.
// - Przy pierwszym wywołaniu należy ustawić parametr `pageOffset = 0`.
// - Jeżeli dostępna jest kolejna strona wyników, w odpowiedzi pojawi się flaga **`hasMore`**.
// - W takim przypadku można wywołać zapytanie ponownie z kolejnym numerem strony.
// > Więcej informacji:
// > - [Pobieranie listy podmiotów podrzędnych](https://github.
// com/CIRFMF/ksef-docs/blob/main/uprawnienia.md#pobranie-listy-podmiot%C3%B3w-podrz%C4%99dnych)
// **Sortowanie:**
// - startDate (Desc)
// **Wymagane uprawnienia**: `CredentialsManage`, `CredentialsRead`, `SubunitManage`.
//
// POST /api/v2/permissions/query/subordinate-entities/roles
func (c *Client) APIV2PermissionsQuerySubordinateEntitiesRolesPost(ctx context.Context, request OptSubordinateEntityRolesQueryRequest, params APIV2PermissionsQuerySubordinateEntitiesRolesPostParams) (APIV2PermissionsQuerySubordinateEntitiesRolesPostRes, error) {
	res, err := c.sendAPIV2PermissionsQuerySubordinateEntitiesRolesPost(ctx, request, params)
	return res, err
}

func (c *Client) sendAPIV2PermissionsQuerySubordinateEntitiesRolesPost(ctx context.Context, request OptSubordinateEntityRolesQueryRequest, params APIV2PermissionsQuerySubordinateEntitiesRolesPostParams) (res APIV2PermissionsQuerySubordinateEntitiesRolesPostRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/v2/permissions/query/subordinate-entities/roles"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "pageOffset" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "pageOffset",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageOffset.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "pageSize" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "pageSize",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAPIV2PermissionsQuerySubordinateEntitiesRolesPostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearer(ctx, APIV2PermissionsQuerySubordinateEntitiesRolesPostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAPIV2PermissionsQuerySubordinateEntitiesRolesPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// APIV2PermissionsQuerySubunitsGrantsPost invokes POST /api/v2/permissions/query/subunits/grants operation.
//
// Metoda pozwala na odczytanie uprawnień do zarządzania uprawnieniami nadanych administratorom:
// - jednostek podrzędnych identyfikowanych identyfikatorem wewnętrznym
// - podmiotów podrzędnych (podrzędnych JST lub członków grupy VAT) identyfikowanych przez NIP
// Lista zwraca wyłącznie uprawnienia do zarządzania uprawnieniami nadane z kontekstu bieżącego
// (z podmiotu nadrzędnego).
// Nie są odczytywane uprawnienia nadane przez administratorów jednostek podrzędnych wewnątrz
// tych jednostek.
// Odpowiedź może być filtrowana na podstawie parametru:
// - **subunitIdentifier** – identyfikator jednostki lub podmiotu podrzędnego
// #### Stronicowanie wyników
// Zapytanie zwraca **jedną stronę wyników** o numerze i rozmiarze podanym w ścieżce.
// - Przy pierwszym wywołaniu należy ustawić parametr `pageOffset = 0`.
// - Jeżeli dostępna jest kolejna strona wyników, w odpowiedzi pojawi się flaga **`hasMore`**.
// - W takim przypadku można wywołać zapytanie ponownie z kolejnym numerem strony.
// > Więcej informacji:
// > - [Pobieranie listy uprawnień](https://github.com/CIRFMF/ksef-docs/blob/main/uprawnienia.
// md#pobranie-listy-uprawnie%C5%84-administrator%C3%B3w-jednostek-i-podmiot%C3%B3w-podrz%C4%99dnych)
// **Sortowanie:**
// - startDate (Desc)
// **Wymagane uprawnienia**: `CredentialsManage`, `CredentialsRead`, `SubunitManage`.
//
// POST /api/v2/permissions/query/subunits/grants
func (c *Client) APIV2PermissionsQuerySubunitsGrantsPost(ctx context.Context, request OptSubunitPermissionsQueryRequest, params APIV2PermissionsQuerySubunitsGrantsPostParams) (APIV2PermissionsQuerySubunitsGrantsPostRes, error) {
	res, err := c.sendAPIV2PermissionsQuerySubunitsGrantsPost(ctx, request, params)
	return res, err
}

func (c *Client) sendAPIV2PermissionsQuerySubunitsGrantsPost(ctx context.Context, request OptSubunitPermissionsQueryRequest, params APIV2PermissionsQuerySubunitsGrantsPostParams) (res APIV2PermissionsQuerySubunitsGrantsPostRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/v2/permissions/query/subunits/grants"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "pageOffset" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "pageOffset",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageOffset.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "pageSize" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "pageSize",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAPIV2PermissionsQuerySubunitsGrantsPostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearer(ctx, APIV2PermissionsQuerySubunitsGrantsPostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAPIV2PermissionsQuerySubunitsGrantsPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// APIV2PermissionsSubunitsGrantsPost invokes POST /api/v2/permissions/subunits/grants operation.
//
// Metoda pozwala na nadanie wskazanemu w żądaniu podmiotowi lub osobie fizycznej uprawnień
// administratora w kontekście:
// - wskazanego NIP podmiotu podrzędnego – wyłącznie jeżeli podmiot bieżącego kontekstu
// logowania ma rolę podmiotu nadrzędnego:
// - **LocalGovernmentUnit**
// - **VatGroupUnit**
// - wskazanego lub utworzonego identyfikatora wewnętrznego
// Wraz z utworzeniem administratora jednostki podrzędnej tworzony jest identyfikator wewnętrzny
// składający się z numeru NIP podmiotu kontekstu logowania oraz 5 cyfr unikalnie
// identyfikujących jednostkę wewnętrzną.
// W żądaniu podaje się również nazwę tej jednostki.
// Uprawnienia administratora jednostki podrzędnej obejmują:
// - **CredentialsManage** – zarządzanie uprawnieniami
// Metoda automatycznie nadaje powyższe uprawnienie, bez konieczności podawania go w żądaniu.
// > Więcej informacji:
// > - [Nadawanie uprawnień](https://github.com/CIRFMF/ksef-docs/blob/main/uprawnienia.
// md#nadanie-uprawnie%C5%84-administratora-podmiotu-podrz%C4%99dnego)
// **Wymagane uprawnienia**: `SubunitManage`.
//
// POST /api/v2/permissions/subunits/grants
func (c *Client) APIV2PermissionsSubunitsGrantsPost(ctx context.Context, request OptSubunitPermissionsGrantRequest) (APIV2PermissionsSubunitsGrantsPostRes, error) {
	res, err := c.sendAPIV2PermissionsSubunitsGrantsPost(ctx, request)
	return res, err
}

func (c *Client) sendAPIV2PermissionsSubunitsGrantsPost(ctx context.Context, request OptSubunitPermissionsGrantRequest) (res APIV2PermissionsSubunitsGrantsPostRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/v2/permissions/subunits/grants"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAPIV2PermissionsSubunitsGrantsPostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearer(ctx, APIV2PermissionsSubunitsGrantsPostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAPIV2PermissionsSubunitsGrantsPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// APIV2RateLimitsGet invokes GET /api/v2/rate-limits operation.
//
// Zwraca wartości aktualnie obowiązujących limitów ilości żądań przesyłanych do API.
//
// GET /api/v2/rate-limits
func (c *Client) APIV2RateLimitsGet(ctx context.Context) (APIV2RateLimitsGetRes, error) {
	res, err := c.sendAPIV2RateLimitsGet(ctx)
	return res, err
}

func (c *Client) sendAPIV2RateLimitsGet(ctx context.Context) (res APIV2RateLimitsGetRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/v2/rate-limits"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearer(ctx, APIV2RateLimitsGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAPIV2RateLimitsGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// APIV2SecurityPublicKeyCertificatesGet invokes GET /api/v2/security/public-key-certificates operation.
//
// Zwraca informacje o kluczach publicznych używanych do szyfrowania danych przesyłanych do systemu
// KSeF.
//
// GET /api/v2/security/public-key-certificates
func (c *Client) APIV2SecurityPublicKeyCertificatesGet(ctx context.Context) (APIV2SecurityPublicKeyCertificatesGetRes, error) {
	res, err := c.sendAPIV2SecurityPublicKeyCertificatesGet(ctx)
	return res, err
}

func (c *Client) sendAPIV2SecurityPublicKeyCertificatesGet(ctx context.Context) (res APIV2SecurityPublicKeyCertificatesGetRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/v2/security/public-key-certificates"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAPIV2SecurityPublicKeyCertificatesGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// APIV2SessionsBatchPost invokes POST /api/v2/sessions/batch operation.
//
// Otwiera sesję do wysyłki wsadowej faktur. Należy przekazać schemat wysyłanych faktur,
// informacje o paczce faktur oraz informacje o kluczu używanym do szyfrowania.
// > Więcej informacji:
// > - [Przygotwanie paczki faktur](https://github.com/CIRFMF/ksef-docs/blob/main/sesja-wsadowa.md)
// > - [Klucz publiczny Ministersta Finansów](/docs/v2/index.html#tag/Certyfikaty-klucza-publicznego)
// **Wymagane uprawnienia**: `InvoiceWrite`.
//
// POST /api/v2/sessions/batch
func (c *Client) APIV2SessionsBatchPost(ctx context.Context, request OptOpenBatchSessionRequest) (APIV2SessionsBatchPostRes, error) {
	res, err := c.sendAPIV2SessionsBatchPost(ctx, request)
	return res, err
}

func (c *Client) sendAPIV2SessionsBatchPost(ctx context.Context, request OptOpenBatchSessionRequest) (res APIV2SessionsBatchPostRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/v2/sessions/batch"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAPIV2SessionsBatchPostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearer(ctx, APIV2SessionsBatchPostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAPIV2SessionsBatchPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// APIV2SessionsBatchReferenceNumberClosePost invokes POST /api/v2/sessions/batch/{referenceNumber}/close operation.
//
// Zamyka sesję wsadową, rozpoczyna procesowanie paczki faktur i generowanie UPO dla prawidłowych
// faktur oraz zbiorczego UPO dla sesji.
// **Wymagane uprawnienia**: `InvoiceWrite`.
//
// POST /api/v2/sessions/batch/{referenceNumber}/close
func (c *Client) APIV2SessionsBatchReferenceNumberClosePost(ctx context.Context, params APIV2SessionsBatchReferenceNumberClosePostParams) (APIV2SessionsBatchReferenceNumberClosePostRes, error) {
	res, err := c.sendAPIV2SessionsBatchReferenceNumberClosePost(ctx, params)
	return res, err
}

func (c *Client) sendAPIV2SessionsBatchReferenceNumberClosePost(ctx context.Context, params APIV2SessionsBatchReferenceNumberClosePostParams) (res APIV2SessionsBatchReferenceNumberClosePostRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/api/v2/sessions/batch/"
	{
		// Encode "referenceNumber" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "referenceNumber",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.ReferenceNumber); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/close"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearer(ctx, APIV2SessionsBatchReferenceNumberClosePostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAPIV2SessionsBatchReferenceNumberClosePostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// APIV2SessionsGet invokes GET /api/v2/sessions operation.
//
// Zwraca listę sesji spełniających podane kryteria wyszukiwania.
// **Sortowanie:**
// - dateCreated (Desc)
// **Wymagane uprawnienia**:
// - `Introspection` – pozwala pobrać wszystkie sesje w bieżącym kontekście uwierzytelnienia
// `(ContextIdentifier)`.
// - `InvoiceWrite` – pozwala pobrać wyłącznie sesje utworzone przez podmiot uwierzytelniający,
// czyli podmiot inicjujący uwierzytelnienie.
//
// GET /api/v2/sessions
func (c *Client) APIV2SessionsGet(ctx context.Context, params APIV2SessionsGetParams) (APIV2SessionsGetRes, error) {
	res, err := c.sendAPIV2SessionsGet(ctx, params)
	return res, err
}

func (c *Client) sendAPIV2SessionsGet(ctx context.Context, params APIV2SessionsGetParams) (res APIV2SessionsGetRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/v2/sessions"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "pageSize" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "pageSize",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "sessionType" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sessionType",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(string(params.SessionType)))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "referenceNumber" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "referenceNumber",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ReferenceNumber.Get(); ok {
				if unwrapped := string(val); true {
					return e.EncodeValue(conv.StringToString(unwrapped))
				}
				return nil
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "dateCreatedFrom" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "dateCreatedFrom",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.DateCreatedFrom.Get(); ok {
				return e.EncodeValue(conv.DateTimeToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "dateCreatedTo" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "dateCreatedTo",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.DateCreatedTo.Get(); ok {
				return e.EncodeValue(conv.DateTimeToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "dateClosedFrom" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "dateClosedFrom",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.DateClosedFrom.Get(); ok {
				return e.EncodeValue(conv.DateTimeToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "dateClosedTo" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "dateClosedTo",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.DateClosedTo.Get(); ok {
				return e.EncodeValue(conv.DateTimeToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "dateModifiedFrom" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "dateModifiedFrom",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.DateModifiedFrom.Get(); ok {
				return e.EncodeValue(conv.DateTimeToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "dateModifiedTo" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "dateModifiedTo",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.DateModifiedTo.Get(); ok {
				return e.EncodeValue(conv.DateTimeToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "statuses" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "statuses",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if params.Statuses != nil {
				return e.EncodeArray(func(e uri.Encoder) error {
					for i, item := range params.Statuses {
						if err := func() error {
							return e.EncodeValue(conv.StringToString(string(item)))
						}(); err != nil {
							return errors.Wrapf(err, "[%d]", i)
						}
					}
					return nil
				})
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "x-continuation-token",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XContinuationToken.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearer(ctx, APIV2SessionsGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAPIV2SessionsGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// APIV2SessionsOnlinePost invokes POST /api/v2/sessions/online operation.
//
// Otwiera sesję do wysyłki pojedynczych faktur. Należy przekazać schemat wysyłanych faktur oraz
// informacje o kluczu używanym do szyfrowania.
// > Więcej informacji:
// > - [Otwarcie sesji interaktywnej](https://github.
// com/CIRFMF/ksef-docs/blob/main/sesja-interaktywna.md#1-otwarcie-sesji)
// > - [Klucz publiczny Ministersta Finansów](/docs/v2/index.html#tag/Certyfikaty-klucza-publicznego)
// **Wymagane uprawnienia**: `InvoiceWrite`, `PefInvoiceWrite`.
//
// POST /api/v2/sessions/online
func (c *Client) APIV2SessionsOnlinePost(ctx context.Context, request OptOpenOnlineSessionRequest) (APIV2SessionsOnlinePostRes, error) {
	res, err := c.sendAPIV2SessionsOnlinePost(ctx, request)
	return res, err
}

func (c *Client) sendAPIV2SessionsOnlinePost(ctx context.Context, request OptOpenOnlineSessionRequest) (res APIV2SessionsOnlinePostRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/v2/sessions/online"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAPIV2SessionsOnlinePostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearer(ctx, APIV2SessionsOnlinePostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAPIV2SessionsOnlinePostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// APIV2SessionsOnlineReferenceNumberClosePost invokes POST /api/v2/sessions/online/{referenceNumber}/close operation.
//
// Zamyka sesję interaktywną i rozpoczyna generowanie zbiorczego UPO dla sesji.
// **Wymagane uprawnienia**: `InvoiceWrite`, `PefInvoiceWrite`.
//
// POST /api/v2/sessions/online/{referenceNumber}/close
func (c *Client) APIV2SessionsOnlineReferenceNumberClosePost(ctx context.Context, params APIV2SessionsOnlineReferenceNumberClosePostParams) (APIV2SessionsOnlineReferenceNumberClosePostRes, error) {
	res, err := c.sendAPIV2SessionsOnlineReferenceNumberClosePost(ctx, params)
	return res, err
}

func (c *Client) sendAPIV2SessionsOnlineReferenceNumberClosePost(ctx context.Context, params APIV2SessionsOnlineReferenceNumberClosePostParams) (res APIV2SessionsOnlineReferenceNumberClosePostRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/api/v2/sessions/online/"
	{
		// Encode "referenceNumber" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "referenceNumber",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.ReferenceNumber); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/close"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearer(ctx, APIV2SessionsOnlineReferenceNumberClosePostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAPIV2SessionsOnlineReferenceNumberClosePostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// APIV2SessionsOnlineReferenceNumberInvoicesPost invokes POST /api/v2/sessions/online/{referenceNumber}/invoices operation.
//
// Przyjmuje zaszyfrowaną fakturę oraz jej metadane i rozpoczyna jej przetwarzanie.
// > Więcej informacji:
// > - [Wysłanie faktury](https://github.com/CIRFMF/ksef-docs/blob/main/sesja-interaktywna.
// md#2-wys%C5%82anie-faktury)
// **Wymagane uprawnienia**: `InvoiceWrite`, `PefInvoiceWrite`.
//
// POST /api/v2/sessions/online/{referenceNumber}/invoices
func (c *Client) APIV2SessionsOnlineReferenceNumberInvoicesPost(ctx context.Context, request OptSendInvoiceRequest, params APIV2SessionsOnlineReferenceNumberInvoicesPostParams) (APIV2SessionsOnlineReferenceNumberInvoicesPostRes, error) {
	res, err := c.sendAPIV2SessionsOnlineReferenceNumberInvoicesPost(ctx, request, params)
	return res, err
}

func (c *Client) sendAPIV2SessionsOnlineReferenceNumberInvoicesPost(ctx context.Context, request OptSendInvoiceRequest, params APIV2SessionsOnlineReferenceNumberInvoicesPostParams) (res APIV2SessionsOnlineReferenceNumberInvoicesPostRes, err error) {
	// Validate request before sending.
	//if err := func() error {
	//	if value, ok := request.Get(); ok {
	//		if err := func() error {
	//			if err := value.Validate(); err != nil {
	//				return err
	//			}
	//			return nil
	//		}(); err != nil {
	//			return err
	//		}
	//	}
	//	return nil
	//}(); err != nil {
	//	return res, errors.Wrap(err, "validate")
	//}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/api/v2/sessions/online/"
	{
		// Encode "referenceNumber" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "referenceNumber",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.ReferenceNumber); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/invoices"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAPIV2SessionsOnlineReferenceNumberInvoicesPostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearer(ctx, APIV2SessionsOnlineReferenceNumberInvoicesPostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAPIV2SessionsOnlineReferenceNumberInvoicesPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// APIV2SessionsReferenceNumberGet invokes GET /api/v2/sessions/{referenceNumber} operation.
//
// Sprawdza bieżący status sesji o podanym numerze referencyjnym.
// **Wymagane uprawnienia**: `InvoiceWrite`, `Introspection`, `PefInvoiceWrite`.
//
// GET /api/v2/sessions/{referenceNumber}
func (c *Client) APIV2SessionsReferenceNumberGet(ctx context.Context, params APIV2SessionsReferenceNumberGetParams) (APIV2SessionsReferenceNumberGetRes, error) {
	res, err := c.sendAPIV2SessionsReferenceNumberGet(ctx, params)
	return res, err
}

func (c *Client) sendAPIV2SessionsReferenceNumberGet(ctx context.Context, params APIV2SessionsReferenceNumberGetParams) (res APIV2SessionsReferenceNumberGetRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/api/v2/sessions/"
	{
		// Encode "referenceNumber" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "referenceNumber",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.ReferenceNumber); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearer(ctx, APIV2SessionsReferenceNumberGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAPIV2SessionsReferenceNumberGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// APIV2SessionsReferenceNumberInvoicesFailedGet invokes GET /api/v2/sessions/{referenceNumber}/invoices/failed operation.
//
// Zwraca listę niepoprawnie przetworzonych faktur przesłanych w sesji wraz z ich statusami.
// **Wymagane uprawnienia**: `InvoiceWrite`, `Introspection`, `PefInvoiceWrite`.
//
// GET /api/v2/sessions/{referenceNumber}/invoices/failed
func (c *Client) APIV2SessionsReferenceNumberInvoicesFailedGet(ctx context.Context, params APIV2SessionsReferenceNumberInvoicesFailedGetParams) (APIV2SessionsReferenceNumberInvoicesFailedGetRes, error) {
	res, err := c.sendAPIV2SessionsReferenceNumberInvoicesFailedGet(ctx, params)
	return res, err
}

func (c *Client) sendAPIV2SessionsReferenceNumberInvoicesFailedGet(ctx context.Context, params APIV2SessionsReferenceNumberInvoicesFailedGetParams) (res APIV2SessionsReferenceNumberInvoicesFailedGetRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/api/v2/sessions/"
	{
		// Encode "referenceNumber" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "referenceNumber",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.ReferenceNumber); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/invoices/failed"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "pageSize" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "pageSize",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "x-continuation-token",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XContinuationToken.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearer(ctx, APIV2SessionsReferenceNumberInvoicesFailedGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAPIV2SessionsReferenceNumberInvoicesFailedGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// APIV2SessionsReferenceNumberInvoicesGet invokes GET /api/v2/sessions/{referenceNumber}/invoices operation.
//
// Zwraca listę faktur przesłanych w sesji wraz z ich statusami, oraz informacje na temat ilości
// poprawnie i niepoprawnie przetworzonych faktur.
// **Wymagane uprawnienia**: `InvoiceWrite`, `Introspection`, `PefInvoiceWrite`.
//
// GET /api/v2/sessions/{referenceNumber}/invoices
func (c *Client) APIV2SessionsReferenceNumberInvoicesGet(ctx context.Context, params APIV2SessionsReferenceNumberInvoicesGetParams) (APIV2SessionsReferenceNumberInvoicesGetRes, error) {
	res, err := c.sendAPIV2SessionsReferenceNumberInvoicesGet(ctx, params)
	return res, err
}

func (c *Client) sendAPIV2SessionsReferenceNumberInvoicesGet(ctx context.Context, params APIV2SessionsReferenceNumberInvoicesGetParams) (res APIV2SessionsReferenceNumberInvoicesGetRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/api/v2/sessions/"
	{
		// Encode "referenceNumber" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "referenceNumber",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.ReferenceNumber); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/invoices"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "pageSize" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "pageSize",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "x-continuation-token",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XContinuationToken.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearer(ctx, APIV2SessionsReferenceNumberInvoicesGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAPIV2SessionsReferenceNumberInvoicesGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// APIV2SessionsReferenceNumberInvoicesInvoiceReferenceNumberGet invokes GET /api/v2/sessions/{referenceNumber}/invoices/{invoiceReferenceNumber} operation.
//
// Zwraca fakturę przesłaną w sesji wraz ze statusem.
// **Wymagane uprawnienia**: `InvoiceWrite`, `Introspection`, `PefInvoiceWrite`.
//
// GET /api/v2/sessions/{referenceNumber}/invoices/{invoiceReferenceNumber}
func (c *Client) APIV2SessionsReferenceNumberInvoicesInvoiceReferenceNumberGet(ctx context.Context, params APIV2SessionsReferenceNumberInvoicesInvoiceReferenceNumberGetParams) (APIV2SessionsReferenceNumberInvoicesInvoiceReferenceNumberGetRes, error) {
	res, err := c.sendAPIV2SessionsReferenceNumberInvoicesInvoiceReferenceNumberGet(ctx, params)
	return res, err
}

func (c *Client) sendAPIV2SessionsReferenceNumberInvoicesInvoiceReferenceNumberGet(ctx context.Context, params APIV2SessionsReferenceNumberInvoicesInvoiceReferenceNumberGetParams) (res APIV2SessionsReferenceNumberInvoicesInvoiceReferenceNumberGetRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/api/v2/sessions/"
	{
		// Encode "referenceNumber" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "referenceNumber",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.ReferenceNumber); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/invoices/"
	{
		// Encode "invoiceReferenceNumber" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "invoiceReferenceNumber",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.InvoiceReferenceNumber); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearer(ctx, APIV2SessionsReferenceNumberInvoicesInvoiceReferenceNumberGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAPIV2SessionsReferenceNumberInvoicesInvoiceReferenceNumberGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// APIV2SessionsReferenceNumberInvoicesInvoiceReferenceNumberUpoGet invokes GET /api/v2/sessions/{referenceNumber}/invoices/{invoiceReferenceNumber}/upo operation.
//
// Zwraca UPO faktury przesłanego w sesji na podstawie jego numeru KSeF.
// **Wymagane uprawnienia**: `InvoiceWrite`, `Introspection`, `PefInvoiceWrite`.
//
// GET /api/v2/sessions/{referenceNumber}/invoices/{invoiceReferenceNumber}/upo
func (c *Client) APIV2SessionsReferenceNumberInvoicesInvoiceReferenceNumberUpoGet(ctx context.Context, params APIV2SessionsReferenceNumberInvoicesInvoiceReferenceNumberUpoGetParams) (APIV2SessionsReferenceNumberInvoicesInvoiceReferenceNumberUpoGetRes, error) {
	res, err := c.sendAPIV2SessionsReferenceNumberInvoicesInvoiceReferenceNumberUpoGet(ctx, params)
	return res, err
}

func (c *Client) sendAPIV2SessionsReferenceNumberInvoicesInvoiceReferenceNumberUpoGet(ctx context.Context, params APIV2SessionsReferenceNumberInvoicesInvoiceReferenceNumberUpoGetParams) (res APIV2SessionsReferenceNumberInvoicesInvoiceReferenceNumberUpoGetRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/api/v2/sessions/"
	{
		// Encode "referenceNumber" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "referenceNumber",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.ReferenceNumber); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/invoices/"
	{
		// Encode "invoiceReferenceNumber" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "invoiceReferenceNumber",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.InvoiceReferenceNumber); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/upo"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearer(ctx, APIV2SessionsReferenceNumberInvoicesInvoiceReferenceNumberUpoGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAPIV2SessionsReferenceNumberInvoicesInvoiceReferenceNumberUpoGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// APIV2SessionsReferenceNumberInvoicesKsefKsefNumberUpoGet invokes GET /api/v2/sessions/{referenceNumber}/invoices/ksef/{ksefNumber}/upo operation.
//
// Zwraca UPO faktury przesłanego w sesji na podstawie jego numeru KSeF.
// **Wymagane uprawnienia**: `InvoiceWrite`, `Introspection`, `PefInvoiceWrite`.
//
// GET /api/v2/sessions/{referenceNumber}/invoices/ksef/{ksefNumber}/upo
func (c *Client) APIV2SessionsReferenceNumberInvoicesKsefKsefNumberUpoGet(ctx context.Context, params APIV2SessionsReferenceNumberInvoicesKsefKsefNumberUpoGetParams) (APIV2SessionsReferenceNumberInvoicesKsefKsefNumberUpoGetRes, error) {
	res, err := c.sendAPIV2SessionsReferenceNumberInvoicesKsefKsefNumberUpoGet(ctx, params)
	return res, err
}

func (c *Client) sendAPIV2SessionsReferenceNumberInvoicesKsefKsefNumberUpoGet(ctx context.Context, params APIV2SessionsReferenceNumberInvoicesKsefKsefNumberUpoGetParams) (res APIV2SessionsReferenceNumberInvoicesKsefKsefNumberUpoGetRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/api/v2/sessions/"
	{
		// Encode "referenceNumber" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "referenceNumber",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.ReferenceNumber); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/invoices/ksef/"
	{
		// Encode "ksefNumber" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "ksefNumber",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.KsefNumber); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/upo"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearer(ctx, APIV2SessionsReferenceNumberInvoicesKsefKsefNumberUpoGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAPIV2SessionsReferenceNumberInvoicesKsefKsefNumberUpoGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// APIV2SessionsReferenceNumberUpoUpoReferenceNumberGet invokes GET /api/v2/sessions/{referenceNumber}/upo/{upoReferenceNumber} operation.
//
// Zwraca XML zawierający zbiorcze UPO dla sesji.
// **Wymagane uprawnienia**: `InvoiceWrite`, `Introspection`, `PefInvoiceWrite`.
//
// GET /api/v2/sessions/{referenceNumber}/upo/{upoReferenceNumber}
func (c *Client) APIV2SessionsReferenceNumberUpoUpoReferenceNumberGet(ctx context.Context, params APIV2SessionsReferenceNumberUpoUpoReferenceNumberGetParams) (APIV2SessionsReferenceNumberUpoUpoReferenceNumberGetRes, error) {
	res, err := c.sendAPIV2SessionsReferenceNumberUpoUpoReferenceNumberGet(ctx, params)
	return res, err
}

func (c *Client) sendAPIV2SessionsReferenceNumberUpoUpoReferenceNumberGet(ctx context.Context, params APIV2SessionsReferenceNumberUpoUpoReferenceNumberGetParams) (res APIV2SessionsReferenceNumberUpoUpoReferenceNumberGetRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/api/v2/sessions/"
	{
		// Encode "referenceNumber" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "referenceNumber",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.ReferenceNumber); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/upo/"
	{
		// Encode "upoReferenceNumber" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "upoReferenceNumber",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.UpoReferenceNumber); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearer(ctx, APIV2SessionsReferenceNumberUpoUpoReferenceNumberGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAPIV2SessionsReferenceNumberUpoUpoReferenceNumberGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// APIV2TestdataAttachmentPost invokes POST /api/v2/testdata/attachment operation.
//
// Dodaje możliwość wysyłania faktur z załącznikiem przez wskazany podmiot.
//
// POST /api/v2/testdata/attachment
func (c *Client) APIV2TestdataAttachmentPost(ctx context.Context, request OptAttachmentPermissionGrantRequest) (APIV2TestdataAttachmentPostRes, error) {
	res, err := c.sendAPIV2TestdataAttachmentPost(ctx, request)
	return res, err
}

func (c *Client) sendAPIV2TestdataAttachmentPost(ctx context.Context, request OptAttachmentPermissionGrantRequest) (res APIV2TestdataAttachmentPostRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/v2/testdata/attachment"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAPIV2TestdataAttachmentPostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAPIV2TestdataAttachmentPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// APIV2TestdataAttachmentRevokePost invokes POST /api/v2/testdata/attachment/revoke operation.
//
// Odbiera możliwość wysyłania faktur z załącznikiem przez wskazany podmiot.
//
// POST /api/v2/testdata/attachment/revoke
func (c *Client) APIV2TestdataAttachmentRevokePost(ctx context.Context, request OptAttachmentPermissionRevokeRequest) (APIV2TestdataAttachmentRevokePostRes, error) {
	res, err := c.sendAPIV2TestdataAttachmentRevokePost(ctx, request)
	return res, err
}

func (c *Client) sendAPIV2TestdataAttachmentRevokePost(ctx context.Context, request OptAttachmentPermissionRevokeRequest) (res APIV2TestdataAttachmentRevokePostRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/v2/testdata/attachment/revoke"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAPIV2TestdataAttachmentRevokePostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAPIV2TestdataAttachmentRevokePostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// APIV2TestdataLimitsContextSessionDelete invokes DELETE /api/v2/testdata/limits/context/session operation.
//
// Przywraca wartości aktualnie obowiązujących limitów sesji dla bieżącego kontekstu do
// wartości domyślnych. **Tylko na środowiskach testowych.**.
//
// DELETE /api/v2/testdata/limits/context/session
func (c *Client) APIV2TestdataLimitsContextSessionDelete(ctx context.Context) (APIV2TestdataLimitsContextSessionDeleteRes, error) {
	res, err := c.sendAPIV2TestdataLimitsContextSessionDelete(ctx)
	return res, err
}

func (c *Client) sendAPIV2TestdataLimitsContextSessionDelete(ctx context.Context) (res APIV2TestdataLimitsContextSessionDeleteRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/v2/testdata/limits/context/session"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearer(ctx, APIV2TestdataLimitsContextSessionDeleteOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAPIV2TestdataLimitsContextSessionDeleteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// APIV2TestdataLimitsContextSessionPost invokes POST /api/v2/testdata/limits/context/session operation.
//
// Zmienia wartości aktualnie obowiązujących limitów sesji dla bieżącego kontekstu. **Tylko na
// środowiskach testowych.**.
//
// POST /api/v2/testdata/limits/context/session
func (c *Client) APIV2TestdataLimitsContextSessionPost(ctx context.Context, request OptSetSessionLimitsRequest) (APIV2TestdataLimitsContextSessionPostRes, error) {
	res, err := c.sendAPIV2TestdataLimitsContextSessionPost(ctx, request)
	return res, err
}

func (c *Client) sendAPIV2TestdataLimitsContextSessionPost(ctx context.Context, request OptSetSessionLimitsRequest) (res APIV2TestdataLimitsContextSessionPostRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/v2/testdata/limits/context/session"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAPIV2TestdataLimitsContextSessionPostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearer(ctx, APIV2TestdataLimitsContextSessionPostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAPIV2TestdataLimitsContextSessionPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// APIV2TestdataLimitsSubjectCertificateDelete invokes DELETE /api/v2/testdata/limits/subject/certificate operation.
//
// Przywraca wartości aktualnie obowiązujących limitów certyfikatów dla bieżącego podmiotu do
// wartości domyślnych. **Tylko na środowiskach testowych.**.
//
// DELETE /api/v2/testdata/limits/subject/certificate
func (c *Client) APIV2TestdataLimitsSubjectCertificateDelete(ctx context.Context) (APIV2TestdataLimitsSubjectCertificateDeleteRes, error) {
	res, err := c.sendAPIV2TestdataLimitsSubjectCertificateDelete(ctx)
	return res, err
}

func (c *Client) sendAPIV2TestdataLimitsSubjectCertificateDelete(ctx context.Context) (res APIV2TestdataLimitsSubjectCertificateDeleteRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/v2/testdata/limits/subject/certificate"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearer(ctx, APIV2TestdataLimitsSubjectCertificateDeleteOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAPIV2TestdataLimitsSubjectCertificateDeleteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// APIV2TestdataLimitsSubjectCertificatePost invokes POST /api/v2/testdata/limits/subject/certificate operation.
//
// Zmienia wartości aktualnie obowiązujących limitów certyfikatów dla bieżącego podmiotu.
// **Tylko na środowiskach testowych.**.
//
// POST /api/v2/testdata/limits/subject/certificate
func (c *Client) APIV2TestdataLimitsSubjectCertificatePost(ctx context.Context, request OptSetSubjectLimitsRequest) (APIV2TestdataLimitsSubjectCertificatePostRes, error) {
	res, err := c.sendAPIV2TestdataLimitsSubjectCertificatePost(ctx, request)
	return res, err
}

func (c *Client) sendAPIV2TestdataLimitsSubjectCertificatePost(ctx context.Context, request OptSetSubjectLimitsRequest) (res APIV2TestdataLimitsSubjectCertificatePostRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/v2/testdata/limits/subject/certificate"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAPIV2TestdataLimitsSubjectCertificatePostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearer(ctx, APIV2TestdataLimitsSubjectCertificatePostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAPIV2TestdataLimitsSubjectCertificatePostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// APIV2TestdataPermissionsPost invokes POST /api/v2/testdata/permissions operation.
//
// Nadawanie uprawnień testowemu podmiotowi lub osobie fizycznej, a także w ich kontekście.
//
// POST /api/v2/testdata/permissions
func (c *Client) APIV2TestdataPermissionsPost(ctx context.Context, request OptTestDataPermissionsGrantRequest) (APIV2TestdataPermissionsPostRes, error) {
	res, err := c.sendAPIV2TestdataPermissionsPost(ctx, request)
	return res, err
}

func (c *Client) sendAPIV2TestdataPermissionsPost(ctx context.Context, request OptTestDataPermissionsGrantRequest) (res APIV2TestdataPermissionsPostRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/v2/testdata/permissions"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAPIV2TestdataPermissionsPostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAPIV2TestdataPermissionsPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// APIV2TestdataPermissionsRevokePost invokes POST /api/v2/testdata/permissions/revoke operation.
//
// Odbieranie uprawnień nadanych testowemu podmiotowi lub osobie fizycznej, a także w ich
// kontekście.
//
// POST /api/v2/testdata/permissions/revoke
func (c *Client) APIV2TestdataPermissionsRevokePost(ctx context.Context, request OptTestDataPermissionsRevokeRequest) (APIV2TestdataPermissionsRevokePostRes, error) {
	res, err := c.sendAPIV2TestdataPermissionsRevokePost(ctx, request)
	return res, err
}

func (c *Client) sendAPIV2TestdataPermissionsRevokePost(ctx context.Context, request OptTestDataPermissionsRevokeRequest) (res APIV2TestdataPermissionsRevokePostRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/v2/testdata/permissions/revoke"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAPIV2TestdataPermissionsRevokePostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAPIV2TestdataPermissionsRevokePostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// APIV2TestdataPersonPost invokes POST /api/v2/testdata/person operation.
//
// Tworzenie nowej osoby fizycznej, której system nadaje uprawnienia właścicielskie. Można
// również określić, czy osoba ta jest komornikiem – wówczas otrzyma odpowiednie uprawnienie
// egzekucyjne.
//
// POST /api/v2/testdata/person
func (c *Client) APIV2TestdataPersonPost(ctx context.Context, request OptPersonCreateRequest) (APIV2TestdataPersonPostRes, error) {
	res, err := c.sendAPIV2TestdataPersonPost(ctx, request)
	return res, err
}

func (c *Client) sendAPIV2TestdataPersonPost(ctx context.Context, request OptPersonCreateRequest) (res APIV2TestdataPersonPostRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/v2/testdata/person"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAPIV2TestdataPersonPostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAPIV2TestdataPersonPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// APIV2TestdataPersonRemovePost invokes POST /api/v2/testdata/person/remove operation.
//
// Usuwanie testowej osoby fizycznej. System automatycznie odbierze jej wszystkie uprawnienia.
//
// POST /api/v2/testdata/person/remove
func (c *Client) APIV2TestdataPersonRemovePost(ctx context.Context, request OptPersonRemoveRequest) (APIV2TestdataPersonRemovePostRes, error) {
	res, err := c.sendAPIV2TestdataPersonRemovePost(ctx, request)
	return res, err
}

func (c *Client) sendAPIV2TestdataPersonRemovePost(ctx context.Context, request OptPersonRemoveRequest) (res APIV2TestdataPersonRemovePostRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/v2/testdata/person/remove"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAPIV2TestdataPersonRemovePostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAPIV2TestdataPersonRemovePostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// APIV2TestdataRateLimitsDelete invokes DELETE /api/v2/testdata/rate-limits operation.
//
// Przywraca wartości aktualnie obowiązujących limitów żądań przesyłąnych do API dla
// bieżącego kontekstu do wartości domyślnych. **Tylko na środowiskach testowych.**.
//
// DELETE /api/v2/testdata/rate-limits
func (c *Client) APIV2TestdataRateLimitsDelete(ctx context.Context) (APIV2TestdataRateLimitsDeleteRes, error) {
	res, err := c.sendAPIV2TestdataRateLimitsDelete(ctx)
	return res, err
}

func (c *Client) sendAPIV2TestdataRateLimitsDelete(ctx context.Context) (res APIV2TestdataRateLimitsDeleteRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/v2/testdata/rate-limits"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearer(ctx, APIV2TestdataRateLimitsDeleteOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAPIV2TestdataRateLimitsDeleteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// APIV2TestdataRateLimitsPost invokes POST /api/v2/testdata/rate-limits operation.
//
// Zmienia wartości aktualnie obowiązujących limitów żądań przesyłąnych do API dla
// bieżącego kontekstu. **Tylko na środowiskach testowych.**.
//
// POST /api/v2/testdata/rate-limits
func (c *Client) APIV2TestdataRateLimitsPost(ctx context.Context, request OptSetRateLimitsRequest) (APIV2TestdataRateLimitsPostRes, error) {
	res, err := c.sendAPIV2TestdataRateLimitsPost(ctx, request)
	return res, err
}

func (c *Client) sendAPIV2TestdataRateLimitsPost(ctx context.Context, request OptSetRateLimitsRequest) (res APIV2TestdataRateLimitsPostRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/v2/testdata/rate-limits"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAPIV2TestdataRateLimitsPostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearer(ctx, APIV2TestdataRateLimitsPostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAPIV2TestdataRateLimitsPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// APIV2TestdataSubjectPost invokes POST /api/v2/testdata/subject operation.
//
// Tworzenie nowego podmiotu testowego. W przypadku grupy VAT i JST istnieje możliwość stworzenia
// jednostek podrzędnych. W wyniku takiego działania w systemie powstanie powiązanie między tymi
// podmiotami.
//
// POST /api/v2/testdata/subject
func (c *Client) APIV2TestdataSubjectPost(ctx context.Context, request OptSubjectCreateRequest) (APIV2TestdataSubjectPostRes, error) {
	res, err := c.sendAPIV2TestdataSubjectPost(ctx, request)
	return res, err
}

func (c *Client) sendAPIV2TestdataSubjectPost(ctx context.Context, request OptSubjectCreateRequest) (res APIV2TestdataSubjectPostRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/v2/testdata/subject"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAPIV2TestdataSubjectPostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAPIV2TestdataSubjectPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// APIV2TestdataSubjectRemovePost invokes POST /api/v2/testdata/subject/remove operation.
//
// Usuwanie podmiotu testowego. W przypadku grupy VAT i JST usunięte zostaną również jednostki
// podrzędne.
//
// POST /api/v2/testdata/subject/remove
func (c *Client) APIV2TestdataSubjectRemovePost(ctx context.Context, request OptSubjectRemoveRequest) (APIV2TestdataSubjectRemovePostRes, error) {
	res, err := c.sendAPIV2TestdataSubjectRemovePost(ctx, request)
	return res, err
}

func (c *Client) sendAPIV2TestdataSubjectRemovePost(ctx context.Context, request OptSubjectRemoveRequest) (res APIV2TestdataSubjectRemovePostRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/v2/testdata/subject/remove"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAPIV2TestdataSubjectRemovePostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAPIV2TestdataSubjectRemovePostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// APIV2TokensGet invokes GET /api/v2/tokens operation.
//
// **Sortowanie:**
// - dateCreated (Desc).
//
// GET /api/v2/tokens
func (c *Client) APIV2TokensGet(ctx context.Context, params APIV2TokensGetParams) (APIV2TokensGetRes, error) {
	res, err := c.sendAPIV2TokensGet(ctx, params)
	return res, err
}

func (c *Client) sendAPIV2TokensGet(ctx context.Context, params APIV2TokensGetParams) (res APIV2TokensGetRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/v2/tokens"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "status" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "status",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if params.Status != nil {
				return e.EncodeArray(func(e uri.Encoder) error {
					for i, item := range params.Status {
						if err := func() error {
							return e.EncodeValue(conv.StringToString(string(item)))
						}(); err != nil {
							return errors.Wrapf(err, "[%d]", i)
						}
					}
					return nil
				})
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "description" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "description",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Description.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "authorIdentifier" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "authorIdentifier",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.AuthorIdentifier.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "authorIdentifierType" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "authorIdentifierType",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.AuthorIdentifierType.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "pageSize" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "pageSize",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "x-continuation-token",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XContinuationToken.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearer(ctx, APIV2TokensGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAPIV2TokensGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// APIV2TokensPost invokes POST /api/v2/tokens operation.
//
// Zwraca token, który może być użyty do uwierzytelniania się w KSeF.
// Token może być generowany tylko w kontekście NIP lub identyfikatora wewnętrznego. Jest
// zwracany tylko raz. Zaczyna być aktywny w momencie gdy jego status zmieni się na `Active`.
//
// POST /api/v2/tokens
func (c *Client) APIV2TokensPost(ctx context.Context, request OptGenerateTokenRequest) (APIV2TokensPostRes, error) {
	res, err := c.sendAPIV2TokensPost(ctx, request)
	return res, err
}

func (c *Client) sendAPIV2TokensPost(ctx context.Context, request OptGenerateTokenRequest) (res APIV2TokensPostRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/v2/tokens"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAPIV2TokensPostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearer(ctx, APIV2TokensPostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAPIV2TokensPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// APIV2TokensReferenceNumberDelete invokes DELETE /api/v2/tokens/{referenceNumber} operation.
//
// Unieważniony token nie pozwoli już na uwierzytelnienie się za jego pomocą. Unieważnienie nie
// może zostać cofnięte.
//
// DELETE /api/v2/tokens/{referenceNumber}
func (c *Client) APIV2TokensReferenceNumberDelete(ctx context.Context, params APIV2TokensReferenceNumberDeleteParams) (APIV2TokensReferenceNumberDeleteRes, error) {
	res, err := c.sendAPIV2TokensReferenceNumberDelete(ctx, params)
	return res, err
}

func (c *Client) sendAPIV2TokensReferenceNumberDelete(ctx context.Context, params APIV2TokensReferenceNumberDeleteParams) (res APIV2TokensReferenceNumberDeleteRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/api/v2/tokens/"
	{
		// Encode "referenceNumber" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "referenceNumber",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.ReferenceNumber); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearer(ctx, APIV2TokensReferenceNumberDeleteOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAPIV2TokensReferenceNumberDeleteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// APIV2TokensReferenceNumberGet invokes GET /api/v2/tokens/{referenceNumber} operation.
//
// Pobranie statusu tokena.
//
// GET /api/v2/tokens/{referenceNumber}
func (c *Client) APIV2TokensReferenceNumberGet(ctx context.Context, params APIV2TokensReferenceNumberGetParams) (APIV2TokensReferenceNumberGetRes, error) {
	res, err := c.sendAPIV2TokensReferenceNumberGet(ctx, params)
	return res, err
}

func (c *Client) sendAPIV2TokensReferenceNumberGet(ctx context.Context, params APIV2TokensReferenceNumberGetParams) (res APIV2TokensReferenceNumberGetRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/api/v2/tokens/"
	{
		// Encode "referenceNumber" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "referenceNumber",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.ReferenceNumber); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearer(ctx, APIV2TokensReferenceNumberGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAPIV2TokensReferenceNumberGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}
