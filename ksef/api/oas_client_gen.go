// Code generated by ogen, DO NOT EDIT.

package api

import (
	"context"
	"net/url"
	"strings"

	"github.com/go-faster/errors"
	"github.com/ogen-go/ogen/conv"
	ht "github.com/ogen-go/ogen/http"
	"github.com/ogen-go/ogen/ogenerrors"
	"github.com/ogen-go/ogen/uri"
)

func trimTrailingSlashes(u *url.URL) {
	u.Path = strings.TrimRight(u.Path, "/")
	u.RawPath = strings.TrimRight(u.RawPath, "/")
}

// Invoker invokes operations described by OpenAPI v3 specification.
type Invoker interface {
	// AuthChallengePost invokes POST /auth/challenge operation.
	//
	// Generuje unikalny challenge wymagany w kolejnym kroku operacji uwierzytelnienia.
	//
	// POST /auth/challenge
	AuthChallengePost(ctx context.Context) (AuthChallengePostRes, error)
	// AuthKsefTokenPost invokes POST /auth/ksef-token operation.
	//
	// Rozpoczyna operację uwierzytelniania z wykorzystaniem wcześniej wygenerowanego tokena KSeF.
	// Token KSeF wraz z timestampem ze wcześniej wygenerowanego challenge'a (w formacie
	// ```token|timestamp```) powinien zostać zaszyfrowany dedykowanym do tego celu kluczem publicznym.
	// - Timestamp powinien zostać przekazany jako **liczba milisekund od 1 stycznia 1970 roku (Unix
	// timestamp)**.
	// - Algorytm szyfrowania: **RSA-OAEP (z użyciem SHA-256 jako funkcji skrótu)**.
	//
	// POST /auth/ksef-token
	AuthKsefTokenPost(ctx context.Context, request OptInitTokenAuthenticationRequest) (AuthKsefTokenPostRes, error)
	// AuthReferenceNumberGet invokes GET /auth/{referenceNumber} operation.
	//
	// Sprawdza bieżący status operacji uwierzytelniania dla podanego tokena.
	// Sposób uwierzytelnienia: `AuthenticationToken` otrzymany przy rozpoczęciu operacji
	// uwierzytelniania.
	//
	// GET /auth/{referenceNumber}
	AuthReferenceNumberGet(ctx context.Context, params AuthReferenceNumberGetParams) (AuthReferenceNumberGetRes, error)
	// AuthSessionsCurrentDelete invokes DELETE /auth/sessions/current operation.
	//
	// Unieważnia sesję powiązaną z tokenem użytym do wywołania tej operacji.
	// Unieważnienie sesji sprawia, że powiązany z nią refresh token przestaje działać i nie można
	// już za jego pomocą uzyskać kolejnych access tokenów.
	// **Aktywne access tokeny działają do czasu minięcia ich termin ważności.**
	// Sposób uwierzytelnienia: `RefreshToken` lub `AccessToken`.
	//
	// DELETE /auth/sessions/current
	AuthSessionsCurrentDelete(ctx context.Context) (AuthSessionsCurrentDeleteRes, error)
	// AuthSessionsGet invokes GET /auth/sessions operation.
	//
	// Zwraca listę aktywnych sesji uwierzytelnienia.
	// **Sortowanie:**
	// - startDate (Desc).
	//
	// GET /auth/sessions
	AuthSessionsGet(ctx context.Context, params AuthSessionsGetParams) (AuthSessionsGetRes, error)
	// AuthSessionsReferenceNumberDelete invokes DELETE /auth/sessions/{referenceNumber} operation.
	//
	// Unieważnia sesję o podanym numerze referencyjnym.
	// Unieważnienie sesji sprawia, że powiązany z nią refresh token przestaje działać i nie można
	// już za jego pomocą uzyskać kolejnych access tokenów.
	// **Aktywne access tokeny działają do czasu minięcia ich termin ważności.**.
	//
	// DELETE /auth/sessions/{referenceNumber}
	AuthSessionsReferenceNumberDelete(ctx context.Context, params AuthSessionsReferenceNumberDeleteParams) (AuthSessionsReferenceNumberDeleteRes, error)
	// AuthTokenRedeemPost invokes POST /auth/token/redeem operation.
	//
	// Pobiera parę tokenów (access token i refresh token) wygenerowanych w ramach pozytywnie
	// zakończonego procesu uwierzytelniania.
	// **Tokeny można pobrać tylko raz.**
	// Sposób uwierzytelnienia: `AuthenticationToken` otrzymany przy rozpoczęciu operacji
	// uwierzytelniania.
	//
	// POST /auth/token/redeem
	AuthTokenRedeemPost(ctx context.Context) (AuthTokenRedeemPostRes, error)
	// AuthTokenRefreshPost invokes POST /auth/token/refresh operation.
	//
	// Generuje nowy token dostępu na podstawie ważnego refresh tokena.
	// Sposób uwierzytelnienia: `RefreshToken`.
	//
	// POST /auth/token/refresh
	AuthTokenRefreshPost(ctx context.Context) (AuthTokenRefreshPostRes, error)
	// AuthXadesSignaturePost invokes POST /auth/xades-signature operation.
	//
	// Rozpoczyna operację uwierzytelniania za pomocą dokumentu XML podpisanego podpisem elektronicznym
	// XAdES.
	// > Więcej informacji:
	// > - [Przygotowanie dokumentu XML](https://github.com/CIRFMF/ksef-docs/blob/main/uwierzytelnianie.
	// md#1-przygotowanie-dokumentu-xml-authtokenrequest)
	// > - [Podpis dokumentu XML](https://github.com/CIRFMF/ksef-docs/blob/main/uwierzytelnianie.
	// md#2-podpisanie-dokumentu-xades)
	// > - [Schemat XSD](/docs/v2/schemas/authv2.xsd).
	//
	// POST /auth/xades-signature
	AuthXadesSignaturePost(ctx context.Context, request AuthXadesSignaturePostReq, params AuthXadesSignaturePostParams) (AuthXadesSignaturePostRes, error)
	// CertificatesCertificateSerialNumberRevokePost invokes POST /certificates/{certificateSerialNumber}/revoke operation.
	//
	// Unieważnia certyfikat o podanym numerze seryjnym.
	//
	// POST /certificates/{certificateSerialNumber}/revoke
	CertificatesCertificateSerialNumberRevokePost(ctx context.Context, request OptRevokeCertificateRequest, params CertificatesCertificateSerialNumberRevokePostParams) (CertificatesCertificateSerialNumberRevokePostRes, error)
	// CertificatesEnrollmentsDataGet invokes GET /certificates/enrollments/data operation.
	//
	// Zwraca dane wymagane do przygotowania wniosku certyfikacyjnego PKCS#10.
	// Dane te są zwracane na podstawie certyfikatu użytego w procesie uwierzytelnienia i identyfikują
	// podmiot, który składa wniosek o certyfikat.
	// > Więcej informacji:
	// > - [Pobranie danych do wniosku certyfikacyjnego](https://github.
	// com/CIRFMF/ksef-docs/blob/main/certyfikaty-KSeF.md#2-pobranie-danych-do-wniosku-certyfikacyjnego)
	// > - [Przygotowanie wniosku](https://github.com/CIRFMF/ksef-docs/blob/main/certyfikaty-KSeF.
	// md#3-przygotowanie-csr-certificate-signing-request).
	//
	// GET /certificates/enrollments/data
	CertificatesEnrollmentsDataGet(ctx context.Context) (CertificatesEnrollmentsDataGetRes, error)
	// CertificatesEnrollmentsPost invokes POST /certificates/enrollments operation.
	//
	// Przyjmuje wniosek certyfikacyjny i rozpoczyna jego przetwarzanie.
	// Dozwolone typy kluczy prywatnych:
	// - RSA (OID: 1.2.840.113549.1.1.1), długość klucza równa 2048 bitów,
	// - EC (klucze oparte na krzywych eliptycznych, OID: 1.2.840.10045.2.1), krzywa NIST P-256
	// (secp256r1)
	// Zalecane jest stosowanie kluczy EC.
	// Dozwolone algorytmy podpisu:
	// - RSA PKCS#1 v1.5,
	// - RSA PSS,
	// - ECDSA (format podpisu zgodny z RFC 3279)
	// Dozwolone funkcje skrótu użyte do podpisu CSR:
	// - SHA1,
	// - SHA256,
	// - SHA384,
	// - SHA512
	// > Więcej informacji:
	// > - [Wysłanie wniosku certyfikacyjnego](https://github.
	// com/CIRFMF/ksef-docs/blob/main/certyfikaty-KSeF.md#4-wys%C5%82anie-wniosku-certyfikacyjnego).
	//
	// POST /certificates/enrollments
	CertificatesEnrollmentsPost(ctx context.Context, request OptEnrollCertificateRequest) (CertificatesEnrollmentsPostRes, error)
	// CertificatesEnrollmentsReferenceNumberGet invokes GET /certificates/enrollments/{referenceNumber} operation.
	//
	// Zwraca informacje o statusie wniosku certyfikacyjnego.
	//
	// GET /certificates/enrollments/{referenceNumber}
	CertificatesEnrollmentsReferenceNumberGet(ctx context.Context, params CertificatesEnrollmentsReferenceNumberGetParams) (CertificatesEnrollmentsReferenceNumberGetRes, error)
	// CertificatesLimitsGet invokes GET /certificates/limits operation.
	//
	// Zwraca informacje o limitach certyfikatów oraz informacje czy użytkownik może zawnioskować o
	// certyfikat KSeF.
	//
	// GET /certificates/limits
	CertificatesLimitsGet(ctx context.Context) (CertificatesLimitsGetRes, error)
	// CertificatesQueryPost invokes POST /certificates/query operation.
	//
	// Zwraca listę certyfikatów spełniających podane kryteria wyszukiwania.
	// W przypadku braku podania kryteriów wyszukiwania zwrócona zostanie nieprzefiltrowana lista.
	// **Sortowanie:**
	// - requestDate (Desc).
	//
	// POST /certificates/query
	CertificatesQueryPost(ctx context.Context, request OptQueryCertificatesRequest, params CertificatesQueryPostParams) (CertificatesQueryPostRes, error)
	// CertificatesRetrievePost invokes POST /certificates/retrieve operation.
	//
	// Zwraca certyfikaty o podanych numerach seryjnych w formacie DER zakodowanym w Base64.
	//
	// POST /certificates/retrieve
	CertificatesRetrievePost(ctx context.Context, request OptRetrieveCertificatesRequest) (CertificatesRetrievePostRes, error)
	// InvoicesExportsPost invokes POST /invoices/exports operation.
	//
	// Rozpoczyna asynchroniczny proces wyszukiwania faktur w systemie KSeF na podstawie przekazanych
	// filtrów oraz przygotowania ich w formie zaszyfrowanej paczki.
	// Wymagane jest przekazanie informacji o szyfrowaniu w polu <b>Encryption</b>, które służą do
	// zabezpieczenia przygotowanej paczki z fakturami.
	// Maksymalnie można uruchomić 10 równoczesnych eksportów w zalogowanym kontekście.
	// System pobiera faktury rosnąco według daty określonej w filtrze (Invoicing, Issue,
	// PermanentStorage) i dodaje faktury(nazwa pliku: <b>{ksefNumber}.xml</b>) do paczki aż do
	// osiągnięcia jednego z poniższych limitów:
	// * Limit liczby faktur: 10 000 sztuk
	// * Limit rozmiaru danych(skompresowanych): 1GB
	// Paczka eksportu zawiera dodatkowy plik z metadanymi faktur w formacie JSON (`_metadata.json`).
	// Zawartość pliku to
	// obiekt z tablicą <b>invoices</b>, gdzie każdy element jest obiektem typu <b>InvoiceMetadata</b>
	// (taki jak zwracany przez endpoint `POST /invoices/query/metadata`).
	// <b>Plik z metadanymi(_metadata.json) nie jest wliczany do limitów algorytmu budowania paczki</b>.
	// `Do realizacji pobierania przyrostowego należy stosować filtrowanie po dacie PermanentStorage`.
	// **Sortowanie:**
	// - permanentStorageDate | invoicingDate | issueDate (Asc) - pole wybierane na podstawie filtrów
	// **Wymagane uprawnienia**: `InvoiceRead`.
	//
	// POST /invoices/exports
	InvoicesExportsPost(ctx context.Context, request OptInvoiceExportRequest) (InvoicesExportsPostRes, error)
	// InvoicesExportsReferenceNumberGet invokes GET /invoices/exports/{referenceNumber} operation.
	//
	// Paczka faktur jest dzielona na części o maksymalnym rozmiarze 50 MB. Każda część jest
	// zaszyfrowana algorytmem AES-256-CBC z dopełnieniem PKCS#7, przy użyciu klucza symetrycznego
	// przekazanego podczas inicjowania eksportu.
	// W przypadku ucięcia wyniku eksportu z powodu przekroczenia limitów, zwracana jest flaga
	// <b>IsTruncated = true</b> oraz odpowiednia data, którą należy wykorzystać do wykonania
	// kolejnego eksportu, aż do momentu, gdy flaga <b>IsTruncated = false</b>.
	// **Sortowanie:**
	// - permanentStorageDate | invoicingDate | issueDate (Asc) - pole wybierane na podstawie filtrów
	// **Wymagane uprawnienia**: `InvoiceRead`.
	//
	// GET /invoices/exports/{referenceNumber}
	InvoicesExportsReferenceNumberGet(ctx context.Context, params InvoicesExportsReferenceNumberGetParams) (InvoicesExportsReferenceNumberGetRes, error)
	// InvoicesKsefKsefNumberGet invokes GET /invoices/ksef/{ksefNumber} operation.
	//
	// Zwraca fakturę o podanym numerze KSeF.
	// **Wymagane uprawnienia**: `InvoiceRead`.
	//
	// GET /invoices/ksef/{ksefNumber}
	InvoicesKsefKsefNumberGet(ctx context.Context, params InvoicesKsefKsefNumberGetParams) (InvoicesKsefKsefNumberGetRes, error)
	// InvoicesQueryMetadataPost invokes POST /invoices/query/metadata operation.
	//
	// Zwraca metadane faktur spełniających filtry.
	// Limit techniczny: ≤ 10 000 rekordów na zestaw filtrów, po jego osiągnięciu <b>isTruncated =
	// true</b> i należy ponownie ustawić <b>dateRange</b>, używając ostatniej daty z wyników (tj.
	// ustawić from/to - w zależności od kierunku sortowania, od daty ostatniego zwróconego rekordu)
	// oraz wyzerować <b>pageOffset</b>.
	// `Do scenariusza przyrostowego należy używać daty PermanentStorage oraz kolejność sortowania
	// Asc`.
	// <b>Scenariusz pobierania przyrostowego (skrót):</b>
	// * Gdy <b>hasMore = false</b>, należy zakończyć,
	// * Gdy <b>hasMore = true</b> i <b>isTruncated = false</b>, należy zwiększyć <b>pageOffset</b>,
	// * Gdy <b>hasMore = true</b> i <b>isTruncated = true</b>, należy zawęzić <b>dateRange</b>
	// (ustawić from od daty ostatniego rekordu), wyzerować <b>pageOffset</b> i kontynuować
	// **Sortowanie:**
	// - permanentStorageDate | invoicingDate | issueDate (Asc | Desc) - pole wybierane na podstawie
	// filtrów
	// **Wymagane uprawnienia**: `InvoiceRead`.
	//
	// POST /invoices/query/metadata
	InvoicesQueryMetadataPost(ctx context.Context, request OptInvoiceQueryFilters, params InvoicesQueryMetadataPostParams) (InvoicesQueryMetadataPostRes, error)
	// LimitsContextGet invokes GET /limits/context operation.
	//
	// Zwraca wartości aktualnie obowiązujących limitów dla bieżącego kontekstu.
	//
	// GET /limits/context
	LimitsContextGet(ctx context.Context) (LimitsContextGetRes, error)
	// LimitsSubjectGet invokes GET /limits/subject operation.
	//
	// Zwraca wartości aktualnie obowiązujących limitów dla bieżącego podmiotu.
	//
	// GET /limits/subject
	LimitsSubjectGet(ctx context.Context) (LimitsSubjectGetRes, error)
	// PeppolQueryGet invokes GET /peppol/query operation.
	//
	// Zwraca listę dostawców usług Peppol zarejestrowanych w systemie.
	// **Sortowanie:**
	// - dateCreated (Desc)
	// - id (Asc).
	//
	// GET /peppol/query
	PeppolQueryGet(ctx context.Context, params PeppolQueryGetParams) (PeppolQueryGetRes, error)
	// PermissionsAttachmentsStatusGet invokes GET /permissions/attachments/status operation.
	//
	// Sprawdzenie czy obecny kontekst posiada zgodę na wystawianie faktur z załącznikiem.
	// **Wymagane uprawnienia**: `CredentialsManage`, `CredentialsRead`.
	//
	// GET /permissions/attachments/status
	PermissionsAttachmentsStatusGet(ctx context.Context) (PermissionsAttachmentsStatusGetRes, error)
	// PermissionsAuthorizationsGrantsPermissionIdDelete invokes DELETE /permissions/authorizations/grants/{permissionId} operation.
	//
	// Metoda pozwala na odebranie uprawnienia podmiotowego o wskazanym identyfikatorze.
	// Wymagane jest wcześniejsze odczytanie uprawnień w celu uzyskania
	// identyfikatora uprawnienia, które ma zostać odebrane.
	// > Więcej informacji:
	// > - [Odbieranie uprawnień](https://github.com/CIRFMF/ksef-docs/blob/main/uprawnienia.
	// md#odebranie-uprawnie%C5%84-podmiotowych)
	// **Wymagane uprawnienia**: `CredentialsManage`.
	//
	// DELETE /permissions/authorizations/grants/{permissionId}
	PermissionsAuthorizationsGrantsPermissionIdDelete(ctx context.Context, params PermissionsAuthorizationsGrantsPermissionIdDeleteParams) (PermissionsAuthorizationsGrantsPermissionIdDeleteRes, error)
	// PermissionsAuthorizationsGrantsPost invokes POST /permissions/authorizations/grants operation.
	//
	// Metoda pozwala na nadanie jednego z uprawnień podmiotowych do obsługi podmiotu kontekstu
	// podmiotowi wskazanemu w żądaniu.
	// > Więcej informacji:
	// > - [Nadawanie uprawnień](https://github.com/CIRFMF/ksef-docs/blob/main/uprawnienia.
	// md#nadanie-uprawnie%C5%84-podmiotowych)
	// **Wymagane uprawnienia**: `CredentialsManage`.
	//
	// POST /permissions/authorizations/grants
	PermissionsAuthorizationsGrantsPost(ctx context.Context, request OptEntityAuthorizationPermissionsGrantRequest) (PermissionsAuthorizationsGrantsPostRes, error)
	// PermissionsCommonGrantsPermissionIdDelete invokes DELETE /permissions/common/grants/{permissionId} operation.
	//
	// Metoda pozwala na odebranie uprawnienia o wskazanym identyfikatorze.
	// Wymagane jest wcześniejsze odczytanie uprawnień w celu uzyskania
	// identyfikatora uprawnienia, które ma zostać odebrane.
	// > Więcej informacji:
	// > - [Odbieranie uprawnień](https://github.com/CIRFMF/ksef-docs/blob/main/uprawnienia.
	// md#odebranie-uprawnie%C5%84)
	// **Wymagane uprawnienia**: `CredentialsManage`, `VatUeManage`, `SubunitManage`.
	//
	// DELETE /permissions/common/grants/{permissionId}
	PermissionsCommonGrantsPermissionIdDelete(ctx context.Context, params PermissionsCommonGrantsPermissionIdDeleteParams) (PermissionsCommonGrantsPermissionIdDeleteRes, error)
	// PermissionsEntitiesGrantsPost invokes POST /permissions/entities/grants operation.
	//
	// Metoda pozwala na nadanie podmiotowi wskazanemu w żądaniu uprawnień do obsługi faktur podmiotu
	// kontekstu.
	// W żądaniu określane są nadawane uprawnienia ze zbioru:
	// - **InvoiceWrite** – wystawianie faktur
	// - **InvoiceRead** – przeglądanie faktur
	// Metoda pozwala na wybór dowolnej kombinacji powyższych uprawnień.
	// Dla każdego uprawnienia może być ustawiona flaga **canDelegate**, mówiąca o możliwości jego
	// dalszego przekazywania poprzez nadawanie w sposób pośredni.
	// > Więcej informacji:
	// > - [Nadawanie uprawnień](https://github.com/CIRFMF/ksef-docs/blob/main/uprawnienia.
	// md#nadanie-podmiotom-uprawnie%C5%84-do-obs%C5%82ugi-faktur)
	// **Wymagane uprawnienia**: `CredentialsManage`.
	//
	// POST /permissions/entities/grants
	PermissionsEntitiesGrantsPost(ctx context.Context, request OptEntityPermissionsGrantRequest) (PermissionsEntitiesGrantsPostRes, error)
	// PermissionsEuEntitiesAdministrationGrantsPost invokes POST /permissions/eu-entities/administration/grants operation.
	//
	// Metoda pozwala na nadanie wskazanemu w żądaniu podmiotowi lub osobie fizycznej uprawnień
	// administratora w kontekście złożonym z identyfikatora NIP podmiotu kontekstu bieżącego oraz
	// numeru VAT UE podmiotu unijnego wskazanego w żądaniu.
	// Wraz z utworzeniem administratora podmiotu unijnego tworzony jest kontekst złożony składający
	// się z numeru NIP podmiotu kontekstu logowania oraz wskazanego numeru identyfikacyjnego VAT UE
	// podmiotu unijnego.
	// W żądaniu podaje się również nazwę i adres podmiotu unijnego.
	// Jedynym sposobem identyfikacji uprawnianego jest odcisk palca certyfikatu kwalifikowanego:
	// - certyfikat podpisu elektronicznego dla osób fizycznych
	// - certyfikat pieczęci elektronicznej dla podmiotów
	// Uprawnienia administratora podmiotu unijnego obejmują:
	// - **VatEuManage** – zarządzanie uprawnieniami w ramach podmiotu unijnego
	// - **InvoiceWrite** – wystawianie faktur
	// - **InvoiceRead** – przeglądanie faktur
	// - **Introspection** – przeglądanie historii sesji
	// Metoda automatycznie nadaje wszystkie powyższe uprawnienia, bez konieczności ich wskazywania w
	// żądaniu.
	// > Więcej informacji:
	// > - [Nadawanie uprawnień](https://github.com/CIRFMF/ksef-docs/blob/main/uprawnienia.
	// md#nadanie-uprawnie%C5%84-administratora-podmiotu-unijnego)
	// **Wymagane uprawnienia**: `CredentialsManage`.
	//
	// POST /permissions/eu-entities/administration/grants
	PermissionsEuEntitiesAdministrationGrantsPost(ctx context.Context, request OptEuEntityAdministrationPermissionsGrantRequest) (PermissionsEuEntitiesAdministrationGrantsPostRes, error)
	// PermissionsEuEntitiesGrantsPost invokes POST /permissions/eu-entities/grants operation.
	//
	// Metoda pozwala na nadanie wskazanemu w żądaniu podmiotowi lub osobie fizycznej uprawnień do
	// wystawiania i/lub przeglądania faktur w kontekście złożonym kontekstu bieżącego.
	// Jedynym sposobem identyfikacji uprawnianego jest odcisk palca certyfikatu kwalifikowanego:
	// - certyfikat podpisu elektronicznego dla osób fizycznych
	// - certyfikat pieczęci elektronicznej dla podmiotów
	// W żądaniu określane są nadawane uprawnienia ze zbioru:
	// - **InvoiceWrite** – wystawianie faktur
	// - **InvoiceRead** – przeglądanie faktur
	// Metoda pozwala na wybór dowolnej kombinacji powyższych uprawnień.
	// > Więcej informacji:
	// > - [Nadawanie uprawnień](https://github.com/CIRFMF/ksef-docs/blob/main/uprawnienia.
	// md#nadanie-uprawnie%C5%84-reprezentanta-podmiotu-unijnego)
	// **Wymagane uprawnienia**: `VatUeManage`.
	//
	// POST /permissions/eu-entities/grants
	PermissionsEuEntitiesGrantsPost(ctx context.Context, request OptEuEntityPermissionsGrantRequest) (PermissionsEuEntitiesGrantsPostRes, error)
	// PermissionsIndirectGrantsPost invokes POST /permissions/indirect/grants operation.
	//
	// Metoda pozwala na nadanie w sposób pośredni osobie wskazanej w żądaniu uprawnień do obsługi
	// faktur innego podmiotu – klienta.
	// Może to być jedna z możliwości:
	// - nadanie uprawnień generalnych – do obsługi wszystkich klientów
	// - nadanie uprawnień selektywnych – do obsługi wskazanego klienta
	// Uprawnienie selektywne może być nadane wyłącznie wtedy, gdy klient nadał wcześniej
	// podmiotowi bieżącego kontekstu dowolne uprawnienie z prawem do jego dalszego przekazywania
	// (patrz [POST /v2/permissions/entities/grants](/docs/v2/index.
	// html#tag/Nadawanie-uprawnien/paths/~1permissions~1entities~1grants/post)).
	// W żądaniu określane są nadawane uprawnienia ze zbioru:
	// - **InvoiceWrite** – wystawianie faktur
	// - **InvoiceRead** – przeglądanie faktur
	// Metoda pozwala na wybór dowolnej kombinacji powyższych uprawnień.
	// > Więcej informacji:
	// > - [Nadawanie uprawnień](https://github.com/CIRFMF/ksef-docs/blob/main/uprawnienia.
	// md#nadanie-uprawnie%C5%84-w-spos%C3%B3b-po%C5%9Bredni)
	// **Wymagane uprawnienia**: `CredentialsManage`.
	//
	// POST /permissions/indirect/grants
	PermissionsIndirectGrantsPost(ctx context.Context, request OptIndirectPermissionsGrantRequest) (PermissionsIndirectGrantsPostRes, error)
	// PermissionsOperationsReferenceNumberGet invokes GET /permissions/operations/{referenceNumber} operation.
	//
	// Zwraca status operacji asynchronicznej związanej z nadaniem lub odebraniem uprawnień.
	//
	// GET /permissions/operations/{referenceNumber}
	PermissionsOperationsReferenceNumberGet(ctx context.Context, params PermissionsOperationsReferenceNumberGetParams) (PermissionsOperationsReferenceNumberGetRes, error)
	// PermissionsPersonsGrantsPost invokes POST /permissions/persons/grants operation.
	//
	// Metoda pozwala na nadanie osobie wskazanej w żądaniu uprawnień do pracy w KSeF
	// w kontekście bieżącym.
	// W żądaniu określane są nadawane uprawnienia ze zbioru:
	// - **InvoiceWrite** – wystawianie faktur,
	// - **InvoiceRead** – przeglądanie faktur,
	// - **CredentialsManage** – zarządzanie uprawnieniami,
	// - **CredentialsRead** – przeglądanie uprawnień,
	// - **Introspection** – przeglądanie historii sesji i generowanie UPO,
	// - **SubunitManage** – zarządzanie jednostkami podrzędnymi,
	// - **EnforcementOperations** – wykonywanie operacji egzekucyjnych.
	// Metoda pozwala na wybór dowolnej kombinacji powyższych uprawnień.
	// Uprawnienie **EnforcementOperations** może być nadane wyłącznie wtedy,
	// gdy podmiot kontekstu ma rolę **EnforcementAuthority** (organ egzekucyjny)
	// lub **CourtBailiff** (komornik sądowy).
	// > Więcej informacji:
	// > - [Nadawanie uprawnień](https://github.com/CIRFMF/ksef-docs/blob/main/uprawnienia.
	// md#nadawanie-uprawnie%C5%84-osobom-fizycznym-do-pracy-w-ksef)
	// **Wymagane uprawnienia**: `CredentialsManage`.
	//
	// POST /permissions/persons/grants
	PermissionsPersonsGrantsPost(ctx context.Context, request OptPersonPermissionsGrantRequest) (PermissionsPersonsGrantsPostRes, error)
	// PermissionsQueryAuthorizationsGrantsPost invokes POST /permissions/query/authorizations/grants operation.
	//
	// Metoda pozwala na odczytanie uprawnień podmiotowych:
	// - otrzymanych przez podmiot bieżącego kontekstu
	// - nadanych przez podmiot bieżącego kontekstu
	// Wybór listy nadanych lub otrzymanych uprawnień odbywa się przy użyciu parametru **queryType**.
	// Uprawnienia zwracane przez operację obejmują:
	// - **SelfInvoicing** – wystawianie faktur w trybie samofakturowania
	// - **TaxRepresentative** – wykonywanie operacji przedstawiciela podatkowego
	// - **RRInvoicing** – wystawianie faktur VAT RR
	// - **PefInvoicing** – wystawianie faktur PEF
	// Odpowiedź może być filtrowana na podstawie następujących parametrów:
	// - **authorizingIdentifier** – identyfikator podmiotu uprawniającego (stosowane przy queryType =
	// Received)
	// - **authorizedIdentifier** – identyfikator podmiotu uprawnionego (stosowane przy queryType =
	// Granted)
	// - **permissionTypes** – lista rodzajów wyszukiwanych uprawnień
	// #### Stronicowanie wyników
	// Zapytanie zwraca **jedną stronę wyników** o numerze i rozmiarze podanym w ścieżce.
	// - Przy pierwszym wywołaniu należy ustawić parametr `pageOffset = 0`.
	// - Jeżeli dostępna jest kolejna strona wyników, w odpowiedzi pojawi się flaga **`hasMore`**.
	// - W takim przypadku można wywołać zapytanie ponownie z kolejnym numerem strony.
	// > Więcej informacji:
	// > - [Pobieranie listy uprawnień](https://github.com/CIRFMF/ksef-docs/blob/main/uprawnienia.
	// md#pobranie-listy-uprawnie%C5%84-podmiotowych-do-obs%C5%82ugi-faktur)
	// **Sortowanie:**
	// - startDate (Desc)
	// - id (Asc)
	// **Wymagane uprawnienia**: `CredentialsManage`, `CredentialsRead`, `PefInvoiceWrite`.
	//
	// POST /permissions/query/authorizations/grants
	PermissionsQueryAuthorizationsGrantsPost(ctx context.Context, request OptEntityAuthorizationPermissionsQueryRequest, params PermissionsQueryAuthorizationsGrantsPostParams) (PermissionsQueryAuthorizationsGrantsPostRes, error)
	// PermissionsQueryEntitiesRolesGet invokes GET /permissions/query/entities/roles operation.
	//
	// Metoda pozwala na **odczytanie listy ról podmiotu bieżącego kontekstu logowania**.
	// #### Role podmiotów zwracane przez operację:
	// - **CourtBailiff** – komornik sądowy
	// - **EnforcementAuthority** – organ egzekucyjny
	// - **LocalGovernmentUnit** – nadrzędna JST
	// - **LocalGovernmentSubUnit** – podrzędne JST
	// - **VatGroupUnit** – grupa VAT
	// - **VatGroupSubUnit** – członek grupy VAT
	// #### Stronicowanie wyników
	// Zapytanie zwraca **jedną stronę wyników** o numerze i rozmiarze podanym w ścieżce.
	// - Przy pierwszym wywołaniu należy ustawić parametr `pageOffset = 0`.
	// - Jeżeli dostępna jest kolejna strona wyników, w odpowiedzi pojawi się flaga **`hasMore`**.
	// - W takim przypadku można wywołać zapytanie ponownie z kolejnym numerem strony.
	// > Więcej informacji:
	// > - [Pobieranie listy ról](https://github.com/CIRFMF/ksef-docs/blob/main/uprawnienia.
	// md#pobranie-listy-r%C3%B3l-podmiotu)
	// **Sortowanie:**
	// - startDate (Desc)
	// - id (Asc)
	// **Wymagane uprawnienia**: `CredentialsManage`, `CredentialsRead`.
	//
	// GET /permissions/query/entities/roles
	PermissionsQueryEntitiesRolesGet(ctx context.Context, params PermissionsQueryEntitiesRolesGetParams) (PermissionsQueryEntitiesRolesGetRes, error)
	// PermissionsQueryEuEntitiesGrantsPost invokes POST /permissions/query/eu-entities/grants operation.
	//
	// Metoda pozwala na odczytanie uprawnień administratorów lub reprezentantów podmiotów unijnych:
	// - Jeżeli kontekstem logowania jest NIP, możliwe jest odczytanie uprawnień administratorów
	// podmiotów unijnych powiązanych z podmiotem bieżącego kontekstu, czyli takich, dla których
	// pierwszy człon kontekstu złożonego jest równy NIP-owi kontekstu logowania.
	// - Jeżeli kontekst logowania jest złożony (NIP-VAT UE), możliwe jest pobranie wszystkich
	// uprawnień administratorów i reprezentantów podmiotu w bieżącym kontekście złożonym.
	// Uprawnienia zwracane przez operację obejmują:
	// - **VatUeManage** – zarządzanie uprawnieniami w ramach podmiotu unijnego
	// - **InvoiceWrite** – wystawianie faktur
	// - **InvoiceRead** – przeglądanie faktur
	// - **Introspection** – przeglądanie historii sesji
	// Odpowiedź może być filtrowana na podstawie następujących parametrów:
	// - **vatUeIdentifier** – identyfikator podmiotu unijnego
	// - **authorizedFingerprintIdentifier** – odcisk palca certyfikatu uprawnionej osoby lub podmiotu
	// - **permissionTypes** – lista rodzajów wyszukiwanych uprawnień
	// #### Stronicowanie wyników
	// Zapytanie zwraca **jedną stronę wyników** o numerze i rozmiarze podanym w ścieżce.
	// - Przy pierwszym wywołaniu należy ustawić parametr `pageOffset = 0`.
	// - Jeżeli dostępna jest kolejna strona wyników, w odpowiedzi pojawi się flaga **`hasMore`**.
	// - W takim przypadku można wywołać zapytanie ponownie z kolejnym numerem strony.
	// > Więcej informacji:
	// > - [Pobieranie listy uprawnień](https://github.com/CIRFMF/ksef-docs/blob/main/uprawnienia.
	// md#pobranie-listy-uprawnie%C5%84-administrator%C3%B3w-lub-reprezentant%C3%B3w-podmiot%C3%B3w-unijnych-uprawnionych-do-samofakturowania)
	// **Sortowanie:**
	// - startDate (Desc)
	// - id (Asc)
	// **Wymagane uprawnienia**: `CredentialsManage`, `CredentialsRead`, `VatUeManage`.
	//
	// POST /permissions/query/eu-entities/grants
	PermissionsQueryEuEntitiesGrantsPost(ctx context.Context, request OptEuEntityPermissionsQueryRequest, params PermissionsQueryEuEntitiesGrantsPostParams) (PermissionsQueryEuEntitiesGrantsPostRes, error)
	// PermissionsQueryPersonalGrantsPost invokes POST /permissions/query/personal/grants operation.
	//
	// Metoda pozwala na odczytanie własnych uprawnień uwierzytelnionego klienta API w bieżącym
	// kontekście logowania.
	// W odpowiedzi przekazywane są następujące uprawnienia:
	// - nadane w sposób bezpośredni w bieżącym kontekście
	// - nadane przez podmiot nadrzędny
	// - nadane w sposób pośredni, jeżeli podmiot kontekstu logowania jest w uprawnieniu pośrednikiem
	// lub podmiotem docelowym
	// - nadane podmiotowi do obsługi faktur przez inny podmiot, jeśli podmiot uwierzytelniony ma w
	// bieżącym kontekście uprawnienia właścicielskie
	// Uprawnienia zwracane przez operację obejmują:
	// - **CredentialsManage** – zarządzanie uprawnieniami
	// - **CredentialsRead** – przeglądanie uprawnień
	// - **InvoiceWrite** – wystawianie faktur
	// - **InvoiceRead** – przeglądanie faktur
	// - **Introspection** – przeglądanie historii sesji
	// - **SubunitManage** – zarządzanie podmiotami podrzędnymi
	// - **EnforcementOperations** – wykonywanie operacji egzekucyjnych
	// - **VatEuManage** – zarządzanie uprawnieniami w ramach podmiotu unijnego
	// Odpowiedź może być filtrowana na podstawie następujących parametrów:
	// - **contextIdentifier** – identyfikator podmiotu, który nadał uprawnienie do obsługi faktur
	// - **targetIdentifier** – identyfikator podmiotu docelowego dla uprawnień nadanych pośrednio
	// - **permissionTypes** – lista rodzajów wyszukiwanych uprawnień
	// - **permissionState** – status uprawnienia
	// #### Stronicowanie wyników
	// Zapytanie zwraca **jedną stronę wyników** o numerze i rozmiarze podanym w ścieżce.
	// - Przy pierwszym wywołaniu należy ustawić parametr `pageOffset = 0`.
	// - Jeżeli dostępna jest kolejna strona wyników, w odpowiedzi pojawi się flaga **`hasMore`**.
	// - W takim przypadku można wywołać zapytanie ponownie z kolejnym numerem strony.
	// > Więcej informacji:
	// > - [Pobieranie listy uprawnień](https://github.com/CIRFMF/ksef-docs/blob/main/uprawnienia.
	// md#pobranie-listy-w%C5%82asnych-uprawnie%C5%84)
	// **Sortowanie:**
	// - startDate (Desc)
	// - id (Asc).
	//
	// POST /permissions/query/personal/grants
	PermissionsQueryPersonalGrantsPost(ctx context.Context, request OptPersonalPermissionsQueryRequest, params PermissionsQueryPersonalGrantsPostParams) (PermissionsQueryPersonalGrantsPostRes, error)
	// PermissionsQueryPersonsGrantsPost invokes POST /permissions/query/persons/grants operation.
	//
	// Metoda pozwala na odczytanie uprawnień nadanych osobie fizycznej lub podmiotowi.
	// Lista pobranych uprawnień może być dwóch rodzajów:
	// - Lista wszystkich uprawnień obowiązujących w bieżącym kontekście logowania (używana, gdy
	// administrator chce przejrzeć uprawnienia wszystkich użytkowników w bieżącym kontekście)
	// - Lista wszystkich uprawnień nadanych w bieżącym kontekście przez uwierzytelnionego klienta
	// API (używana, gdy administrator chce przejrzeć listę nadanych przez siebie uprawnień w
	// bieżącym kontekście)
	// Dla pierwszej listy (obowiązujących uprawnień) w odpowiedzi przekazywane są:
	// - osoby i podmioty mogące pracować w bieżącym kontekście z wyjątkiem osób uprawnionych w
	// sposób pośredni
	// - osoby uprawnione w sposób pośredni przez podmiot bieżącego kontekstu
	// Dla drugiej listy (nadanych uprawnień) w odpowiedzi przekazywane są:
	// - uprawnienia nadane w sposób bezpośredni do pracy w bieżącym kontekście lub w kontekście
	// jednostek podrzędnych
	// - uprawnienia nadane w sposób pośredni do obsługi klientów podmiotu bieżącego kontekstu
	// Uprawnienia zwracane przez operację obejmują:
	// - **CredentialsManage** – zarządzanie uprawnieniami
	// - **CredentialsRead** – przeglądanie uprawnień
	// - **InvoiceWrite** – wystawianie faktur
	// - **InvoiceRead** – przeglądanie faktur
	// - **Introspection** – przeglądanie historii sesji
	// - **SubunitManage** – zarządzanie podmiotami podrzędnymi
	// - **EnforcementOperations** – wykonywanie operacji egzekucyjnych
	// Odpowiedź może być filtrowana na podstawie parametrów:
	// - **authorIdentifier** – identyfikator osoby, która nadała uprawnienie
	// - **authorizedIdentifier** – identyfikator osoby lub podmiotu uprawnionego
	// - **targetIdentifier** – identyfikator podmiotu docelowego dla uprawnień nadanych pośrednio
	// - **permissionTypes** – lista rodzajów wyszukiwanych uprawnień
	// - **permissionState** – status uprawnienia
	// - **queryType** – typ zapytania określający, która z dwóch list ma zostać zwrócona
	// #### Stronicowanie wyników
	// Zapytanie zwraca **jedną stronę wyników** o numerze i rozmiarze podanym w ścieżce.
	// - Przy pierwszym wywołaniu należy ustawić parametr `pageOffset = 0`.
	// - Jeżeli dostępna jest kolejna strona wyników, w odpowiedzi pojawi się flaga **`hasMore`**.
	// - W takim przypadku można wywołać zapytanie ponownie z kolejnym numerem strony.
	// > Więcej informacji:
	// > - [Pobieranie listy uprawnień](https://github.com/CIRFMF/ksef-docs/blob/main/uprawnienia.
	// md#pobranie-listy-uprawnie%C5%84-do-pracy-w-ksef-nadanych-osobom-fizycznym-lub-podmiotom)
	// **Sortowanie:**
	// - startDate (Desc)
	// - id (Asc)
	// **Wymagane uprawnienia**: `CredentialsManage`, `CredentialsRead`, `SubunitManage`.
	//
	// POST /permissions/query/persons/grants
	PermissionsQueryPersonsGrantsPost(ctx context.Context, request OptPersonPermissionsQueryRequest, params PermissionsQueryPersonsGrantsPostParams) (PermissionsQueryPersonsGrantsPostRes, error)
	// PermissionsQuerySubordinateEntitiesRolesPost invokes POST /permissions/query/subordinate-entities/roles operation.
	//
	// Metoda pozwala na odczytanie listy podmiotów podrzędnych,
	// jeżeli podmiot bieżącego kontekstu ma rolę podmiotu nadrzędnego:
	// - **nadrzędna JST** – odczytywane są podrzędne JST,
	// - **grupa VAT** – odczytywane są podmioty będące członkami grupy VAT.
	// Role podmiotów zwracane przez operację obejmują:
	// - **LocalGovernmentSubUnit** – podrzędne JST,
	// - **VatGroupSubUnit** – członek grupy VAT.
	// Odpowiedź może być filtrowana według parametru:
	// - **subordinateEntityIdentifier** – identyfikator podmiotu podrzędnego.
	// #### Stronicowanie wyników
	// Zapytanie zwraca **jedną stronę wyników** o numerze i rozmiarze podanym w ścieżce.
	// - Przy pierwszym wywołaniu należy ustawić parametr `pageOffset = 0`.
	// - Jeżeli dostępna jest kolejna strona wyników, w odpowiedzi pojawi się flaga **`hasMore`**.
	// - W takim przypadku można wywołać zapytanie ponownie z kolejnym numerem strony.
	// > Więcej informacji:
	// > - [Pobieranie listy podmiotów podrzędnych](https://github.
	// com/CIRFMF/ksef-docs/blob/main/uprawnienia.md#pobranie-listy-podmiot%C3%B3w-podrz%C4%99dnych)
	// **Sortowanie:**
	// - startDate (Desc)
	// - id (Asc)
	// **Wymagane uprawnienia**: `CredentialsManage`, `CredentialsRead`, `SubunitManage`.
	//
	// POST /permissions/query/subordinate-entities/roles
	PermissionsQuerySubordinateEntitiesRolesPost(ctx context.Context, request OptSubordinateEntityRolesQueryRequest, params PermissionsQuerySubordinateEntitiesRolesPostParams) (PermissionsQuerySubordinateEntitiesRolesPostRes, error)
	// PermissionsQuerySubunitsGrantsPost invokes POST /permissions/query/subunits/grants operation.
	//
	// Metoda pozwala na odczytanie uprawnień do zarządzania uprawnieniami nadanych administratorom:
	// - jednostek podrzędnych identyfikowanych identyfikatorem wewnętrznym
	// - podmiotów podrzędnych (podrzędnych JST lub członków grupy VAT) identyfikowanych przez NIP
	// Lista zwraca wyłącznie uprawnienia do zarządzania uprawnieniami nadane z kontekstu bieżącego
	// (z podmiotu nadrzędnego).
	// Nie są odczytywane uprawnienia nadane przez administratorów jednostek podrzędnych wewnątrz
	// tych jednostek.
	// Odpowiedź może być filtrowana na podstawie parametru:
	// - **subunitIdentifier** – identyfikator jednostki lub podmiotu podrzędnego
	// #### Stronicowanie wyników
	// Zapytanie zwraca **jedną stronę wyników** o numerze i rozmiarze podanym w ścieżce.
	// - Przy pierwszym wywołaniu należy ustawić parametr `pageOffset = 0`.
	// - Jeżeli dostępna jest kolejna strona wyników, w odpowiedzi pojawi się flaga **`hasMore`**.
	// - W takim przypadku można wywołać zapytanie ponownie z kolejnym numerem strony.
	// > Więcej informacji:
	// > - [Pobieranie listy uprawnień](https://github.com/CIRFMF/ksef-docs/blob/main/uprawnienia.
	// md#pobranie-listy-uprawnie%C5%84-administrator%C3%B3w-jednostek-i-podmiot%C3%B3w-podrz%C4%99dnych)
	// **Sortowanie:**
	// - startDate (Desc)
	// - id (Asc)
	// **Wymagane uprawnienia**: `CredentialsManage`, `CredentialsRead`, `SubunitManage`.
	//
	// POST /permissions/query/subunits/grants
	PermissionsQuerySubunitsGrantsPost(ctx context.Context, request OptSubunitPermissionsQueryRequest, params PermissionsQuerySubunitsGrantsPostParams) (PermissionsQuerySubunitsGrantsPostRes, error)
	// PermissionsSubunitsGrantsPost invokes POST /permissions/subunits/grants operation.
	//
	// Metoda pozwala na nadanie wskazanemu w żądaniu podmiotowi lub osobie fizycznej uprawnień
	// administratora w kontekście:
	// - wskazanego NIP podmiotu podrzędnego – wyłącznie jeżeli podmiot bieżącego kontekstu
	// logowania ma rolę podmiotu nadrzędnego:
	// - **LocalGovernmentUnit**
	// - **VatGroupUnit**
	// - wskazanego lub utworzonego identyfikatora wewnętrznego
	// Wraz z utworzeniem administratora jednostki podrzędnej tworzony jest identyfikator wewnętrzny
	// składający się z numeru NIP podmiotu kontekstu logowania oraz 5 cyfr unikalnie
	// identyfikujących jednostkę wewnętrzną.
	// Ostatnia cyfra musi być poprawną sumą kontrolną, która jest obliczana według poniższego
	// algorytmu.
	// Algorytm używa naprzemiennych wag (1×, 3×, 1×, 3×, ...), sumuje wyniki i zwraca resztę z
	// dzielenia przez 10.
	// Przykład:
	// - Wejście: "6824515772-1234" (bez cyfry kontrolnej)
	// - Pozycja 0 (1. cyfra): 6 × 1 = 6
	// - Pozycja 1 (2. cyfra): 8 × 3 = 24
	// - Pozycja 2 (3. cyfra): 2 × 1 = 2
	// - Pozycja 3 (4. cyfra): 4 × 3 = 12
	// - Pozycja 4 (5. cyfra): 5 × 1 = 5
	// - Pozycja 5 (6. cyfra): 1 × 3 = 3
	// - Pozycja 6 (7. cyfra): 5 × 1 = 5
	// - Pozycja 7 (8. cyfra): 7 × 3 = 21
	// - Pozycja 8 (9. cyfra): 7 × 1 = 7
	// - Pozycja 9 (10. cyfra): 2 × 3 = 6
	// - Pozycja 10 (11. cyfra): 1 × 1 = 1
	// - Pozycja 11 (12. cyfra): 2 × 3 = 6
	// - Pozycja 12 (13. cyfra): 3 × 1 = 3
	// - Pozycja 13 (14. cyfra): 4 × 3 = 12
	// - Suma: 6 + 24 + 2 + 12 + 5 + 3 + 5 + 21 + 7 + 6 + 1 + 6 + 3 + 12 = 113
	// - Cyfra kontrolna (15. cyfra): 113 % 10 = 3
	// W żądaniu podaje się również nazwę tej jednostki.
	// Uprawnienia administratora jednostki podrzędnej obejmują:
	// - **CredentialsManage** – zarządzanie uprawnieniami
	// Metoda automatycznie nadaje powyższe uprawnienie, bez konieczności podawania go w żądaniu.
	// > Więcej informacji:
	// > - [Nadawanie uprawnień](https://github.com/CIRFMF/ksef-docs/blob/main/uprawnienia.
	// md#nadanie-uprawnie%C5%84-administratora-podmiotu-podrz%C4%99dnego)
	// **Wymagane uprawnienia**: `SubunitManage`.
	//
	// POST /permissions/subunits/grants
	PermissionsSubunitsGrantsPost(ctx context.Context, request OptSubunitPermissionsGrantRequest) (PermissionsSubunitsGrantsPostRes, error)
	// RateLimitsGet invokes GET /rate-limits operation.
	//
	// Zwraca wartości aktualnie obowiązujących limitów ilości żądań przesyłanych do API.
	//
	// GET /rate-limits
	RateLimitsGet(ctx context.Context) (RateLimitsGetRes, error)
	// SecurityPublicKeyCertificatesGet invokes GET /security/public-key-certificates operation.
	//
	// Zwraca informacje o kluczach publicznych używanych do szyfrowania danych przesyłanych do systemu
	// KSeF.
	//
	// GET /security/public-key-certificates
	SecurityPublicKeyCertificatesGet(ctx context.Context) (SecurityPublicKeyCertificatesGetRes, error)
	// SessionsBatchPost invokes POST /sessions/batch operation.
	//
	// Otwiera sesję do wysyłki wsadowej faktur. Należy przekazać schemat wysyłanych faktur,
	// informacje o paczce faktur oraz informacje o kluczu używanym do szyfrowania.
	// > Więcej informacji:
	// > - [Przygotowanie paczki faktur](https://github.com/CIRFMF/ksef-docs/blob/main/sesja-wsadowa.md)
	// > - [Klucz publiczny Ministerstwa Finansów](/docs/v2/index.
	// html#tag/Certyfikaty-klucza-publicznego)
	// Aby generować dokumenty UPO w wersji v4-3 w ramach sesji, należy przy jej otwarciu przesłać
	// nagłówek <b>X-KSeF-Feature: upo-v4-3</b>.
	// Od 22 grudnia 2025 wersja UPO v4-3 będzie generowana domyślnie.
	// **Wymagane uprawnienia**: `InvoiceWrite`, `EnforcementOperations`.
	//
	// POST /sessions/batch
	SessionsBatchPost(ctx context.Context, request OptOpenBatchSessionRequest) (SessionsBatchPostRes, error)
	// SessionsBatchReferenceNumberClosePost invokes POST /sessions/batch/{referenceNumber}/close operation.
	//
	// Zamyka sesję wsadową, rozpoczyna procesowanie paczki faktur i generowanie UPO dla prawidłowych
	// faktur oraz zbiorczego UPO dla sesji.
	// **Wymagane uprawnienia**: `InvoiceWrite`, `EnforcementOperations`.
	//
	// POST /sessions/batch/{referenceNumber}/close
	SessionsBatchReferenceNumberClosePost(ctx context.Context, params SessionsBatchReferenceNumberClosePostParams) (SessionsBatchReferenceNumberClosePostRes, error)
	// SessionsGet invokes GET /sessions operation.
	//
	// Zwraca listę sesji spełniających podane kryteria wyszukiwania.
	// **Sortowanie:**
	// - dateCreated (Desc)
	// **Wymagane uprawnienia**:
	// - `Introspection`/`EnforcementOperations` – pozwala pobrać wszystkie sesje w bieżącym
	// kontekście uwierzytelnienia `(ContextIdentifier)`.
	// - `InvoiceWrite` – pozwala pobrać wyłącznie sesje utworzone przez podmiot uwierzytelniający,
	// czyli podmiot inicjujący uwierzytelnienie.
	//
	// GET /sessions
	SessionsGet(ctx context.Context, params SessionsGetParams) (SessionsGetRes, error)
	// SessionsOnlinePost invokes POST /sessions/online operation.
	//
	// Otwiera sesję do wysyłki pojedynczych faktur. Należy przekazać schemat wysyłanych faktur oraz
	// informacje o kluczu używanym do szyfrowania.
	// > Więcej informacji:
	// > - [Otwarcie sesji interaktywnej](https://github.
	// com/CIRFMF/ksef-docs/blob/main/sesja-interaktywna.md#1-otwarcie-sesji)
	// > - [Klucz publiczny Ministerstwa Finansów](/docs/v2/index.
	// html#tag/Certyfikaty-klucza-publicznego)
	// Aby generować dokumenty UPO w wersji v4-3 w ramach sesji, należy przy jej otwarciu przesłać
	// nagłówek <b>X-KSeF-Feature: upo-v4-3</b>.
	// Od 22 grudnia 2025 wersja UPO v4-3 będzie generowana domyślnie.
	// **Wymagane uprawnienia**: `InvoiceWrite`, `PefInvoiceWrite`, `EnforcementOperations`.
	//
	// POST /sessions/online
	SessionsOnlinePost(ctx context.Context, request OptOpenOnlineSessionRequest) (SessionsOnlinePostRes, error)
	// SessionsOnlineReferenceNumberClosePost invokes POST /sessions/online/{referenceNumber}/close operation.
	//
	// Zamyka sesję interaktywną i rozpoczyna generowanie zbiorczego UPO dla sesji.
	// **Wymagane uprawnienia**: `InvoiceWrite`, `PefInvoiceWrite`, `EnforcementOperations`.
	//
	// POST /sessions/online/{referenceNumber}/close
	SessionsOnlineReferenceNumberClosePost(ctx context.Context, params SessionsOnlineReferenceNumberClosePostParams) (SessionsOnlineReferenceNumberClosePostRes, error)
	// SessionsOnlineReferenceNumberInvoicesPost invokes POST /sessions/online/{referenceNumber}/invoices operation.
	//
	// Przyjmuje zaszyfrowaną fakturę oraz jej metadane i rozpoczyna jej przetwarzanie.
	// > Więcej informacji:
	// > - [Wysłanie faktury](https://github.com/CIRFMF/ksef-docs/blob/main/sesja-interaktywna.
	// md#2-wys%C5%82anie-faktury)
	// **Wymagane uprawnienia**: `InvoiceWrite`, `PefInvoiceWrite`, `EnforcementOperations`.
	//
	// POST /sessions/online/{referenceNumber}/invoices
	SessionsOnlineReferenceNumberInvoicesPost(ctx context.Context, request OptSendInvoiceRequest, params SessionsOnlineReferenceNumberInvoicesPostParams) (SessionsOnlineReferenceNumberInvoicesPostRes, error)
	// SessionsReferenceNumberGet invokes GET /sessions/{referenceNumber} operation.
	//
	// Sprawdza bieżący status sesji o podanym numerze referencyjnym.
	// **Wymagane uprawnienia**: `InvoiceWrite`, `Introspection`, `PefInvoiceWrite`,
	// `EnforcementOperations`.
	//
	// GET /sessions/{referenceNumber}
	SessionsReferenceNumberGet(ctx context.Context, params SessionsReferenceNumberGetParams) (SessionsReferenceNumberGetRes, error)
	// SessionsReferenceNumberInvoicesFailedGet invokes GET /sessions/{referenceNumber}/invoices/failed operation.
	//
	// Zwraca listę niepoprawnie przetworzonych faktur przesłanych w sesji wraz z ich statusami.
	// **Wymagane uprawnienia**: `InvoiceWrite`, `Introspection`, `PefInvoiceWrite`,
	// `EnforcementOperations`.
	//
	// GET /sessions/{referenceNumber}/invoices/failed
	SessionsReferenceNumberInvoicesFailedGet(ctx context.Context, params SessionsReferenceNumberInvoicesFailedGetParams) (SessionsReferenceNumberInvoicesFailedGetRes, error)
	// SessionsReferenceNumberInvoicesGet invokes GET /sessions/{referenceNumber}/invoices operation.
	//
	// Zwraca listę faktur przesłanych w sesji wraz z ich statusami, oraz informacje na temat ilości
	// poprawnie i niepoprawnie przetworzonych faktur.
	// **Wymagane uprawnienia**: `InvoiceWrite`, `Introspection`, `PefInvoiceWrite`,
	// `EnforcementOperations`.
	//
	// GET /sessions/{referenceNumber}/invoices
	SessionsReferenceNumberInvoicesGet(ctx context.Context, params SessionsReferenceNumberInvoicesGetParams) (SessionsReferenceNumberInvoicesGetRes, error)
	// SessionsReferenceNumberInvoicesInvoiceReferenceNumberGet invokes GET /sessions/{referenceNumber}/invoices/{invoiceReferenceNumber} operation.
	//
	// Zwraca fakturę przesłaną w sesji wraz ze statusem.
	// **Wymagane uprawnienia**: `InvoiceWrite`, `Introspection`, `PefInvoiceWrite`,
	// `EnforcementOperations`.
	//
	// GET /sessions/{referenceNumber}/invoices/{invoiceReferenceNumber}
	SessionsReferenceNumberInvoicesInvoiceReferenceNumberGet(ctx context.Context, params SessionsReferenceNumberInvoicesInvoiceReferenceNumberGetParams) (SessionsReferenceNumberInvoicesInvoiceReferenceNumberGetRes, error)
	// SessionsReferenceNumberInvoicesInvoiceReferenceNumberUpoGet invokes GET /sessions/{referenceNumber}/invoices/{invoiceReferenceNumber}/upo operation.
	//
	// Zwraca UPO faktury przesłanego w sesji na podstawie jego numeru KSeF.
	// **Wymagane uprawnienia**: `InvoiceWrite`, `Introspection`, `PefInvoiceWrite`,
	// `EnforcementOperations`.
	//
	// GET /sessions/{referenceNumber}/invoices/{invoiceReferenceNumber}/upo
	SessionsReferenceNumberInvoicesInvoiceReferenceNumberUpoGet(ctx context.Context, params SessionsReferenceNumberInvoicesInvoiceReferenceNumberUpoGetParams) (SessionsReferenceNumberInvoicesInvoiceReferenceNumberUpoGetRes, error)
	// SessionsReferenceNumberInvoicesKsefKsefNumberUpoGet invokes GET /sessions/{referenceNumber}/invoices/ksef/{ksefNumber}/upo operation.
	//
	// Zwraca UPO faktury przesłanego w sesji na podstawie jego numeru KSeF.
	// **Wymagane uprawnienia**: `InvoiceWrite`, `Introspection`, `PefInvoiceWrite`,
	// `EnforcementOperations`.
	//
	// GET /sessions/{referenceNumber}/invoices/ksef/{ksefNumber}/upo
	SessionsReferenceNumberInvoicesKsefKsefNumberUpoGet(ctx context.Context, params SessionsReferenceNumberInvoicesKsefKsefNumberUpoGetParams) (SessionsReferenceNumberInvoicesKsefKsefNumberUpoGetRes, error)
	// SessionsReferenceNumberUpoUpoReferenceNumberGet invokes GET /sessions/{referenceNumber}/upo/{upoReferenceNumber} operation.
	//
	// Zwraca XML zawierający zbiorcze UPO dla sesji.
	// **Wymagane uprawnienia**: `InvoiceWrite`, `Introspection`, `PefInvoiceWrite`,
	// `EnforcementOperations`.
	//
	// GET /sessions/{referenceNumber}/upo/{upoReferenceNumber}
	SessionsReferenceNumberUpoUpoReferenceNumberGet(ctx context.Context, params SessionsReferenceNumberUpoUpoReferenceNumberGetParams) (SessionsReferenceNumberUpoUpoReferenceNumberGetRes, error)
	// TestdataAttachmentPost invokes POST /testdata/attachment operation.
	//
	// Dodaje możliwość wysyłania faktur z załącznikiem przez wskazany podmiot.
	//
	// POST /testdata/attachment
	TestdataAttachmentPost(ctx context.Context, request OptAttachmentPermissionGrantRequest) (TestdataAttachmentPostRes, error)
	// TestdataAttachmentRevokePost invokes POST /testdata/attachment/revoke operation.
	//
	// Odbiera możliwość wysyłania faktur z załącznikiem przez wskazany podmiot.
	//
	// POST /testdata/attachment/revoke
	TestdataAttachmentRevokePost(ctx context.Context, request OptAttachmentPermissionRevokeRequest) (TestdataAttachmentRevokePostRes, error)
	// TestdataLimitsContextSessionDelete invokes DELETE /testdata/limits/context/session operation.
	//
	// Przywraca wartości aktualnie obowiązujących limitów sesji dla bieżącego kontekstu do
	// wartości domyślnych. **Tylko na środowiskach testowych.**.
	//
	// DELETE /testdata/limits/context/session
	TestdataLimitsContextSessionDelete(ctx context.Context) (TestdataLimitsContextSessionDeleteRes, error)
	// TestdataLimitsContextSessionPost invokes POST /testdata/limits/context/session operation.
	//
	// Zmienia wartości aktualnie obowiązujących limitów sesji dla bieżącego kontekstu. **Tylko na
	// środowiskach testowych.**.
	//
	// POST /testdata/limits/context/session
	TestdataLimitsContextSessionPost(ctx context.Context, request OptSetSessionLimitsRequest) (TestdataLimitsContextSessionPostRes, error)
	// TestdataLimitsSubjectCertificateDelete invokes DELETE /testdata/limits/subject/certificate operation.
	//
	// Przywraca wartości aktualnie obowiązujących limitów certyfikatów dla bieżącego podmiotu do
	// wartości domyślnych. **Tylko na środowiskach testowych.**.
	//
	// DELETE /testdata/limits/subject/certificate
	TestdataLimitsSubjectCertificateDelete(ctx context.Context) (TestdataLimitsSubjectCertificateDeleteRes, error)
	// TestdataLimitsSubjectCertificatePost invokes POST /testdata/limits/subject/certificate operation.
	//
	// Zmienia wartości aktualnie obowiązujących limitów certyfikatów dla bieżącego podmiotu.
	// **Tylko na środowiskach testowych.**.
	//
	// POST /testdata/limits/subject/certificate
	TestdataLimitsSubjectCertificatePost(ctx context.Context, request OptSetSubjectLimitsRequest) (TestdataLimitsSubjectCertificatePostRes, error)
	// TestdataPermissionsPost invokes POST /testdata/permissions operation.
	//
	// Nadawanie uprawnień testowemu podmiotowi lub osobie fizycznej, a także w ich kontekście.
	//
	// POST /testdata/permissions
	TestdataPermissionsPost(ctx context.Context, request OptTestDataPermissionsGrantRequest) (TestdataPermissionsPostRes, error)
	// TestdataPermissionsRevokePost invokes POST /testdata/permissions/revoke operation.
	//
	// Odbieranie uprawnień nadanych testowemu podmiotowi lub osobie fizycznej, a także w ich
	// kontekście.
	//
	// POST /testdata/permissions/revoke
	TestdataPermissionsRevokePost(ctx context.Context, request OptTestDataPermissionsRevokeRequest) (TestdataPermissionsRevokePostRes, error)
	// TestdataPersonPost invokes POST /testdata/person operation.
	//
	// Tworzenie nowej osoby fizycznej, której system nadaje uprawnienia właścicielskie. Można
	// również określić, czy osoba ta jest komornikiem – wówczas otrzyma odpowiednie uprawnienie
	// egzekucyjne.
	//
	// POST /testdata/person
	TestdataPersonPost(ctx context.Context, request OptPersonCreateRequest) (TestdataPersonPostRes, error)
	// TestdataPersonRemovePost invokes POST /testdata/person/remove operation.
	//
	// Usuwanie testowej osoby fizycznej. System automatycznie odbierze jej wszystkie uprawnienia.
	//
	// POST /testdata/person/remove
	TestdataPersonRemovePost(ctx context.Context, request OptPersonRemoveRequest) (TestdataPersonRemovePostRes, error)
	// TestdataRateLimitsDelete invokes DELETE /testdata/rate-limits operation.
	//
	// Przywraca wartości aktualnie obowiązujących limitów żądań przesyłanych do API dla
	// bieżącego kontekstu do wartości domyślnych. **Tylko na środowiskach testowych.**.
	//
	// DELETE /testdata/rate-limits
	TestdataRateLimitsDelete(ctx context.Context) (TestdataRateLimitsDeleteRes, error)
	// TestdataRateLimitsPost invokes POST /testdata/rate-limits operation.
	//
	// Zmienia wartości aktualnie obowiązujących limitów żądań przesyłanych do API dla
	// bieżącego kontekstu. **Tylko na środowiskach testowych.**.
	//
	// POST /testdata/rate-limits
	TestdataRateLimitsPost(ctx context.Context, request OptSetRateLimitsRequest) (TestdataRateLimitsPostRes, error)
	// TestdataRateLimitsProductionPost invokes POST /testdata/rate-limits/production operation.
	//
	// Zmienia wartości aktualnie obowiązujących limitów żądań przesyłanych do API dla
	// bieżącego kontekstu na wartości takie jakie będą na środowisku produkcyjnym. **Tylko na
	// środowiskach testowych.**.
	//
	// POST /testdata/rate-limits/production
	TestdataRateLimitsProductionPost(ctx context.Context) (TestdataRateLimitsProductionPostRes, error)
	// TestdataSubjectPost invokes POST /testdata/subject operation.
	//
	// Tworzenie nowego podmiotu testowego. W przypadku grupy VAT i JST istnieje możliwość stworzenia
	// jednostek podrzędnych. W wyniku takiego działania w systemie powstanie powiązanie między tymi
	// podmiotami.
	//
	// POST /testdata/subject
	TestdataSubjectPost(ctx context.Context, request OptSubjectCreateRequest) (TestdataSubjectPostRes, error)
	// TestdataSubjectRemovePost invokes POST /testdata/subject/remove operation.
	//
	// Usuwanie podmiotu testowego. W przypadku grupy VAT i JST usunięte zostaną również jednostki
	// podrzędne.
	//
	// POST /testdata/subject/remove
	TestdataSubjectRemovePost(ctx context.Context, request OptSubjectRemoveRequest) (TestdataSubjectRemovePostRes, error)
	// TokensGet invokes GET /tokens operation.
	//
	// **Sortowanie:**
	// - dateCreated (Desc).
	//
	// GET /tokens
	TokensGet(ctx context.Context, params TokensGetParams) (TokensGetRes, error)
	// TokensPost invokes POST /tokens operation.
	//
	// Zwraca token, który może być użyty do uwierzytelniania się w KSeF.
	// Token może być generowany tylko w kontekście NIP lub identyfikatora wewnętrznego. Jest
	// zwracany tylko raz. Zaczyna być aktywny w momencie gdy jego status zmieni się na `Active`.
	//
	// POST /tokens
	TokensPost(ctx context.Context, request OptGenerateTokenRequest) (TokensPostRes, error)
	// TokensReferenceNumberDelete invokes DELETE /tokens/{referenceNumber} operation.
	//
	// Unieważniony token nie pozwoli już na uwierzytelnienie się za jego pomocą. Unieważnienie nie
	// może zostać cofnięte.
	//
	// DELETE /tokens/{referenceNumber}
	TokensReferenceNumberDelete(ctx context.Context, params TokensReferenceNumberDeleteParams) (TokensReferenceNumberDeleteRes, error)
	// TokensReferenceNumberGet invokes GET /tokens/{referenceNumber} operation.
	//
	// Pobranie statusu tokena.
	//
	// GET /tokens/{referenceNumber}
	TokensReferenceNumberGet(ctx context.Context, params TokensReferenceNumberGetParams) (TokensReferenceNumberGetRes, error)
}

// Client implements OAS client.
type Client struct {
	serverURL *url.URL
	sec       SecuritySource
	baseClient
}

// NewClient initializes new Client defined by OAS.
func NewClient(serverURL string, sec SecuritySource, opts ...ClientOption) (*Client, error) {
	u, err := url.Parse(serverURL)
	if err != nil {
		return nil, err
	}
	trimTrailingSlashes(u)

	c, err := newClientConfig(opts...).baseClient()
	if err != nil {
		return nil, err
	}
	return &Client{
		serverURL:  u,
		sec:        sec,
		baseClient: c,
	}, nil
}

type serverURLKey struct{}

// WithServerURL sets context key to override server URL.
func WithServerURL(ctx context.Context, u *url.URL) context.Context {
	return context.WithValue(ctx, serverURLKey{}, u)
}

func (c *Client) requestURL(ctx context.Context) *url.URL {
	u, ok := ctx.Value(serverURLKey{}).(*url.URL)
	if !ok {
		return c.serverURL
	}
	return u
}

// AuthChallengePost invokes POST /auth/challenge operation.
//
// Generuje unikalny challenge wymagany w kolejnym kroku operacji uwierzytelnienia.
//
// POST /auth/challenge
func (c *Client) AuthChallengePost(ctx context.Context) (AuthChallengePostRes, error) {
	res, err := c.sendAuthChallengePost(ctx)
	return res, err
}

func (c *Client) sendAuthChallengePost(ctx context.Context) (res AuthChallengePostRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/auth/challenge"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAuthChallengePostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AuthKsefTokenPost invokes POST /auth/ksef-token operation.
//
// Rozpoczyna operację uwierzytelniania z wykorzystaniem wcześniej wygenerowanego tokena KSeF.
// Token KSeF wraz z timestampem ze wcześniej wygenerowanego challenge'a (w formacie
// ```token|timestamp```) powinien zostać zaszyfrowany dedykowanym do tego celu kluczem publicznym.
// - Timestamp powinien zostać przekazany jako **liczba milisekund od 1 stycznia 1970 roku (Unix
// timestamp)**.
// - Algorytm szyfrowania: **RSA-OAEP (z użyciem SHA-256 jako funkcji skrótu)**.
//
// POST /auth/ksef-token
func (c *Client) AuthKsefTokenPost(ctx context.Context, request OptInitTokenAuthenticationRequest) (AuthKsefTokenPostRes, error) {
	res, err := c.sendAuthKsefTokenPost(ctx, request)
	return res, err
}

func (c *Client) sendAuthKsefTokenPost(ctx context.Context, request OptInitTokenAuthenticationRequest) (res AuthKsefTokenPostRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/auth/ksef-token"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAuthKsefTokenPostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAuthKsefTokenPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AuthReferenceNumberGet invokes GET /auth/{referenceNumber} operation.
//
// Sprawdza bieżący status operacji uwierzytelniania dla podanego tokena.
// Sposób uwierzytelnienia: `AuthenticationToken` otrzymany przy rozpoczęciu operacji
// uwierzytelniania.
//
// GET /auth/{referenceNumber}
func (c *Client) AuthReferenceNumberGet(ctx context.Context, params AuthReferenceNumberGetParams) (AuthReferenceNumberGetRes, error) {
	res, err := c.sendAuthReferenceNumberGet(ctx, params)
	return res, err
}

func (c *Client) sendAuthReferenceNumberGet(ctx context.Context, params AuthReferenceNumberGetParams) (res AuthReferenceNumberGetRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/auth/"
	{
		// Encode "referenceNumber" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "referenceNumber",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.ReferenceNumber); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearer(ctx, AuthReferenceNumberGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAuthReferenceNumberGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AuthSessionsCurrentDelete invokes DELETE /auth/sessions/current operation.
//
// Unieważnia sesję powiązaną z tokenem użytym do wywołania tej operacji.
// Unieważnienie sesji sprawia, że powiązany z nią refresh token przestaje działać i nie można
// już za jego pomocą uzyskać kolejnych access tokenów.
// **Aktywne access tokeny działają do czasu minięcia ich termin ważności.**
// Sposób uwierzytelnienia: `RefreshToken` lub `AccessToken`.
//
// DELETE /auth/sessions/current
func (c *Client) AuthSessionsCurrentDelete(ctx context.Context) (AuthSessionsCurrentDeleteRes, error) {
	res, err := c.sendAuthSessionsCurrentDelete(ctx)
	return res, err
}

func (c *Client) sendAuthSessionsCurrentDelete(ctx context.Context) (res AuthSessionsCurrentDeleteRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/auth/sessions/current"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearer(ctx, AuthSessionsCurrentDeleteOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAuthSessionsCurrentDeleteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AuthSessionsGet invokes GET /auth/sessions operation.
//
// Zwraca listę aktywnych sesji uwierzytelnienia.
// **Sortowanie:**
// - startDate (Desc).
//
// GET /auth/sessions
func (c *Client) AuthSessionsGet(ctx context.Context, params AuthSessionsGetParams) (AuthSessionsGetRes, error) {
	res, err := c.sendAuthSessionsGet(ctx, params)
	return res, err
}

func (c *Client) sendAuthSessionsGet(ctx context.Context, params AuthSessionsGetParams) (res AuthSessionsGetRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/auth/sessions"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "pageSize" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "pageSize",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "x-continuation-token",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XContinuationToken.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearer(ctx, AuthSessionsGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAuthSessionsGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AuthSessionsReferenceNumberDelete invokes DELETE /auth/sessions/{referenceNumber} operation.
//
// Unieważnia sesję o podanym numerze referencyjnym.
// Unieważnienie sesji sprawia, że powiązany z nią refresh token przestaje działać i nie można
// już za jego pomocą uzyskać kolejnych access tokenów.
// **Aktywne access tokeny działają do czasu minięcia ich termin ważności.**.
//
// DELETE /auth/sessions/{referenceNumber}
func (c *Client) AuthSessionsReferenceNumberDelete(ctx context.Context, params AuthSessionsReferenceNumberDeleteParams) (AuthSessionsReferenceNumberDeleteRes, error) {
	res, err := c.sendAuthSessionsReferenceNumberDelete(ctx, params)
	return res, err
}

func (c *Client) sendAuthSessionsReferenceNumberDelete(ctx context.Context, params AuthSessionsReferenceNumberDeleteParams) (res AuthSessionsReferenceNumberDeleteRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/auth/sessions/"
	{
		// Encode "referenceNumber" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "referenceNumber",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.ReferenceNumber); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearer(ctx, AuthSessionsReferenceNumberDeleteOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAuthSessionsReferenceNumberDeleteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AuthTokenRedeemPost invokes POST /auth/token/redeem operation.
//
// Pobiera parę tokenów (access token i refresh token) wygenerowanych w ramach pozytywnie
// zakończonego procesu uwierzytelniania.
// **Tokeny można pobrać tylko raz.**
// Sposób uwierzytelnienia: `AuthenticationToken` otrzymany przy rozpoczęciu operacji
// uwierzytelniania.
//
// POST /auth/token/redeem
func (c *Client) AuthTokenRedeemPost(ctx context.Context) (AuthTokenRedeemPostRes, error) {
	res, err := c.sendAuthTokenRedeemPost(ctx)
	return res, err
}

func (c *Client) sendAuthTokenRedeemPost(ctx context.Context) (res AuthTokenRedeemPostRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/auth/token/redeem"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearer(ctx, AuthTokenRedeemPostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAuthTokenRedeemPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AuthTokenRefreshPost invokes POST /auth/token/refresh operation.
//
// Generuje nowy token dostępu na podstawie ważnego refresh tokena.
// Sposób uwierzytelnienia: `RefreshToken`.
//
// POST /auth/token/refresh
func (c *Client) AuthTokenRefreshPost(ctx context.Context) (AuthTokenRefreshPostRes, error) {
	res, err := c.sendAuthTokenRefreshPost(ctx)
	return res, err
}

func (c *Client) sendAuthTokenRefreshPost(ctx context.Context) (res AuthTokenRefreshPostRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/auth/token/refresh"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearer(ctx, AuthTokenRefreshPostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAuthTokenRefreshPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AuthXadesSignaturePost invokes POST /auth/xades-signature operation.
//
// Rozpoczyna operację uwierzytelniania za pomocą dokumentu XML podpisanego podpisem elektronicznym
// XAdES.
// > Więcej informacji:
// > - [Przygotowanie dokumentu XML](https://github.com/CIRFMF/ksef-docs/blob/main/uwierzytelnianie.
// md#1-przygotowanie-dokumentu-xml-authtokenrequest)
// > - [Podpis dokumentu XML](https://github.com/CIRFMF/ksef-docs/blob/main/uwierzytelnianie.
// md#2-podpisanie-dokumentu-xades)
// > - [Schemat XSD](/docs/v2/schemas/authv2.xsd).
//
// POST /auth/xades-signature
func (c *Client) AuthXadesSignaturePost(ctx context.Context, request AuthXadesSignaturePostReq, params AuthXadesSignaturePostParams) (AuthXadesSignaturePostRes, error) {
	res, err := c.sendAuthXadesSignaturePost(ctx, request, params)
	return res, err
}

func (c *Client) sendAuthXadesSignaturePost(ctx context.Context, request AuthXadesSignaturePostReq, params AuthXadesSignaturePostParams) (res AuthXadesSignaturePostRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/auth/xades-signature"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "verifyCertificateChain" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "verifyCertificateChain",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.VerifyCertificateChain.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAuthXadesSignaturePostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAuthXadesSignaturePostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CertificatesCertificateSerialNumberRevokePost invokes POST /certificates/{certificateSerialNumber}/revoke operation.
//
// Unieważnia certyfikat o podanym numerze seryjnym.
//
// POST /certificates/{certificateSerialNumber}/revoke
func (c *Client) CertificatesCertificateSerialNumberRevokePost(ctx context.Context, request OptRevokeCertificateRequest, params CertificatesCertificateSerialNumberRevokePostParams) (CertificatesCertificateSerialNumberRevokePostRes, error) {
	res, err := c.sendCertificatesCertificateSerialNumberRevokePost(ctx, request, params)
	return res, err
}

func (c *Client) sendCertificatesCertificateSerialNumberRevokePost(ctx context.Context, request OptRevokeCertificateRequest, params CertificatesCertificateSerialNumberRevokePostParams) (res CertificatesCertificateSerialNumberRevokePostRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/certificates/"
	{
		// Encode "certificateSerialNumber" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "certificateSerialNumber",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CertificateSerialNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/revoke"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCertificatesCertificateSerialNumberRevokePostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearer(ctx, CertificatesCertificateSerialNumberRevokePostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCertificatesCertificateSerialNumberRevokePostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CertificatesEnrollmentsDataGet invokes GET /certificates/enrollments/data operation.
//
// Zwraca dane wymagane do przygotowania wniosku certyfikacyjnego PKCS#10.
// Dane te są zwracane na podstawie certyfikatu użytego w procesie uwierzytelnienia i identyfikują
// podmiot, który składa wniosek o certyfikat.
// > Więcej informacji:
// > - [Pobranie danych do wniosku certyfikacyjnego](https://github.
// com/CIRFMF/ksef-docs/blob/main/certyfikaty-KSeF.md#2-pobranie-danych-do-wniosku-certyfikacyjnego)
// > - [Przygotowanie wniosku](https://github.com/CIRFMF/ksef-docs/blob/main/certyfikaty-KSeF.
// md#3-przygotowanie-csr-certificate-signing-request).
//
// GET /certificates/enrollments/data
func (c *Client) CertificatesEnrollmentsDataGet(ctx context.Context) (CertificatesEnrollmentsDataGetRes, error) {
	res, err := c.sendCertificatesEnrollmentsDataGet(ctx)
	return res, err
}

func (c *Client) sendCertificatesEnrollmentsDataGet(ctx context.Context) (res CertificatesEnrollmentsDataGetRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/certificates/enrollments/data"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearer(ctx, CertificatesEnrollmentsDataGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCertificatesEnrollmentsDataGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CertificatesEnrollmentsPost invokes POST /certificates/enrollments operation.
//
// Przyjmuje wniosek certyfikacyjny i rozpoczyna jego przetwarzanie.
// Dozwolone typy kluczy prywatnych:
// - RSA (OID: 1.2.840.113549.1.1.1), długość klucza równa 2048 bitów,
// - EC (klucze oparte na krzywych eliptycznych, OID: 1.2.840.10045.2.1), krzywa NIST P-256
// (secp256r1)
// Zalecane jest stosowanie kluczy EC.
// Dozwolone algorytmy podpisu:
// - RSA PKCS#1 v1.5,
// - RSA PSS,
// - ECDSA (format podpisu zgodny z RFC 3279)
// Dozwolone funkcje skrótu użyte do podpisu CSR:
// - SHA1,
// - SHA256,
// - SHA384,
// - SHA512
// > Więcej informacji:
// > - [Wysłanie wniosku certyfikacyjnego](https://github.
// com/CIRFMF/ksef-docs/blob/main/certyfikaty-KSeF.md#4-wys%C5%82anie-wniosku-certyfikacyjnego).
//
// POST /certificates/enrollments
func (c *Client) CertificatesEnrollmentsPost(ctx context.Context, request OptEnrollCertificateRequest) (CertificatesEnrollmentsPostRes, error) {
	res, err := c.sendCertificatesEnrollmentsPost(ctx, request)
	return res, err
}

func (c *Client) sendCertificatesEnrollmentsPost(ctx context.Context, request OptEnrollCertificateRequest) (res CertificatesEnrollmentsPostRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/certificates/enrollments"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCertificatesEnrollmentsPostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearer(ctx, CertificatesEnrollmentsPostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCertificatesEnrollmentsPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CertificatesEnrollmentsReferenceNumberGet invokes GET /certificates/enrollments/{referenceNumber} operation.
//
// Zwraca informacje o statusie wniosku certyfikacyjnego.
//
// GET /certificates/enrollments/{referenceNumber}
func (c *Client) CertificatesEnrollmentsReferenceNumberGet(ctx context.Context, params CertificatesEnrollmentsReferenceNumberGetParams) (CertificatesEnrollmentsReferenceNumberGetRes, error) {
	res, err := c.sendCertificatesEnrollmentsReferenceNumberGet(ctx, params)
	return res, err
}

func (c *Client) sendCertificatesEnrollmentsReferenceNumberGet(ctx context.Context, params CertificatesEnrollmentsReferenceNumberGetParams) (res CertificatesEnrollmentsReferenceNumberGetRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/certificates/enrollments/"
	{
		// Encode "referenceNumber" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "referenceNumber",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.ReferenceNumber); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearer(ctx, CertificatesEnrollmentsReferenceNumberGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCertificatesEnrollmentsReferenceNumberGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CertificatesLimitsGet invokes GET /certificates/limits operation.
//
// Zwraca informacje o limitach certyfikatów oraz informacje czy użytkownik może zawnioskować o
// certyfikat KSeF.
//
// GET /certificates/limits
func (c *Client) CertificatesLimitsGet(ctx context.Context) (CertificatesLimitsGetRes, error) {
	res, err := c.sendCertificatesLimitsGet(ctx)
	return res, err
}

func (c *Client) sendCertificatesLimitsGet(ctx context.Context) (res CertificatesLimitsGetRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/certificates/limits"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearer(ctx, CertificatesLimitsGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCertificatesLimitsGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CertificatesQueryPost invokes POST /certificates/query operation.
//
// Zwraca listę certyfikatów spełniających podane kryteria wyszukiwania.
// W przypadku braku podania kryteriów wyszukiwania zwrócona zostanie nieprzefiltrowana lista.
// **Sortowanie:**
// - requestDate (Desc).
//
// POST /certificates/query
func (c *Client) CertificatesQueryPost(ctx context.Context, request OptQueryCertificatesRequest, params CertificatesQueryPostParams) (CertificatesQueryPostRes, error) {
	res, err := c.sendCertificatesQueryPost(ctx, request, params)
	return res, err
}

func (c *Client) sendCertificatesQueryPost(ctx context.Context, request OptQueryCertificatesRequest, params CertificatesQueryPostParams) (res CertificatesQueryPostRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/certificates/query"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "pageSize" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "pageSize",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "pageOffset" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "pageOffset",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageOffset.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCertificatesQueryPostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearer(ctx, CertificatesQueryPostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCertificatesQueryPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CertificatesRetrievePost invokes POST /certificates/retrieve operation.
//
// Zwraca certyfikaty o podanych numerach seryjnych w formacie DER zakodowanym w Base64.
//
// POST /certificates/retrieve
func (c *Client) CertificatesRetrievePost(ctx context.Context, request OptRetrieveCertificatesRequest) (CertificatesRetrievePostRes, error) {
	res, err := c.sendCertificatesRetrievePost(ctx, request)
	return res, err
}

func (c *Client) sendCertificatesRetrievePost(ctx context.Context, request OptRetrieveCertificatesRequest) (res CertificatesRetrievePostRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/certificates/retrieve"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCertificatesRetrievePostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearer(ctx, CertificatesRetrievePostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCertificatesRetrievePostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// InvoicesExportsPost invokes POST /invoices/exports operation.
//
// Rozpoczyna asynchroniczny proces wyszukiwania faktur w systemie KSeF na podstawie przekazanych
// filtrów oraz przygotowania ich w formie zaszyfrowanej paczki.
// Wymagane jest przekazanie informacji o szyfrowaniu w polu <b>Encryption</b>, które służą do
// zabezpieczenia przygotowanej paczki z fakturami.
// Maksymalnie można uruchomić 10 równoczesnych eksportów w zalogowanym kontekście.
// System pobiera faktury rosnąco według daty określonej w filtrze (Invoicing, Issue,
// PermanentStorage) i dodaje faktury(nazwa pliku: <b>{ksefNumber}.xml</b>) do paczki aż do
// osiągnięcia jednego z poniższych limitów:
// * Limit liczby faktur: 10 000 sztuk
// * Limit rozmiaru danych(skompresowanych): 1GB
// Paczka eksportu zawiera dodatkowy plik z metadanymi faktur w formacie JSON (`_metadata.json`).
// Zawartość pliku to
// obiekt z tablicą <b>invoices</b>, gdzie każdy element jest obiektem typu <b>InvoiceMetadata</b>
// (taki jak zwracany przez endpoint `POST /invoices/query/metadata`).
// <b>Plik z metadanymi(_metadata.json) nie jest wliczany do limitów algorytmu budowania paczki</b>.
// `Do realizacji pobierania przyrostowego należy stosować filtrowanie po dacie PermanentStorage`.
// **Sortowanie:**
// - permanentStorageDate | invoicingDate | issueDate (Asc) - pole wybierane na podstawie filtrów
// **Wymagane uprawnienia**: `InvoiceRead`.
//
// POST /invoices/exports
func (c *Client) InvoicesExportsPost(ctx context.Context, request OptInvoiceExportRequest) (InvoicesExportsPostRes, error) {
	res, err := c.sendInvoicesExportsPost(ctx, request)
	return res, err
}

func (c *Client) sendInvoicesExportsPost(ctx context.Context, request OptInvoiceExportRequest) (res InvoicesExportsPostRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/invoices/exports"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeInvoicesExportsPostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearer(ctx, InvoicesExportsPostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeInvoicesExportsPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// InvoicesExportsReferenceNumberGet invokes GET /invoices/exports/{referenceNumber} operation.
//
// Paczka faktur jest dzielona na części o maksymalnym rozmiarze 50 MB. Każda część jest
// zaszyfrowana algorytmem AES-256-CBC z dopełnieniem PKCS#7, przy użyciu klucza symetrycznego
// przekazanego podczas inicjowania eksportu.
// W przypadku ucięcia wyniku eksportu z powodu przekroczenia limitów, zwracana jest flaga
// <b>IsTruncated = true</b> oraz odpowiednia data, którą należy wykorzystać do wykonania
// kolejnego eksportu, aż do momentu, gdy flaga <b>IsTruncated = false</b>.
// **Sortowanie:**
// - permanentStorageDate | invoicingDate | issueDate (Asc) - pole wybierane na podstawie filtrów
// **Wymagane uprawnienia**: `InvoiceRead`.
//
// GET /invoices/exports/{referenceNumber}
func (c *Client) InvoicesExportsReferenceNumberGet(ctx context.Context, params InvoicesExportsReferenceNumberGetParams) (InvoicesExportsReferenceNumberGetRes, error) {
	res, err := c.sendInvoicesExportsReferenceNumberGet(ctx, params)
	return res, err
}

func (c *Client) sendInvoicesExportsReferenceNumberGet(ctx context.Context, params InvoicesExportsReferenceNumberGetParams) (res InvoicesExportsReferenceNumberGetRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/invoices/exports/"
	{
		// Encode "referenceNumber" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "referenceNumber",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.ReferenceNumber); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearer(ctx, InvoicesExportsReferenceNumberGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeInvoicesExportsReferenceNumberGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// InvoicesKsefKsefNumberGet invokes GET /invoices/ksef/{ksefNumber} operation.
//
// Zwraca fakturę o podanym numerze KSeF.
// **Wymagane uprawnienia**: `InvoiceRead`.
//
// GET /invoices/ksef/{ksefNumber}
func (c *Client) InvoicesKsefKsefNumberGet(ctx context.Context, params InvoicesKsefKsefNumberGetParams) (InvoicesKsefKsefNumberGetRes, error) {
	res, err := c.sendInvoicesKsefKsefNumberGet(ctx, params)
	return res, err
}

func (c *Client) sendInvoicesKsefKsefNumberGet(ctx context.Context, params InvoicesKsefKsefNumberGetParams) (res InvoicesKsefKsefNumberGetRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/invoices/ksef/"
	{
		// Encode "ksefNumber" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "ksefNumber",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.KsefNumber); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearer(ctx, InvoicesKsefKsefNumberGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeInvoicesKsefKsefNumberGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// InvoicesQueryMetadataPost invokes POST /invoices/query/metadata operation.
//
// Zwraca metadane faktur spełniających filtry.
// Limit techniczny: ≤ 10 000 rekordów na zestaw filtrów, po jego osiągnięciu <b>isTruncated =
// true</b> i należy ponownie ustawić <b>dateRange</b>, używając ostatniej daty z wyników (tj.
// ustawić from/to - w zależności od kierunku sortowania, od daty ostatniego zwróconego rekordu)
// oraz wyzerować <b>pageOffset</b>.
// `Do scenariusza przyrostowego należy używać daty PermanentStorage oraz kolejność sortowania
// Asc`.
// <b>Scenariusz pobierania przyrostowego (skrót):</b>
// * Gdy <b>hasMore = false</b>, należy zakończyć,
// * Gdy <b>hasMore = true</b> i <b>isTruncated = false</b>, należy zwiększyć <b>pageOffset</b>,
// * Gdy <b>hasMore = true</b> i <b>isTruncated = true</b>, należy zawęzić <b>dateRange</b>
// (ustawić from od daty ostatniego rekordu), wyzerować <b>pageOffset</b> i kontynuować
// **Sortowanie:**
// - permanentStorageDate | invoicingDate | issueDate (Asc | Desc) - pole wybierane na podstawie
// filtrów
// **Wymagane uprawnienia**: `InvoiceRead`.
//
// POST /invoices/query/metadata
func (c *Client) InvoicesQueryMetadataPost(ctx context.Context, request OptInvoiceQueryFilters, params InvoicesQueryMetadataPostParams) (InvoicesQueryMetadataPostRes, error) {
	res, err := c.sendInvoicesQueryMetadataPost(ctx, request, params)
	return res, err
}

func (c *Client) sendInvoicesQueryMetadataPost(ctx context.Context, request OptInvoiceQueryFilters, params InvoicesQueryMetadataPostParams) (res InvoicesQueryMetadataPostRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/invoices/query/metadata"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "sortOrder" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sortOrder",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.SortOrder.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "pageOffset" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "pageOffset",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageOffset.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "pageSize" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "pageSize",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeInvoicesQueryMetadataPostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearer(ctx, InvoicesQueryMetadataPostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeInvoicesQueryMetadataPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// LimitsContextGet invokes GET /limits/context operation.
//
// Zwraca wartości aktualnie obowiązujących limitów dla bieżącego kontekstu.
//
// GET /limits/context
func (c *Client) LimitsContextGet(ctx context.Context) (LimitsContextGetRes, error) {
	res, err := c.sendLimitsContextGet(ctx)
	return res, err
}

func (c *Client) sendLimitsContextGet(ctx context.Context) (res LimitsContextGetRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/limits/context"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearer(ctx, LimitsContextGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeLimitsContextGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// LimitsSubjectGet invokes GET /limits/subject operation.
//
// Zwraca wartości aktualnie obowiązujących limitów dla bieżącego podmiotu.
//
// GET /limits/subject
func (c *Client) LimitsSubjectGet(ctx context.Context) (LimitsSubjectGetRes, error) {
	res, err := c.sendLimitsSubjectGet(ctx)
	return res, err
}

func (c *Client) sendLimitsSubjectGet(ctx context.Context) (res LimitsSubjectGetRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/limits/subject"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearer(ctx, LimitsSubjectGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeLimitsSubjectGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PeppolQueryGet invokes GET /peppol/query operation.
//
// Zwraca listę dostawców usług Peppol zarejestrowanych w systemie.
// **Sortowanie:**
// - dateCreated (Desc)
// - id (Asc).
//
// GET /peppol/query
func (c *Client) PeppolQueryGet(ctx context.Context, params PeppolQueryGetParams) (PeppolQueryGetRes, error) {
	res, err := c.sendPeppolQueryGet(ctx, params)
	return res, err
}

func (c *Client) sendPeppolQueryGet(ctx context.Context, params PeppolQueryGetParams) (res PeppolQueryGetRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/peppol/query"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "pageOffset" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "pageOffset",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageOffset.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "pageSize" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "pageSize",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodePeppolQueryGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PermissionsAttachmentsStatusGet invokes GET /permissions/attachments/status operation.
//
// Sprawdzenie czy obecny kontekst posiada zgodę na wystawianie faktur z załącznikiem.
// **Wymagane uprawnienia**: `CredentialsManage`, `CredentialsRead`.
//
// GET /permissions/attachments/status
func (c *Client) PermissionsAttachmentsStatusGet(ctx context.Context) (PermissionsAttachmentsStatusGetRes, error) {
	res, err := c.sendPermissionsAttachmentsStatusGet(ctx)
	return res, err
}

func (c *Client) sendPermissionsAttachmentsStatusGet(ctx context.Context) (res PermissionsAttachmentsStatusGetRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/permissions/attachments/status"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearer(ctx, PermissionsAttachmentsStatusGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodePermissionsAttachmentsStatusGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PermissionsAuthorizationsGrantsPermissionIdDelete invokes DELETE /permissions/authorizations/grants/{permissionId} operation.
//
// Metoda pozwala na odebranie uprawnienia podmiotowego o wskazanym identyfikatorze.
// Wymagane jest wcześniejsze odczytanie uprawnień w celu uzyskania
// identyfikatora uprawnienia, które ma zostać odebrane.
// > Więcej informacji:
// > - [Odbieranie uprawnień](https://github.com/CIRFMF/ksef-docs/blob/main/uprawnienia.
// md#odebranie-uprawnie%C5%84-podmiotowych)
// **Wymagane uprawnienia**: `CredentialsManage`.
//
// DELETE /permissions/authorizations/grants/{permissionId}
func (c *Client) PermissionsAuthorizationsGrantsPermissionIdDelete(ctx context.Context, params PermissionsAuthorizationsGrantsPermissionIdDeleteParams) (PermissionsAuthorizationsGrantsPermissionIdDeleteRes, error) {
	res, err := c.sendPermissionsAuthorizationsGrantsPermissionIdDelete(ctx, params)
	return res, err
}

func (c *Client) sendPermissionsAuthorizationsGrantsPermissionIdDelete(ctx context.Context, params PermissionsAuthorizationsGrantsPermissionIdDeleteParams) (res PermissionsAuthorizationsGrantsPermissionIdDeleteRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/permissions/authorizations/grants/"
	{
		// Encode "permissionId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "permissionId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.PermissionId); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearer(ctx, PermissionsAuthorizationsGrantsPermissionIdDeleteOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodePermissionsAuthorizationsGrantsPermissionIdDeleteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PermissionsAuthorizationsGrantsPost invokes POST /permissions/authorizations/grants operation.
//
// Metoda pozwala na nadanie jednego z uprawnień podmiotowych do obsługi podmiotu kontekstu
// podmiotowi wskazanemu w żądaniu.
// > Więcej informacji:
// > - [Nadawanie uprawnień](https://github.com/CIRFMF/ksef-docs/blob/main/uprawnienia.
// md#nadanie-uprawnie%C5%84-podmiotowych)
// **Wymagane uprawnienia**: `CredentialsManage`.
//
// POST /permissions/authorizations/grants
func (c *Client) PermissionsAuthorizationsGrantsPost(ctx context.Context, request OptEntityAuthorizationPermissionsGrantRequest) (PermissionsAuthorizationsGrantsPostRes, error) {
	res, err := c.sendPermissionsAuthorizationsGrantsPost(ctx, request)
	return res, err
}

func (c *Client) sendPermissionsAuthorizationsGrantsPost(ctx context.Context, request OptEntityAuthorizationPermissionsGrantRequest) (res PermissionsAuthorizationsGrantsPostRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/permissions/authorizations/grants"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePermissionsAuthorizationsGrantsPostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearer(ctx, PermissionsAuthorizationsGrantsPostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodePermissionsAuthorizationsGrantsPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PermissionsCommonGrantsPermissionIdDelete invokes DELETE /permissions/common/grants/{permissionId} operation.
//
// Metoda pozwala na odebranie uprawnienia o wskazanym identyfikatorze.
// Wymagane jest wcześniejsze odczytanie uprawnień w celu uzyskania
// identyfikatora uprawnienia, które ma zostać odebrane.
// > Więcej informacji:
// > - [Odbieranie uprawnień](https://github.com/CIRFMF/ksef-docs/blob/main/uprawnienia.
// md#odebranie-uprawnie%C5%84)
// **Wymagane uprawnienia**: `CredentialsManage`, `VatUeManage`, `SubunitManage`.
//
// DELETE /permissions/common/grants/{permissionId}
func (c *Client) PermissionsCommonGrantsPermissionIdDelete(ctx context.Context, params PermissionsCommonGrantsPermissionIdDeleteParams) (PermissionsCommonGrantsPermissionIdDeleteRes, error) {
	res, err := c.sendPermissionsCommonGrantsPermissionIdDelete(ctx, params)
	return res, err
}

func (c *Client) sendPermissionsCommonGrantsPermissionIdDelete(ctx context.Context, params PermissionsCommonGrantsPermissionIdDeleteParams) (res PermissionsCommonGrantsPermissionIdDeleteRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/permissions/common/grants/"
	{
		// Encode "permissionId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "permissionId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.PermissionId); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearer(ctx, PermissionsCommonGrantsPermissionIdDeleteOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodePermissionsCommonGrantsPermissionIdDeleteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PermissionsEntitiesGrantsPost invokes POST /permissions/entities/grants operation.
//
// Metoda pozwala na nadanie podmiotowi wskazanemu w żądaniu uprawnień do obsługi faktur podmiotu
// kontekstu.
// W żądaniu określane są nadawane uprawnienia ze zbioru:
// - **InvoiceWrite** – wystawianie faktur
// - **InvoiceRead** – przeglądanie faktur
// Metoda pozwala na wybór dowolnej kombinacji powyższych uprawnień.
// Dla każdego uprawnienia może być ustawiona flaga **canDelegate**, mówiąca o możliwości jego
// dalszego przekazywania poprzez nadawanie w sposób pośredni.
// > Więcej informacji:
// > - [Nadawanie uprawnień](https://github.com/CIRFMF/ksef-docs/blob/main/uprawnienia.
// md#nadanie-podmiotom-uprawnie%C5%84-do-obs%C5%82ugi-faktur)
// **Wymagane uprawnienia**: `CredentialsManage`.
//
// POST /permissions/entities/grants
func (c *Client) PermissionsEntitiesGrantsPost(ctx context.Context, request OptEntityPermissionsGrantRequest) (PermissionsEntitiesGrantsPostRes, error) {
	res, err := c.sendPermissionsEntitiesGrantsPost(ctx, request)
	return res, err
}

func (c *Client) sendPermissionsEntitiesGrantsPost(ctx context.Context, request OptEntityPermissionsGrantRequest) (res PermissionsEntitiesGrantsPostRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/permissions/entities/grants"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePermissionsEntitiesGrantsPostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearer(ctx, PermissionsEntitiesGrantsPostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodePermissionsEntitiesGrantsPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PermissionsEuEntitiesAdministrationGrantsPost invokes POST /permissions/eu-entities/administration/grants operation.
//
// Metoda pozwala na nadanie wskazanemu w żądaniu podmiotowi lub osobie fizycznej uprawnień
// administratora w kontekście złożonym z identyfikatora NIP podmiotu kontekstu bieżącego oraz
// numeru VAT UE podmiotu unijnego wskazanego w żądaniu.
// Wraz z utworzeniem administratora podmiotu unijnego tworzony jest kontekst złożony składający
// się z numeru NIP podmiotu kontekstu logowania oraz wskazanego numeru identyfikacyjnego VAT UE
// podmiotu unijnego.
// W żądaniu podaje się również nazwę i adres podmiotu unijnego.
// Jedynym sposobem identyfikacji uprawnianego jest odcisk palca certyfikatu kwalifikowanego:
// - certyfikat podpisu elektronicznego dla osób fizycznych
// - certyfikat pieczęci elektronicznej dla podmiotów
// Uprawnienia administratora podmiotu unijnego obejmują:
// - **VatEuManage** – zarządzanie uprawnieniami w ramach podmiotu unijnego
// - **InvoiceWrite** – wystawianie faktur
// - **InvoiceRead** – przeglądanie faktur
// - **Introspection** – przeglądanie historii sesji
// Metoda automatycznie nadaje wszystkie powyższe uprawnienia, bez konieczności ich wskazywania w
// żądaniu.
// > Więcej informacji:
// > - [Nadawanie uprawnień](https://github.com/CIRFMF/ksef-docs/blob/main/uprawnienia.
// md#nadanie-uprawnie%C5%84-administratora-podmiotu-unijnego)
// **Wymagane uprawnienia**: `CredentialsManage`.
//
// POST /permissions/eu-entities/administration/grants
func (c *Client) PermissionsEuEntitiesAdministrationGrantsPost(ctx context.Context, request OptEuEntityAdministrationPermissionsGrantRequest) (PermissionsEuEntitiesAdministrationGrantsPostRes, error) {
	res, err := c.sendPermissionsEuEntitiesAdministrationGrantsPost(ctx, request)
	return res, err
}

func (c *Client) sendPermissionsEuEntitiesAdministrationGrantsPost(ctx context.Context, request OptEuEntityAdministrationPermissionsGrantRequest) (res PermissionsEuEntitiesAdministrationGrantsPostRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/permissions/eu-entities/administration/grants"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePermissionsEuEntitiesAdministrationGrantsPostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearer(ctx, PermissionsEuEntitiesAdministrationGrantsPostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodePermissionsEuEntitiesAdministrationGrantsPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PermissionsEuEntitiesGrantsPost invokes POST /permissions/eu-entities/grants operation.
//
// Metoda pozwala na nadanie wskazanemu w żądaniu podmiotowi lub osobie fizycznej uprawnień do
// wystawiania i/lub przeglądania faktur w kontekście złożonym kontekstu bieżącego.
// Jedynym sposobem identyfikacji uprawnianego jest odcisk palca certyfikatu kwalifikowanego:
// - certyfikat podpisu elektronicznego dla osób fizycznych
// - certyfikat pieczęci elektronicznej dla podmiotów
// W żądaniu określane są nadawane uprawnienia ze zbioru:
// - **InvoiceWrite** – wystawianie faktur
// - **InvoiceRead** – przeglądanie faktur
// Metoda pozwala na wybór dowolnej kombinacji powyższych uprawnień.
// > Więcej informacji:
// > - [Nadawanie uprawnień](https://github.com/CIRFMF/ksef-docs/blob/main/uprawnienia.
// md#nadanie-uprawnie%C5%84-reprezentanta-podmiotu-unijnego)
// **Wymagane uprawnienia**: `VatUeManage`.
//
// POST /permissions/eu-entities/grants
func (c *Client) PermissionsEuEntitiesGrantsPost(ctx context.Context, request OptEuEntityPermissionsGrantRequest) (PermissionsEuEntitiesGrantsPostRes, error) {
	res, err := c.sendPermissionsEuEntitiesGrantsPost(ctx, request)
	return res, err
}

func (c *Client) sendPermissionsEuEntitiesGrantsPost(ctx context.Context, request OptEuEntityPermissionsGrantRequest) (res PermissionsEuEntitiesGrantsPostRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/permissions/eu-entities/grants"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePermissionsEuEntitiesGrantsPostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearer(ctx, PermissionsEuEntitiesGrantsPostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodePermissionsEuEntitiesGrantsPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PermissionsIndirectGrantsPost invokes POST /permissions/indirect/grants operation.
//
// Metoda pozwala na nadanie w sposób pośredni osobie wskazanej w żądaniu uprawnień do obsługi
// faktur innego podmiotu – klienta.
// Może to być jedna z możliwości:
// - nadanie uprawnień generalnych – do obsługi wszystkich klientów
// - nadanie uprawnień selektywnych – do obsługi wskazanego klienta
// Uprawnienie selektywne może być nadane wyłącznie wtedy, gdy klient nadał wcześniej
// podmiotowi bieżącego kontekstu dowolne uprawnienie z prawem do jego dalszego przekazywania
// (patrz [POST /v2/permissions/entities/grants](/docs/v2/index.
// html#tag/Nadawanie-uprawnien/paths/~1permissions~1entities~1grants/post)).
// W żądaniu określane są nadawane uprawnienia ze zbioru:
// - **InvoiceWrite** – wystawianie faktur
// - **InvoiceRead** – przeglądanie faktur
// Metoda pozwala na wybór dowolnej kombinacji powyższych uprawnień.
// > Więcej informacji:
// > - [Nadawanie uprawnień](https://github.com/CIRFMF/ksef-docs/blob/main/uprawnienia.
// md#nadanie-uprawnie%C5%84-w-spos%C3%B3b-po%C5%9Bredni)
// **Wymagane uprawnienia**: `CredentialsManage`.
//
// POST /permissions/indirect/grants
func (c *Client) PermissionsIndirectGrantsPost(ctx context.Context, request OptIndirectPermissionsGrantRequest) (PermissionsIndirectGrantsPostRes, error) {
	res, err := c.sendPermissionsIndirectGrantsPost(ctx, request)
	return res, err
}

func (c *Client) sendPermissionsIndirectGrantsPost(ctx context.Context, request OptIndirectPermissionsGrantRequest) (res PermissionsIndirectGrantsPostRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/permissions/indirect/grants"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePermissionsIndirectGrantsPostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearer(ctx, PermissionsIndirectGrantsPostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodePermissionsIndirectGrantsPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PermissionsOperationsReferenceNumberGet invokes GET /permissions/operations/{referenceNumber} operation.
//
// Zwraca status operacji asynchronicznej związanej z nadaniem lub odebraniem uprawnień.
//
// GET /permissions/operations/{referenceNumber}
func (c *Client) PermissionsOperationsReferenceNumberGet(ctx context.Context, params PermissionsOperationsReferenceNumberGetParams) (PermissionsOperationsReferenceNumberGetRes, error) {
	res, err := c.sendPermissionsOperationsReferenceNumberGet(ctx, params)
	return res, err
}

func (c *Client) sendPermissionsOperationsReferenceNumberGet(ctx context.Context, params PermissionsOperationsReferenceNumberGetParams) (res PermissionsOperationsReferenceNumberGetRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/permissions/operations/"
	{
		// Encode "referenceNumber" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "referenceNumber",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.ReferenceNumber); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearer(ctx, PermissionsOperationsReferenceNumberGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodePermissionsOperationsReferenceNumberGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PermissionsPersonsGrantsPost invokes POST /permissions/persons/grants operation.
//
// Metoda pozwala na nadanie osobie wskazanej w żądaniu uprawnień do pracy w KSeF
// w kontekście bieżącym.
// W żądaniu określane są nadawane uprawnienia ze zbioru:
// - **InvoiceWrite** – wystawianie faktur,
// - **InvoiceRead** – przeglądanie faktur,
// - **CredentialsManage** – zarządzanie uprawnieniami,
// - **CredentialsRead** – przeglądanie uprawnień,
// - **Introspection** – przeglądanie historii sesji i generowanie UPO,
// - **SubunitManage** – zarządzanie jednostkami podrzędnymi,
// - **EnforcementOperations** – wykonywanie operacji egzekucyjnych.
// Metoda pozwala na wybór dowolnej kombinacji powyższych uprawnień.
// Uprawnienie **EnforcementOperations** może być nadane wyłącznie wtedy,
// gdy podmiot kontekstu ma rolę **EnforcementAuthority** (organ egzekucyjny)
// lub **CourtBailiff** (komornik sądowy).
// > Więcej informacji:
// > - [Nadawanie uprawnień](https://github.com/CIRFMF/ksef-docs/blob/main/uprawnienia.
// md#nadawanie-uprawnie%C5%84-osobom-fizycznym-do-pracy-w-ksef)
// **Wymagane uprawnienia**: `CredentialsManage`.
//
// POST /permissions/persons/grants
func (c *Client) PermissionsPersonsGrantsPost(ctx context.Context, request OptPersonPermissionsGrantRequest) (PermissionsPersonsGrantsPostRes, error) {
	res, err := c.sendPermissionsPersonsGrantsPost(ctx, request)
	return res, err
}

func (c *Client) sendPermissionsPersonsGrantsPost(ctx context.Context, request OptPersonPermissionsGrantRequest) (res PermissionsPersonsGrantsPostRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/permissions/persons/grants"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePermissionsPersonsGrantsPostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearer(ctx, PermissionsPersonsGrantsPostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodePermissionsPersonsGrantsPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PermissionsQueryAuthorizationsGrantsPost invokes POST /permissions/query/authorizations/grants operation.
//
// Metoda pozwala na odczytanie uprawnień podmiotowych:
// - otrzymanych przez podmiot bieżącego kontekstu
// - nadanych przez podmiot bieżącego kontekstu
// Wybór listy nadanych lub otrzymanych uprawnień odbywa się przy użyciu parametru **queryType**.
// Uprawnienia zwracane przez operację obejmują:
// - **SelfInvoicing** – wystawianie faktur w trybie samofakturowania
// - **TaxRepresentative** – wykonywanie operacji przedstawiciela podatkowego
// - **RRInvoicing** – wystawianie faktur VAT RR
// - **PefInvoicing** – wystawianie faktur PEF
// Odpowiedź może być filtrowana na podstawie następujących parametrów:
// - **authorizingIdentifier** – identyfikator podmiotu uprawniającego (stosowane przy queryType =
// Received)
// - **authorizedIdentifier** – identyfikator podmiotu uprawnionego (stosowane przy queryType =
// Granted)
// - **permissionTypes** – lista rodzajów wyszukiwanych uprawnień
// #### Stronicowanie wyników
// Zapytanie zwraca **jedną stronę wyników** o numerze i rozmiarze podanym w ścieżce.
// - Przy pierwszym wywołaniu należy ustawić parametr `pageOffset = 0`.
// - Jeżeli dostępna jest kolejna strona wyników, w odpowiedzi pojawi się flaga **`hasMore`**.
// - W takim przypadku można wywołać zapytanie ponownie z kolejnym numerem strony.
// > Więcej informacji:
// > - [Pobieranie listy uprawnień](https://github.com/CIRFMF/ksef-docs/blob/main/uprawnienia.
// md#pobranie-listy-uprawnie%C5%84-podmiotowych-do-obs%C5%82ugi-faktur)
// **Sortowanie:**
// - startDate (Desc)
// - id (Asc)
// **Wymagane uprawnienia**: `CredentialsManage`, `CredentialsRead`, `PefInvoiceWrite`.
//
// POST /permissions/query/authorizations/grants
func (c *Client) PermissionsQueryAuthorizationsGrantsPost(ctx context.Context, request OptEntityAuthorizationPermissionsQueryRequest, params PermissionsQueryAuthorizationsGrantsPostParams) (PermissionsQueryAuthorizationsGrantsPostRes, error) {
	res, err := c.sendPermissionsQueryAuthorizationsGrantsPost(ctx, request, params)
	return res, err
}

func (c *Client) sendPermissionsQueryAuthorizationsGrantsPost(ctx context.Context, request OptEntityAuthorizationPermissionsQueryRequest, params PermissionsQueryAuthorizationsGrantsPostParams) (res PermissionsQueryAuthorizationsGrantsPostRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/permissions/query/authorizations/grants"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "pageOffset" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "pageOffset",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageOffset.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "pageSize" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "pageSize",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePermissionsQueryAuthorizationsGrantsPostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearer(ctx, PermissionsQueryAuthorizationsGrantsPostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodePermissionsQueryAuthorizationsGrantsPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PermissionsQueryEntitiesRolesGet invokes GET /permissions/query/entities/roles operation.
//
// Metoda pozwala na **odczytanie listy ról podmiotu bieżącego kontekstu logowania**.
// #### Role podmiotów zwracane przez operację:
// - **CourtBailiff** – komornik sądowy
// - **EnforcementAuthority** – organ egzekucyjny
// - **LocalGovernmentUnit** – nadrzędna JST
// - **LocalGovernmentSubUnit** – podrzędne JST
// - **VatGroupUnit** – grupa VAT
// - **VatGroupSubUnit** – członek grupy VAT
// #### Stronicowanie wyników
// Zapytanie zwraca **jedną stronę wyników** o numerze i rozmiarze podanym w ścieżce.
// - Przy pierwszym wywołaniu należy ustawić parametr `pageOffset = 0`.
// - Jeżeli dostępna jest kolejna strona wyników, w odpowiedzi pojawi się flaga **`hasMore`**.
// - W takim przypadku można wywołać zapytanie ponownie z kolejnym numerem strony.
// > Więcej informacji:
// > - [Pobieranie listy ról](https://github.com/CIRFMF/ksef-docs/blob/main/uprawnienia.
// md#pobranie-listy-r%C3%B3l-podmiotu)
// **Sortowanie:**
// - startDate (Desc)
// - id (Asc)
// **Wymagane uprawnienia**: `CredentialsManage`, `CredentialsRead`.
//
// GET /permissions/query/entities/roles
func (c *Client) PermissionsQueryEntitiesRolesGet(ctx context.Context, params PermissionsQueryEntitiesRolesGetParams) (PermissionsQueryEntitiesRolesGetRes, error) {
	res, err := c.sendPermissionsQueryEntitiesRolesGet(ctx, params)
	return res, err
}

func (c *Client) sendPermissionsQueryEntitiesRolesGet(ctx context.Context, params PermissionsQueryEntitiesRolesGetParams) (res PermissionsQueryEntitiesRolesGetRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/permissions/query/entities/roles"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "pageOffset" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "pageOffset",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageOffset.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "pageSize" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "pageSize",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearer(ctx, PermissionsQueryEntitiesRolesGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodePermissionsQueryEntitiesRolesGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PermissionsQueryEuEntitiesGrantsPost invokes POST /permissions/query/eu-entities/grants operation.
//
// Metoda pozwala na odczytanie uprawnień administratorów lub reprezentantów podmiotów unijnych:
// - Jeżeli kontekstem logowania jest NIP, możliwe jest odczytanie uprawnień administratorów
// podmiotów unijnych powiązanych z podmiotem bieżącego kontekstu, czyli takich, dla których
// pierwszy człon kontekstu złożonego jest równy NIP-owi kontekstu logowania.
// - Jeżeli kontekst logowania jest złożony (NIP-VAT UE), możliwe jest pobranie wszystkich
// uprawnień administratorów i reprezentantów podmiotu w bieżącym kontekście złożonym.
// Uprawnienia zwracane przez operację obejmują:
// - **VatUeManage** – zarządzanie uprawnieniami w ramach podmiotu unijnego
// - **InvoiceWrite** – wystawianie faktur
// - **InvoiceRead** – przeglądanie faktur
// - **Introspection** – przeglądanie historii sesji
// Odpowiedź może być filtrowana na podstawie następujących parametrów:
// - **vatUeIdentifier** – identyfikator podmiotu unijnego
// - **authorizedFingerprintIdentifier** – odcisk palca certyfikatu uprawnionej osoby lub podmiotu
// - **permissionTypes** – lista rodzajów wyszukiwanych uprawnień
// #### Stronicowanie wyników
// Zapytanie zwraca **jedną stronę wyników** o numerze i rozmiarze podanym w ścieżce.
// - Przy pierwszym wywołaniu należy ustawić parametr `pageOffset = 0`.
// - Jeżeli dostępna jest kolejna strona wyników, w odpowiedzi pojawi się flaga **`hasMore`**.
// - W takim przypadku można wywołać zapytanie ponownie z kolejnym numerem strony.
// > Więcej informacji:
// > - [Pobieranie listy uprawnień](https://github.com/CIRFMF/ksef-docs/blob/main/uprawnienia.
// md#pobranie-listy-uprawnie%C5%84-administrator%C3%B3w-lub-reprezentant%C3%B3w-podmiot%C3%B3w-unijnych-uprawnionych-do-samofakturowania)
// **Sortowanie:**
// - startDate (Desc)
// - id (Asc)
// **Wymagane uprawnienia**: `CredentialsManage`, `CredentialsRead`, `VatUeManage`.
//
// POST /permissions/query/eu-entities/grants
func (c *Client) PermissionsQueryEuEntitiesGrantsPost(ctx context.Context, request OptEuEntityPermissionsQueryRequest, params PermissionsQueryEuEntitiesGrantsPostParams) (PermissionsQueryEuEntitiesGrantsPostRes, error) {
	res, err := c.sendPermissionsQueryEuEntitiesGrantsPost(ctx, request, params)
	return res, err
}

func (c *Client) sendPermissionsQueryEuEntitiesGrantsPost(ctx context.Context, request OptEuEntityPermissionsQueryRequest, params PermissionsQueryEuEntitiesGrantsPostParams) (res PermissionsQueryEuEntitiesGrantsPostRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/permissions/query/eu-entities/grants"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "pageOffset" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "pageOffset",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageOffset.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "pageSize" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "pageSize",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePermissionsQueryEuEntitiesGrantsPostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearer(ctx, PermissionsQueryEuEntitiesGrantsPostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodePermissionsQueryEuEntitiesGrantsPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PermissionsQueryPersonalGrantsPost invokes POST /permissions/query/personal/grants operation.
//
// Metoda pozwala na odczytanie własnych uprawnień uwierzytelnionego klienta API w bieżącym
// kontekście logowania.
// W odpowiedzi przekazywane są następujące uprawnienia:
// - nadane w sposób bezpośredni w bieżącym kontekście
// - nadane przez podmiot nadrzędny
// - nadane w sposób pośredni, jeżeli podmiot kontekstu logowania jest w uprawnieniu pośrednikiem
// lub podmiotem docelowym
// - nadane podmiotowi do obsługi faktur przez inny podmiot, jeśli podmiot uwierzytelniony ma w
// bieżącym kontekście uprawnienia właścicielskie
// Uprawnienia zwracane przez operację obejmują:
// - **CredentialsManage** – zarządzanie uprawnieniami
// - **CredentialsRead** – przeglądanie uprawnień
// - **InvoiceWrite** – wystawianie faktur
// - **InvoiceRead** – przeglądanie faktur
// - **Introspection** – przeglądanie historii sesji
// - **SubunitManage** – zarządzanie podmiotami podrzędnymi
// - **EnforcementOperations** – wykonywanie operacji egzekucyjnych
// - **VatEuManage** – zarządzanie uprawnieniami w ramach podmiotu unijnego
// Odpowiedź może być filtrowana na podstawie następujących parametrów:
// - **contextIdentifier** – identyfikator podmiotu, który nadał uprawnienie do obsługi faktur
// - **targetIdentifier** – identyfikator podmiotu docelowego dla uprawnień nadanych pośrednio
// - **permissionTypes** – lista rodzajów wyszukiwanych uprawnień
// - **permissionState** – status uprawnienia
// #### Stronicowanie wyników
// Zapytanie zwraca **jedną stronę wyników** o numerze i rozmiarze podanym w ścieżce.
// - Przy pierwszym wywołaniu należy ustawić parametr `pageOffset = 0`.
// - Jeżeli dostępna jest kolejna strona wyników, w odpowiedzi pojawi się flaga **`hasMore`**.
// - W takim przypadku można wywołać zapytanie ponownie z kolejnym numerem strony.
// > Więcej informacji:
// > - [Pobieranie listy uprawnień](https://github.com/CIRFMF/ksef-docs/blob/main/uprawnienia.
// md#pobranie-listy-w%C5%82asnych-uprawnie%C5%84)
// **Sortowanie:**
// - startDate (Desc)
// - id (Asc).
//
// POST /permissions/query/personal/grants
func (c *Client) PermissionsQueryPersonalGrantsPost(ctx context.Context, request OptPersonalPermissionsQueryRequest, params PermissionsQueryPersonalGrantsPostParams) (PermissionsQueryPersonalGrantsPostRes, error) {
	res, err := c.sendPermissionsQueryPersonalGrantsPost(ctx, request, params)
	return res, err
}

func (c *Client) sendPermissionsQueryPersonalGrantsPost(ctx context.Context, request OptPersonalPermissionsQueryRequest, params PermissionsQueryPersonalGrantsPostParams) (res PermissionsQueryPersonalGrantsPostRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/permissions/query/personal/grants"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "pageOffset" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "pageOffset",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageOffset.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "pageSize" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "pageSize",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePermissionsQueryPersonalGrantsPostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearer(ctx, PermissionsQueryPersonalGrantsPostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodePermissionsQueryPersonalGrantsPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PermissionsQueryPersonsGrantsPost invokes POST /permissions/query/persons/grants operation.
//
// Metoda pozwala na odczytanie uprawnień nadanych osobie fizycznej lub podmiotowi.
// Lista pobranych uprawnień może być dwóch rodzajów:
// - Lista wszystkich uprawnień obowiązujących w bieżącym kontekście logowania (używana, gdy
// administrator chce przejrzeć uprawnienia wszystkich użytkowników w bieżącym kontekście)
// - Lista wszystkich uprawnień nadanych w bieżącym kontekście przez uwierzytelnionego klienta
// API (używana, gdy administrator chce przejrzeć listę nadanych przez siebie uprawnień w
// bieżącym kontekście)
// Dla pierwszej listy (obowiązujących uprawnień) w odpowiedzi przekazywane są:
// - osoby i podmioty mogące pracować w bieżącym kontekście z wyjątkiem osób uprawnionych w
// sposób pośredni
// - osoby uprawnione w sposób pośredni przez podmiot bieżącego kontekstu
// Dla drugiej listy (nadanych uprawnień) w odpowiedzi przekazywane są:
// - uprawnienia nadane w sposób bezpośredni do pracy w bieżącym kontekście lub w kontekście
// jednostek podrzędnych
// - uprawnienia nadane w sposób pośredni do obsługi klientów podmiotu bieżącego kontekstu
// Uprawnienia zwracane przez operację obejmują:
// - **CredentialsManage** – zarządzanie uprawnieniami
// - **CredentialsRead** – przeglądanie uprawnień
// - **InvoiceWrite** – wystawianie faktur
// - **InvoiceRead** – przeglądanie faktur
// - **Introspection** – przeglądanie historii sesji
// - **SubunitManage** – zarządzanie podmiotami podrzędnymi
// - **EnforcementOperations** – wykonywanie operacji egzekucyjnych
// Odpowiedź może być filtrowana na podstawie parametrów:
// - **authorIdentifier** – identyfikator osoby, która nadała uprawnienie
// - **authorizedIdentifier** – identyfikator osoby lub podmiotu uprawnionego
// - **targetIdentifier** – identyfikator podmiotu docelowego dla uprawnień nadanych pośrednio
// - **permissionTypes** – lista rodzajów wyszukiwanych uprawnień
// - **permissionState** – status uprawnienia
// - **queryType** – typ zapytania określający, która z dwóch list ma zostać zwrócona
// #### Stronicowanie wyników
// Zapytanie zwraca **jedną stronę wyników** o numerze i rozmiarze podanym w ścieżce.
// - Przy pierwszym wywołaniu należy ustawić parametr `pageOffset = 0`.
// - Jeżeli dostępna jest kolejna strona wyników, w odpowiedzi pojawi się flaga **`hasMore`**.
// - W takim przypadku można wywołać zapytanie ponownie z kolejnym numerem strony.
// > Więcej informacji:
// > - [Pobieranie listy uprawnień](https://github.com/CIRFMF/ksef-docs/blob/main/uprawnienia.
// md#pobranie-listy-uprawnie%C5%84-do-pracy-w-ksef-nadanych-osobom-fizycznym-lub-podmiotom)
// **Sortowanie:**
// - startDate (Desc)
// - id (Asc)
// **Wymagane uprawnienia**: `CredentialsManage`, `CredentialsRead`, `SubunitManage`.
//
// POST /permissions/query/persons/grants
func (c *Client) PermissionsQueryPersonsGrantsPost(ctx context.Context, request OptPersonPermissionsQueryRequest, params PermissionsQueryPersonsGrantsPostParams) (PermissionsQueryPersonsGrantsPostRes, error) {
	res, err := c.sendPermissionsQueryPersonsGrantsPost(ctx, request, params)
	return res, err
}

func (c *Client) sendPermissionsQueryPersonsGrantsPost(ctx context.Context, request OptPersonPermissionsQueryRequest, params PermissionsQueryPersonsGrantsPostParams) (res PermissionsQueryPersonsGrantsPostRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/permissions/query/persons/grants"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "pageOffset" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "pageOffset",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageOffset.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "pageSize" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "pageSize",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePermissionsQueryPersonsGrantsPostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearer(ctx, PermissionsQueryPersonsGrantsPostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodePermissionsQueryPersonsGrantsPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PermissionsQuerySubordinateEntitiesRolesPost invokes POST /permissions/query/subordinate-entities/roles operation.
//
// Metoda pozwala na odczytanie listy podmiotów podrzędnych,
// jeżeli podmiot bieżącego kontekstu ma rolę podmiotu nadrzędnego:
// - **nadrzędna JST** – odczytywane są podrzędne JST,
// - **grupa VAT** – odczytywane są podmioty będące członkami grupy VAT.
// Role podmiotów zwracane przez operację obejmują:
// - **LocalGovernmentSubUnit** – podrzędne JST,
// - **VatGroupSubUnit** – członek grupy VAT.
// Odpowiedź może być filtrowana według parametru:
// - **subordinateEntityIdentifier** – identyfikator podmiotu podrzędnego.
// #### Stronicowanie wyników
// Zapytanie zwraca **jedną stronę wyników** o numerze i rozmiarze podanym w ścieżce.
// - Przy pierwszym wywołaniu należy ustawić parametr `pageOffset = 0`.
// - Jeżeli dostępna jest kolejna strona wyników, w odpowiedzi pojawi się flaga **`hasMore`**.
// - W takim przypadku można wywołać zapytanie ponownie z kolejnym numerem strony.
// > Więcej informacji:
// > - [Pobieranie listy podmiotów podrzędnych](https://github.
// com/CIRFMF/ksef-docs/blob/main/uprawnienia.md#pobranie-listy-podmiot%C3%B3w-podrz%C4%99dnych)
// **Sortowanie:**
// - startDate (Desc)
// - id (Asc)
// **Wymagane uprawnienia**: `CredentialsManage`, `CredentialsRead`, `SubunitManage`.
//
// POST /permissions/query/subordinate-entities/roles
func (c *Client) PermissionsQuerySubordinateEntitiesRolesPost(ctx context.Context, request OptSubordinateEntityRolesQueryRequest, params PermissionsQuerySubordinateEntitiesRolesPostParams) (PermissionsQuerySubordinateEntitiesRolesPostRes, error) {
	res, err := c.sendPermissionsQuerySubordinateEntitiesRolesPost(ctx, request, params)
	return res, err
}

func (c *Client) sendPermissionsQuerySubordinateEntitiesRolesPost(ctx context.Context, request OptSubordinateEntityRolesQueryRequest, params PermissionsQuerySubordinateEntitiesRolesPostParams) (res PermissionsQuerySubordinateEntitiesRolesPostRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/permissions/query/subordinate-entities/roles"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "pageOffset" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "pageOffset",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageOffset.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "pageSize" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "pageSize",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePermissionsQuerySubordinateEntitiesRolesPostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearer(ctx, PermissionsQuerySubordinateEntitiesRolesPostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodePermissionsQuerySubordinateEntitiesRolesPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PermissionsQuerySubunitsGrantsPost invokes POST /permissions/query/subunits/grants operation.
//
// Metoda pozwala na odczytanie uprawnień do zarządzania uprawnieniami nadanych administratorom:
// - jednostek podrzędnych identyfikowanych identyfikatorem wewnętrznym
// - podmiotów podrzędnych (podrzędnych JST lub członków grupy VAT) identyfikowanych przez NIP
// Lista zwraca wyłącznie uprawnienia do zarządzania uprawnieniami nadane z kontekstu bieżącego
// (z podmiotu nadrzędnego).
// Nie są odczytywane uprawnienia nadane przez administratorów jednostek podrzędnych wewnątrz
// tych jednostek.
// Odpowiedź może być filtrowana na podstawie parametru:
// - **subunitIdentifier** – identyfikator jednostki lub podmiotu podrzędnego
// #### Stronicowanie wyników
// Zapytanie zwraca **jedną stronę wyników** o numerze i rozmiarze podanym w ścieżce.
// - Przy pierwszym wywołaniu należy ustawić parametr `pageOffset = 0`.
// - Jeżeli dostępna jest kolejna strona wyników, w odpowiedzi pojawi się flaga **`hasMore`**.
// - W takim przypadku można wywołać zapytanie ponownie z kolejnym numerem strony.
// > Więcej informacji:
// > - [Pobieranie listy uprawnień](https://github.com/CIRFMF/ksef-docs/blob/main/uprawnienia.
// md#pobranie-listy-uprawnie%C5%84-administrator%C3%B3w-jednostek-i-podmiot%C3%B3w-podrz%C4%99dnych)
// **Sortowanie:**
// - startDate (Desc)
// - id (Asc)
// **Wymagane uprawnienia**: `CredentialsManage`, `CredentialsRead`, `SubunitManage`.
//
// POST /permissions/query/subunits/grants
func (c *Client) PermissionsQuerySubunitsGrantsPost(ctx context.Context, request OptSubunitPermissionsQueryRequest, params PermissionsQuerySubunitsGrantsPostParams) (PermissionsQuerySubunitsGrantsPostRes, error) {
	res, err := c.sendPermissionsQuerySubunitsGrantsPost(ctx, request, params)
	return res, err
}

func (c *Client) sendPermissionsQuerySubunitsGrantsPost(ctx context.Context, request OptSubunitPermissionsQueryRequest, params PermissionsQuerySubunitsGrantsPostParams) (res PermissionsQuerySubunitsGrantsPostRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/permissions/query/subunits/grants"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "pageOffset" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "pageOffset",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageOffset.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "pageSize" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "pageSize",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePermissionsQuerySubunitsGrantsPostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearer(ctx, PermissionsQuerySubunitsGrantsPostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodePermissionsQuerySubunitsGrantsPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PermissionsSubunitsGrantsPost invokes POST /permissions/subunits/grants operation.
//
// Metoda pozwala na nadanie wskazanemu w żądaniu podmiotowi lub osobie fizycznej uprawnień
// administratora w kontekście:
// - wskazanego NIP podmiotu podrzędnego – wyłącznie jeżeli podmiot bieżącego kontekstu
// logowania ma rolę podmiotu nadrzędnego:
// - **LocalGovernmentUnit**
// - **VatGroupUnit**
// - wskazanego lub utworzonego identyfikatora wewnętrznego
// Wraz z utworzeniem administratora jednostki podrzędnej tworzony jest identyfikator wewnętrzny
// składający się z numeru NIP podmiotu kontekstu logowania oraz 5 cyfr unikalnie
// identyfikujących jednostkę wewnętrzną.
// Ostatnia cyfra musi być poprawną sumą kontrolną, która jest obliczana według poniższego
// algorytmu.
// Algorytm używa naprzemiennych wag (1×, 3×, 1×, 3×, ...), sumuje wyniki i zwraca resztę z
// dzielenia przez 10.
// Przykład:
// - Wejście: "6824515772-1234" (bez cyfry kontrolnej)
// - Pozycja 0 (1. cyfra): 6 × 1 = 6
// - Pozycja 1 (2. cyfra): 8 × 3 = 24
// - Pozycja 2 (3. cyfra): 2 × 1 = 2
// - Pozycja 3 (4. cyfra): 4 × 3 = 12
// - Pozycja 4 (5. cyfra): 5 × 1 = 5
// - Pozycja 5 (6. cyfra): 1 × 3 = 3
// - Pozycja 6 (7. cyfra): 5 × 1 = 5
// - Pozycja 7 (8. cyfra): 7 × 3 = 21
// - Pozycja 8 (9. cyfra): 7 × 1 = 7
// - Pozycja 9 (10. cyfra): 2 × 3 = 6
// - Pozycja 10 (11. cyfra): 1 × 1 = 1
// - Pozycja 11 (12. cyfra): 2 × 3 = 6
// - Pozycja 12 (13. cyfra): 3 × 1 = 3
// - Pozycja 13 (14. cyfra): 4 × 3 = 12
// - Suma: 6 + 24 + 2 + 12 + 5 + 3 + 5 + 21 + 7 + 6 + 1 + 6 + 3 + 12 = 113
// - Cyfra kontrolna (15. cyfra): 113 % 10 = 3
// W żądaniu podaje się również nazwę tej jednostki.
// Uprawnienia administratora jednostki podrzędnej obejmują:
// - **CredentialsManage** – zarządzanie uprawnieniami
// Metoda automatycznie nadaje powyższe uprawnienie, bez konieczności podawania go w żądaniu.
// > Więcej informacji:
// > - [Nadawanie uprawnień](https://github.com/CIRFMF/ksef-docs/blob/main/uprawnienia.
// md#nadanie-uprawnie%C5%84-administratora-podmiotu-podrz%C4%99dnego)
// **Wymagane uprawnienia**: `SubunitManage`.
//
// POST /permissions/subunits/grants
func (c *Client) PermissionsSubunitsGrantsPost(ctx context.Context, request OptSubunitPermissionsGrantRequest) (PermissionsSubunitsGrantsPostRes, error) {
	res, err := c.sendPermissionsSubunitsGrantsPost(ctx, request)
	return res, err
}

func (c *Client) sendPermissionsSubunitsGrantsPost(ctx context.Context, request OptSubunitPermissionsGrantRequest) (res PermissionsSubunitsGrantsPostRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/permissions/subunits/grants"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePermissionsSubunitsGrantsPostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearer(ctx, PermissionsSubunitsGrantsPostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodePermissionsSubunitsGrantsPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// RateLimitsGet invokes GET /rate-limits operation.
//
// Zwraca wartości aktualnie obowiązujących limitów ilości żądań przesyłanych do API.
//
// GET /rate-limits
func (c *Client) RateLimitsGet(ctx context.Context) (RateLimitsGetRes, error) {
	res, err := c.sendRateLimitsGet(ctx)
	return res, err
}

func (c *Client) sendRateLimitsGet(ctx context.Context) (res RateLimitsGetRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/rate-limits"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearer(ctx, RateLimitsGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeRateLimitsGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SecurityPublicKeyCertificatesGet invokes GET /security/public-key-certificates operation.
//
// Zwraca informacje o kluczach publicznych używanych do szyfrowania danych przesyłanych do systemu
// KSeF.
//
// GET /security/public-key-certificates
func (c *Client) SecurityPublicKeyCertificatesGet(ctx context.Context) (SecurityPublicKeyCertificatesGetRes, error) {
	res, err := c.sendSecurityPublicKeyCertificatesGet(ctx)
	return res, err
}

func (c *Client) sendSecurityPublicKeyCertificatesGet(ctx context.Context) (res SecurityPublicKeyCertificatesGetRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/security/public-key-certificates"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeSecurityPublicKeyCertificatesGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SessionsBatchPost invokes POST /sessions/batch operation.
//
// Otwiera sesję do wysyłki wsadowej faktur. Należy przekazać schemat wysyłanych faktur,
// informacje o paczce faktur oraz informacje o kluczu używanym do szyfrowania.
// > Więcej informacji:
// > - [Przygotowanie paczki faktur](https://github.com/CIRFMF/ksef-docs/blob/main/sesja-wsadowa.md)
// > - [Klucz publiczny Ministerstwa Finansów](/docs/v2/index.
// html#tag/Certyfikaty-klucza-publicznego)
// Aby generować dokumenty UPO w wersji v4-3 w ramach sesji, należy przy jej otwarciu przesłać
// nagłówek <b>X-KSeF-Feature: upo-v4-3</b>.
// Od 22 grudnia 2025 wersja UPO v4-3 będzie generowana domyślnie.
// **Wymagane uprawnienia**: `InvoiceWrite`, `EnforcementOperations`.
//
// POST /sessions/batch
func (c *Client) SessionsBatchPost(ctx context.Context, request OptOpenBatchSessionRequest) (SessionsBatchPostRes, error) {
	res, err := c.sendSessionsBatchPost(ctx, request)
	return res, err
}

func (c *Client) sendSessionsBatchPost(ctx context.Context, request OptOpenBatchSessionRequest) (res SessionsBatchPostRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/sessions/batch"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeSessionsBatchPostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearer(ctx, SessionsBatchPostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeSessionsBatchPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SessionsBatchReferenceNumberClosePost invokes POST /sessions/batch/{referenceNumber}/close operation.
//
// Zamyka sesję wsadową, rozpoczyna procesowanie paczki faktur i generowanie UPO dla prawidłowych
// faktur oraz zbiorczego UPO dla sesji.
// **Wymagane uprawnienia**: `InvoiceWrite`, `EnforcementOperations`.
//
// POST /sessions/batch/{referenceNumber}/close
func (c *Client) SessionsBatchReferenceNumberClosePost(ctx context.Context, params SessionsBatchReferenceNumberClosePostParams) (SessionsBatchReferenceNumberClosePostRes, error) {
	res, err := c.sendSessionsBatchReferenceNumberClosePost(ctx, params)
	return res, err
}

func (c *Client) sendSessionsBatchReferenceNumberClosePost(ctx context.Context, params SessionsBatchReferenceNumberClosePostParams) (res SessionsBatchReferenceNumberClosePostRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/sessions/batch/"
	{
		// Encode "referenceNumber" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "referenceNumber",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.ReferenceNumber); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/close"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearer(ctx, SessionsBatchReferenceNumberClosePostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeSessionsBatchReferenceNumberClosePostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SessionsGet invokes GET /sessions operation.
//
// Zwraca listę sesji spełniających podane kryteria wyszukiwania.
// **Sortowanie:**
// - dateCreated (Desc)
// **Wymagane uprawnienia**:
// - `Introspection`/`EnforcementOperations` – pozwala pobrać wszystkie sesje w bieżącym
// kontekście uwierzytelnienia `(ContextIdentifier)`.
// - `InvoiceWrite` – pozwala pobrać wyłącznie sesje utworzone przez podmiot uwierzytelniający,
// czyli podmiot inicjujący uwierzytelnienie.
//
// GET /sessions
func (c *Client) SessionsGet(ctx context.Context, params SessionsGetParams) (SessionsGetRes, error) {
	res, err := c.sendSessionsGet(ctx, params)
	return res, err
}

func (c *Client) sendSessionsGet(ctx context.Context, params SessionsGetParams) (res SessionsGetRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/sessions"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "pageSize" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "pageSize",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "sessionType" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sessionType",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(string(params.SessionType)))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "referenceNumber" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "referenceNumber",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ReferenceNumber.Get(); ok {
				if unwrapped := string(val); true {
					return e.EncodeValue(conv.StringToString(unwrapped))
				}
				return nil
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "dateCreatedFrom" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "dateCreatedFrom",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.DateCreatedFrom.Get(); ok {
				return e.EncodeValue(conv.DateTimeToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "dateCreatedTo" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "dateCreatedTo",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.DateCreatedTo.Get(); ok {
				return e.EncodeValue(conv.DateTimeToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "dateClosedFrom" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "dateClosedFrom",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.DateClosedFrom.Get(); ok {
				return e.EncodeValue(conv.DateTimeToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "dateClosedTo" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "dateClosedTo",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.DateClosedTo.Get(); ok {
				return e.EncodeValue(conv.DateTimeToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "dateModifiedFrom" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "dateModifiedFrom",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.DateModifiedFrom.Get(); ok {
				return e.EncodeValue(conv.DateTimeToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "dateModifiedTo" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "dateModifiedTo",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.DateModifiedTo.Get(); ok {
				return e.EncodeValue(conv.DateTimeToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "statuses" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "statuses",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if params.Statuses != nil {
				return e.EncodeArray(func(e uri.Encoder) error {
					for i, item := range params.Statuses {
						if err := func() error {
							return e.EncodeValue(conv.StringToString(string(item)))
						}(); err != nil {
							return errors.Wrapf(err, "[%d]", i)
						}
					}
					return nil
				})
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "x-continuation-token",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XContinuationToken.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearer(ctx, SessionsGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeSessionsGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SessionsOnlinePost invokes POST /sessions/online operation.
//
// Otwiera sesję do wysyłki pojedynczych faktur. Należy przekazać schemat wysyłanych faktur oraz
// informacje o kluczu używanym do szyfrowania.
// > Więcej informacji:
// > - [Otwarcie sesji interaktywnej](https://github.
// com/CIRFMF/ksef-docs/blob/main/sesja-interaktywna.md#1-otwarcie-sesji)
// > - [Klucz publiczny Ministerstwa Finansów](/docs/v2/index.
// html#tag/Certyfikaty-klucza-publicznego)
// Aby generować dokumenty UPO w wersji v4-3 w ramach sesji, należy przy jej otwarciu przesłać
// nagłówek <b>X-KSeF-Feature: upo-v4-3</b>.
// Od 22 grudnia 2025 wersja UPO v4-3 będzie generowana domyślnie.
// **Wymagane uprawnienia**: `InvoiceWrite`, `PefInvoiceWrite`, `EnforcementOperations`.
//
// POST /sessions/online
func (c *Client) SessionsOnlinePost(ctx context.Context, request OptOpenOnlineSessionRequest) (SessionsOnlinePostRes, error) {
	res, err := c.sendSessionsOnlinePost(ctx, request)
	return res, err
}

func (c *Client) sendSessionsOnlinePost(ctx context.Context, request OptOpenOnlineSessionRequest) (res SessionsOnlinePostRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/sessions/online"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeSessionsOnlinePostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearer(ctx, SessionsOnlinePostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeSessionsOnlinePostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SessionsOnlineReferenceNumberClosePost invokes POST /sessions/online/{referenceNumber}/close operation.
//
// Zamyka sesję interaktywną i rozpoczyna generowanie zbiorczego UPO dla sesji.
// **Wymagane uprawnienia**: `InvoiceWrite`, `PefInvoiceWrite`, `EnforcementOperations`.
//
// POST /sessions/online/{referenceNumber}/close
func (c *Client) SessionsOnlineReferenceNumberClosePost(ctx context.Context, params SessionsOnlineReferenceNumberClosePostParams) (SessionsOnlineReferenceNumberClosePostRes, error) {
	res, err := c.sendSessionsOnlineReferenceNumberClosePost(ctx, params)
	return res, err
}

func (c *Client) sendSessionsOnlineReferenceNumberClosePost(ctx context.Context, params SessionsOnlineReferenceNumberClosePostParams) (res SessionsOnlineReferenceNumberClosePostRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/sessions/online/"
	{
		// Encode "referenceNumber" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "referenceNumber",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.ReferenceNumber); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/close"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearer(ctx, SessionsOnlineReferenceNumberClosePostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeSessionsOnlineReferenceNumberClosePostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SessionsOnlineReferenceNumberInvoicesPost invokes POST /sessions/online/{referenceNumber}/invoices operation.
//
// Przyjmuje zaszyfrowaną fakturę oraz jej metadane i rozpoczyna jej przetwarzanie.
// > Więcej informacji:
// > - [Wysłanie faktury](https://github.com/CIRFMF/ksef-docs/blob/main/sesja-interaktywna.
// md#2-wys%C5%82anie-faktury)
// **Wymagane uprawnienia**: `InvoiceWrite`, `PefInvoiceWrite`, `EnforcementOperations`.
//
// POST /sessions/online/{referenceNumber}/invoices
func (c *Client) SessionsOnlineReferenceNumberInvoicesPost(ctx context.Context, request OptSendInvoiceRequest, params SessionsOnlineReferenceNumberInvoicesPostParams) (SessionsOnlineReferenceNumberInvoicesPostRes, error) {
	res, err := c.sendSessionsOnlineReferenceNumberInvoicesPost(ctx, request, params)
	return res, err
}

func (c *Client) sendSessionsOnlineReferenceNumberInvoicesPost(ctx context.Context, request OptSendInvoiceRequest, params SessionsOnlineReferenceNumberInvoicesPostParams) (res SessionsOnlineReferenceNumberInvoicesPostRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/sessions/online/"
	{
		// Encode "referenceNumber" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "referenceNumber",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.ReferenceNumber); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/invoices"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeSessionsOnlineReferenceNumberInvoicesPostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearer(ctx, SessionsOnlineReferenceNumberInvoicesPostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeSessionsOnlineReferenceNumberInvoicesPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SessionsReferenceNumberGet invokes GET /sessions/{referenceNumber} operation.
//
// Sprawdza bieżący status sesji o podanym numerze referencyjnym.
// **Wymagane uprawnienia**: `InvoiceWrite`, `Introspection`, `PefInvoiceWrite`,
// `EnforcementOperations`.
//
// GET /sessions/{referenceNumber}
func (c *Client) SessionsReferenceNumberGet(ctx context.Context, params SessionsReferenceNumberGetParams) (SessionsReferenceNumberGetRes, error) {
	res, err := c.sendSessionsReferenceNumberGet(ctx, params)
	return res, err
}

func (c *Client) sendSessionsReferenceNumberGet(ctx context.Context, params SessionsReferenceNumberGetParams) (res SessionsReferenceNumberGetRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/sessions/"
	{
		// Encode "referenceNumber" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "referenceNumber",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.ReferenceNumber); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearer(ctx, SessionsReferenceNumberGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeSessionsReferenceNumberGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SessionsReferenceNumberInvoicesFailedGet invokes GET /sessions/{referenceNumber}/invoices/failed operation.
//
// Zwraca listę niepoprawnie przetworzonych faktur przesłanych w sesji wraz z ich statusami.
// **Wymagane uprawnienia**: `InvoiceWrite`, `Introspection`, `PefInvoiceWrite`,
// `EnforcementOperations`.
//
// GET /sessions/{referenceNumber}/invoices/failed
func (c *Client) SessionsReferenceNumberInvoicesFailedGet(ctx context.Context, params SessionsReferenceNumberInvoicesFailedGetParams) (SessionsReferenceNumberInvoicesFailedGetRes, error) {
	res, err := c.sendSessionsReferenceNumberInvoicesFailedGet(ctx, params)
	return res, err
}

func (c *Client) sendSessionsReferenceNumberInvoicesFailedGet(ctx context.Context, params SessionsReferenceNumberInvoicesFailedGetParams) (res SessionsReferenceNumberInvoicesFailedGetRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/sessions/"
	{
		// Encode "referenceNumber" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "referenceNumber",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.ReferenceNumber); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/invoices/failed"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "pageSize" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "pageSize",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "x-continuation-token",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XContinuationToken.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearer(ctx, SessionsReferenceNumberInvoicesFailedGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeSessionsReferenceNumberInvoicesFailedGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SessionsReferenceNumberInvoicesGet invokes GET /sessions/{referenceNumber}/invoices operation.
//
// Zwraca listę faktur przesłanych w sesji wraz z ich statusami, oraz informacje na temat ilości
// poprawnie i niepoprawnie przetworzonych faktur.
// **Wymagane uprawnienia**: `InvoiceWrite`, `Introspection`, `PefInvoiceWrite`,
// `EnforcementOperations`.
//
// GET /sessions/{referenceNumber}/invoices
func (c *Client) SessionsReferenceNumberInvoicesGet(ctx context.Context, params SessionsReferenceNumberInvoicesGetParams) (SessionsReferenceNumberInvoicesGetRes, error) {
	res, err := c.sendSessionsReferenceNumberInvoicesGet(ctx, params)
	return res, err
}

func (c *Client) sendSessionsReferenceNumberInvoicesGet(ctx context.Context, params SessionsReferenceNumberInvoicesGetParams) (res SessionsReferenceNumberInvoicesGetRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/sessions/"
	{
		// Encode "referenceNumber" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "referenceNumber",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.ReferenceNumber); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/invoices"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "pageSize" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "pageSize",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "x-continuation-token",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XContinuationToken.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearer(ctx, SessionsReferenceNumberInvoicesGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeSessionsReferenceNumberInvoicesGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SessionsReferenceNumberInvoicesInvoiceReferenceNumberGet invokes GET /sessions/{referenceNumber}/invoices/{invoiceReferenceNumber} operation.
//
// Zwraca fakturę przesłaną w sesji wraz ze statusem.
// **Wymagane uprawnienia**: `InvoiceWrite`, `Introspection`, `PefInvoiceWrite`,
// `EnforcementOperations`.
//
// GET /sessions/{referenceNumber}/invoices/{invoiceReferenceNumber}
func (c *Client) SessionsReferenceNumberInvoicesInvoiceReferenceNumberGet(ctx context.Context, params SessionsReferenceNumberInvoicesInvoiceReferenceNumberGetParams) (SessionsReferenceNumberInvoicesInvoiceReferenceNumberGetRes, error) {
	res, err := c.sendSessionsReferenceNumberInvoicesInvoiceReferenceNumberGet(ctx, params)
	return res, err
}

func (c *Client) sendSessionsReferenceNumberInvoicesInvoiceReferenceNumberGet(ctx context.Context, params SessionsReferenceNumberInvoicesInvoiceReferenceNumberGetParams) (res SessionsReferenceNumberInvoicesInvoiceReferenceNumberGetRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/sessions/"
	{
		// Encode "referenceNumber" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "referenceNumber",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.ReferenceNumber); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/invoices/"
	{
		// Encode "invoiceReferenceNumber" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "invoiceReferenceNumber",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.InvoiceReferenceNumber); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearer(ctx, SessionsReferenceNumberInvoicesInvoiceReferenceNumberGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeSessionsReferenceNumberInvoicesInvoiceReferenceNumberGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SessionsReferenceNumberInvoicesInvoiceReferenceNumberUpoGet invokes GET /sessions/{referenceNumber}/invoices/{invoiceReferenceNumber}/upo operation.
//
// Zwraca UPO faktury przesłanego w sesji na podstawie jego numeru KSeF.
// **Wymagane uprawnienia**: `InvoiceWrite`, `Introspection`, `PefInvoiceWrite`,
// `EnforcementOperations`.
//
// GET /sessions/{referenceNumber}/invoices/{invoiceReferenceNumber}/upo
func (c *Client) SessionsReferenceNumberInvoicesInvoiceReferenceNumberUpoGet(ctx context.Context, params SessionsReferenceNumberInvoicesInvoiceReferenceNumberUpoGetParams) (SessionsReferenceNumberInvoicesInvoiceReferenceNumberUpoGetRes, error) {
	res, err := c.sendSessionsReferenceNumberInvoicesInvoiceReferenceNumberUpoGet(ctx, params)
	return res, err
}

func (c *Client) sendSessionsReferenceNumberInvoicesInvoiceReferenceNumberUpoGet(ctx context.Context, params SessionsReferenceNumberInvoicesInvoiceReferenceNumberUpoGetParams) (res SessionsReferenceNumberInvoicesInvoiceReferenceNumberUpoGetRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/sessions/"
	{
		// Encode "referenceNumber" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "referenceNumber",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.ReferenceNumber); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/invoices/"
	{
		// Encode "invoiceReferenceNumber" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "invoiceReferenceNumber",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.InvoiceReferenceNumber); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/upo"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearer(ctx, SessionsReferenceNumberInvoicesInvoiceReferenceNumberUpoGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeSessionsReferenceNumberInvoicesInvoiceReferenceNumberUpoGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SessionsReferenceNumberInvoicesKsefKsefNumberUpoGet invokes GET /sessions/{referenceNumber}/invoices/ksef/{ksefNumber}/upo operation.
//
// Zwraca UPO faktury przesłanego w sesji na podstawie jego numeru KSeF.
// **Wymagane uprawnienia**: `InvoiceWrite`, `Introspection`, `PefInvoiceWrite`,
// `EnforcementOperations`.
//
// GET /sessions/{referenceNumber}/invoices/ksef/{ksefNumber}/upo
func (c *Client) SessionsReferenceNumberInvoicesKsefKsefNumberUpoGet(ctx context.Context, params SessionsReferenceNumberInvoicesKsefKsefNumberUpoGetParams) (SessionsReferenceNumberInvoicesKsefKsefNumberUpoGetRes, error) {
	res, err := c.sendSessionsReferenceNumberInvoicesKsefKsefNumberUpoGet(ctx, params)
	return res, err
}

func (c *Client) sendSessionsReferenceNumberInvoicesKsefKsefNumberUpoGet(ctx context.Context, params SessionsReferenceNumberInvoicesKsefKsefNumberUpoGetParams) (res SessionsReferenceNumberInvoicesKsefKsefNumberUpoGetRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/sessions/"
	{
		// Encode "referenceNumber" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "referenceNumber",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.ReferenceNumber); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/invoices/ksef/"
	{
		// Encode "ksefNumber" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "ksefNumber",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.KsefNumber); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/upo"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearer(ctx, SessionsReferenceNumberInvoicesKsefKsefNumberUpoGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeSessionsReferenceNumberInvoicesKsefKsefNumberUpoGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SessionsReferenceNumberUpoUpoReferenceNumberGet invokes GET /sessions/{referenceNumber}/upo/{upoReferenceNumber} operation.
//
// Zwraca XML zawierający zbiorcze UPO dla sesji.
// **Wymagane uprawnienia**: `InvoiceWrite`, `Introspection`, `PefInvoiceWrite`,
// `EnforcementOperations`.
//
// GET /sessions/{referenceNumber}/upo/{upoReferenceNumber}
func (c *Client) SessionsReferenceNumberUpoUpoReferenceNumberGet(ctx context.Context, params SessionsReferenceNumberUpoUpoReferenceNumberGetParams) (SessionsReferenceNumberUpoUpoReferenceNumberGetRes, error) {
	res, err := c.sendSessionsReferenceNumberUpoUpoReferenceNumberGet(ctx, params)
	return res, err
}

func (c *Client) sendSessionsReferenceNumberUpoUpoReferenceNumberGet(ctx context.Context, params SessionsReferenceNumberUpoUpoReferenceNumberGetParams) (res SessionsReferenceNumberUpoUpoReferenceNumberGetRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/sessions/"
	{
		// Encode "referenceNumber" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "referenceNumber",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.ReferenceNumber); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/upo/"
	{
		// Encode "upoReferenceNumber" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "upoReferenceNumber",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.UpoReferenceNumber); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearer(ctx, SessionsReferenceNumberUpoUpoReferenceNumberGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeSessionsReferenceNumberUpoUpoReferenceNumberGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TestdataAttachmentPost invokes POST /testdata/attachment operation.
//
// Dodaje możliwość wysyłania faktur z załącznikiem przez wskazany podmiot.
//
// POST /testdata/attachment
func (c *Client) TestdataAttachmentPost(ctx context.Context, request OptAttachmentPermissionGrantRequest) (TestdataAttachmentPostRes, error) {
	res, err := c.sendTestdataAttachmentPost(ctx, request)
	return res, err
}

func (c *Client) sendTestdataAttachmentPost(ctx context.Context, request OptAttachmentPermissionGrantRequest) (res TestdataAttachmentPostRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/testdata/attachment"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeTestdataAttachmentPostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTestdataAttachmentPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TestdataAttachmentRevokePost invokes POST /testdata/attachment/revoke operation.
//
// Odbiera możliwość wysyłania faktur z załącznikiem przez wskazany podmiot.
//
// POST /testdata/attachment/revoke
func (c *Client) TestdataAttachmentRevokePost(ctx context.Context, request OptAttachmentPermissionRevokeRequest) (TestdataAttachmentRevokePostRes, error) {
	res, err := c.sendTestdataAttachmentRevokePost(ctx, request)
	return res, err
}

func (c *Client) sendTestdataAttachmentRevokePost(ctx context.Context, request OptAttachmentPermissionRevokeRequest) (res TestdataAttachmentRevokePostRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/testdata/attachment/revoke"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeTestdataAttachmentRevokePostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTestdataAttachmentRevokePostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TestdataLimitsContextSessionDelete invokes DELETE /testdata/limits/context/session operation.
//
// Przywraca wartości aktualnie obowiązujących limitów sesji dla bieżącego kontekstu do
// wartości domyślnych. **Tylko na środowiskach testowych.**.
//
// DELETE /testdata/limits/context/session
func (c *Client) TestdataLimitsContextSessionDelete(ctx context.Context) (TestdataLimitsContextSessionDeleteRes, error) {
	res, err := c.sendTestdataLimitsContextSessionDelete(ctx)
	return res, err
}

func (c *Client) sendTestdataLimitsContextSessionDelete(ctx context.Context) (res TestdataLimitsContextSessionDeleteRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/testdata/limits/context/session"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearer(ctx, TestdataLimitsContextSessionDeleteOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTestdataLimitsContextSessionDeleteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TestdataLimitsContextSessionPost invokes POST /testdata/limits/context/session operation.
//
// Zmienia wartości aktualnie obowiązujących limitów sesji dla bieżącego kontekstu. **Tylko na
// środowiskach testowych.**.
//
// POST /testdata/limits/context/session
func (c *Client) TestdataLimitsContextSessionPost(ctx context.Context, request OptSetSessionLimitsRequest) (TestdataLimitsContextSessionPostRes, error) {
	res, err := c.sendTestdataLimitsContextSessionPost(ctx, request)
	return res, err
}

func (c *Client) sendTestdataLimitsContextSessionPost(ctx context.Context, request OptSetSessionLimitsRequest) (res TestdataLimitsContextSessionPostRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/testdata/limits/context/session"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeTestdataLimitsContextSessionPostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearer(ctx, TestdataLimitsContextSessionPostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTestdataLimitsContextSessionPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TestdataLimitsSubjectCertificateDelete invokes DELETE /testdata/limits/subject/certificate operation.
//
// Przywraca wartości aktualnie obowiązujących limitów certyfikatów dla bieżącego podmiotu do
// wartości domyślnych. **Tylko na środowiskach testowych.**.
//
// DELETE /testdata/limits/subject/certificate
func (c *Client) TestdataLimitsSubjectCertificateDelete(ctx context.Context) (TestdataLimitsSubjectCertificateDeleteRes, error) {
	res, err := c.sendTestdataLimitsSubjectCertificateDelete(ctx)
	return res, err
}

func (c *Client) sendTestdataLimitsSubjectCertificateDelete(ctx context.Context) (res TestdataLimitsSubjectCertificateDeleteRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/testdata/limits/subject/certificate"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearer(ctx, TestdataLimitsSubjectCertificateDeleteOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTestdataLimitsSubjectCertificateDeleteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TestdataLimitsSubjectCertificatePost invokes POST /testdata/limits/subject/certificate operation.
//
// Zmienia wartości aktualnie obowiązujących limitów certyfikatów dla bieżącego podmiotu.
// **Tylko na środowiskach testowych.**.
//
// POST /testdata/limits/subject/certificate
func (c *Client) TestdataLimitsSubjectCertificatePost(ctx context.Context, request OptSetSubjectLimitsRequest) (TestdataLimitsSubjectCertificatePostRes, error) {
	res, err := c.sendTestdataLimitsSubjectCertificatePost(ctx, request)
	return res, err
}

func (c *Client) sendTestdataLimitsSubjectCertificatePost(ctx context.Context, request OptSetSubjectLimitsRequest) (res TestdataLimitsSubjectCertificatePostRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/testdata/limits/subject/certificate"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeTestdataLimitsSubjectCertificatePostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearer(ctx, TestdataLimitsSubjectCertificatePostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTestdataLimitsSubjectCertificatePostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TestdataPermissionsPost invokes POST /testdata/permissions operation.
//
// Nadawanie uprawnień testowemu podmiotowi lub osobie fizycznej, a także w ich kontekście.
//
// POST /testdata/permissions
func (c *Client) TestdataPermissionsPost(ctx context.Context, request OptTestDataPermissionsGrantRequest) (TestdataPermissionsPostRes, error) {
	res, err := c.sendTestdataPermissionsPost(ctx, request)
	return res, err
}

func (c *Client) sendTestdataPermissionsPost(ctx context.Context, request OptTestDataPermissionsGrantRequest) (res TestdataPermissionsPostRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/testdata/permissions"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeTestdataPermissionsPostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTestdataPermissionsPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TestdataPermissionsRevokePost invokes POST /testdata/permissions/revoke operation.
//
// Odbieranie uprawnień nadanych testowemu podmiotowi lub osobie fizycznej, a także w ich
// kontekście.
//
// POST /testdata/permissions/revoke
func (c *Client) TestdataPermissionsRevokePost(ctx context.Context, request OptTestDataPermissionsRevokeRequest) (TestdataPermissionsRevokePostRes, error) {
	res, err := c.sendTestdataPermissionsRevokePost(ctx, request)
	return res, err
}

func (c *Client) sendTestdataPermissionsRevokePost(ctx context.Context, request OptTestDataPermissionsRevokeRequest) (res TestdataPermissionsRevokePostRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/testdata/permissions/revoke"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeTestdataPermissionsRevokePostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTestdataPermissionsRevokePostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TestdataPersonPost invokes POST /testdata/person operation.
//
// Tworzenie nowej osoby fizycznej, której system nadaje uprawnienia właścicielskie. Można
// również określić, czy osoba ta jest komornikiem – wówczas otrzyma odpowiednie uprawnienie
// egzekucyjne.
//
// POST /testdata/person
func (c *Client) TestdataPersonPost(ctx context.Context, request OptPersonCreateRequest) (TestdataPersonPostRes, error) {
	res, err := c.sendTestdataPersonPost(ctx, request)
	return res, err
}

func (c *Client) sendTestdataPersonPost(ctx context.Context, request OptPersonCreateRequest) (res TestdataPersonPostRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/testdata/person"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeTestdataPersonPostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTestdataPersonPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TestdataPersonRemovePost invokes POST /testdata/person/remove operation.
//
// Usuwanie testowej osoby fizycznej. System automatycznie odbierze jej wszystkie uprawnienia.
//
// POST /testdata/person/remove
func (c *Client) TestdataPersonRemovePost(ctx context.Context, request OptPersonRemoveRequest) (TestdataPersonRemovePostRes, error) {
	res, err := c.sendTestdataPersonRemovePost(ctx, request)
	return res, err
}

func (c *Client) sendTestdataPersonRemovePost(ctx context.Context, request OptPersonRemoveRequest) (res TestdataPersonRemovePostRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/testdata/person/remove"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeTestdataPersonRemovePostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTestdataPersonRemovePostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TestdataRateLimitsDelete invokes DELETE /testdata/rate-limits operation.
//
// Przywraca wartości aktualnie obowiązujących limitów żądań przesyłanych do API dla
// bieżącego kontekstu do wartości domyślnych. **Tylko na środowiskach testowych.**.
//
// DELETE /testdata/rate-limits
func (c *Client) TestdataRateLimitsDelete(ctx context.Context) (TestdataRateLimitsDeleteRes, error) {
	res, err := c.sendTestdataRateLimitsDelete(ctx)
	return res, err
}

func (c *Client) sendTestdataRateLimitsDelete(ctx context.Context) (res TestdataRateLimitsDeleteRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/testdata/rate-limits"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearer(ctx, TestdataRateLimitsDeleteOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTestdataRateLimitsDeleteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TestdataRateLimitsPost invokes POST /testdata/rate-limits operation.
//
// Zmienia wartości aktualnie obowiązujących limitów żądań przesyłanych do API dla
// bieżącego kontekstu. **Tylko na środowiskach testowych.**.
//
// POST /testdata/rate-limits
func (c *Client) TestdataRateLimitsPost(ctx context.Context, request OptSetRateLimitsRequest) (TestdataRateLimitsPostRes, error) {
	res, err := c.sendTestdataRateLimitsPost(ctx, request)
	return res, err
}

func (c *Client) sendTestdataRateLimitsPost(ctx context.Context, request OptSetRateLimitsRequest) (res TestdataRateLimitsPostRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/testdata/rate-limits"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeTestdataRateLimitsPostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearer(ctx, TestdataRateLimitsPostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTestdataRateLimitsPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TestdataRateLimitsProductionPost invokes POST /testdata/rate-limits/production operation.
//
// Zmienia wartości aktualnie obowiązujących limitów żądań przesyłanych do API dla
// bieżącego kontekstu na wartości takie jakie będą na środowisku produkcyjnym. **Tylko na
// środowiskach testowych.**.
//
// POST /testdata/rate-limits/production
func (c *Client) TestdataRateLimitsProductionPost(ctx context.Context) (TestdataRateLimitsProductionPostRes, error) {
	res, err := c.sendTestdataRateLimitsProductionPost(ctx)
	return res, err
}

func (c *Client) sendTestdataRateLimitsProductionPost(ctx context.Context) (res TestdataRateLimitsProductionPostRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/testdata/rate-limits/production"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearer(ctx, TestdataRateLimitsProductionPostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTestdataRateLimitsProductionPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TestdataSubjectPost invokes POST /testdata/subject operation.
//
// Tworzenie nowego podmiotu testowego. W przypadku grupy VAT i JST istnieje możliwość stworzenia
// jednostek podrzędnych. W wyniku takiego działania w systemie powstanie powiązanie między tymi
// podmiotami.
//
// POST /testdata/subject
func (c *Client) TestdataSubjectPost(ctx context.Context, request OptSubjectCreateRequest) (TestdataSubjectPostRes, error) {
	res, err := c.sendTestdataSubjectPost(ctx, request)
	return res, err
}

func (c *Client) sendTestdataSubjectPost(ctx context.Context, request OptSubjectCreateRequest) (res TestdataSubjectPostRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/testdata/subject"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeTestdataSubjectPostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTestdataSubjectPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TestdataSubjectRemovePost invokes POST /testdata/subject/remove operation.
//
// Usuwanie podmiotu testowego. W przypadku grupy VAT i JST usunięte zostaną również jednostki
// podrzędne.
//
// POST /testdata/subject/remove
func (c *Client) TestdataSubjectRemovePost(ctx context.Context, request OptSubjectRemoveRequest) (TestdataSubjectRemovePostRes, error) {
	res, err := c.sendTestdataSubjectRemovePost(ctx, request)
	return res, err
}

func (c *Client) sendTestdataSubjectRemovePost(ctx context.Context, request OptSubjectRemoveRequest) (res TestdataSubjectRemovePostRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/testdata/subject/remove"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeTestdataSubjectRemovePostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTestdataSubjectRemovePostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TokensGet invokes GET /tokens operation.
//
// **Sortowanie:**
// - dateCreated (Desc).
//
// GET /tokens
func (c *Client) TokensGet(ctx context.Context, params TokensGetParams) (TokensGetRes, error) {
	res, err := c.sendTokensGet(ctx, params)
	return res, err
}

func (c *Client) sendTokensGet(ctx context.Context, params TokensGetParams) (res TokensGetRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/tokens"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "status" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "status",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if params.Status != nil {
				return e.EncodeArray(func(e uri.Encoder) error {
					for i, item := range params.Status {
						if err := func() error {
							return e.EncodeValue(conv.StringToString(string(item)))
						}(); err != nil {
							return errors.Wrapf(err, "[%d]", i)
						}
					}
					return nil
				})
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "description" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "description",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Description.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "authorIdentifier" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "authorIdentifier",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.AuthorIdentifier.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "authorIdentifierType" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "authorIdentifierType",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.AuthorIdentifierType.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "pageSize" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "pageSize",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "x-continuation-token",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XContinuationToken.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearer(ctx, TokensGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTokensGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TokensPost invokes POST /tokens operation.
//
// Zwraca token, który może być użyty do uwierzytelniania się w KSeF.
// Token może być generowany tylko w kontekście NIP lub identyfikatora wewnętrznego. Jest
// zwracany tylko raz. Zaczyna być aktywny w momencie gdy jego status zmieni się na `Active`.
//
// POST /tokens
func (c *Client) TokensPost(ctx context.Context, request OptGenerateTokenRequest) (TokensPostRes, error) {
	res, err := c.sendTokensPost(ctx, request)
	return res, err
}

func (c *Client) sendTokensPost(ctx context.Context, request OptGenerateTokenRequest) (res TokensPostRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/tokens"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeTokensPostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearer(ctx, TokensPostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTokensPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TokensReferenceNumberDelete invokes DELETE /tokens/{referenceNumber} operation.
//
// Unieważniony token nie pozwoli już na uwierzytelnienie się za jego pomocą. Unieważnienie nie
// może zostać cofnięte.
//
// DELETE /tokens/{referenceNumber}
func (c *Client) TokensReferenceNumberDelete(ctx context.Context, params TokensReferenceNumberDeleteParams) (TokensReferenceNumberDeleteRes, error) {
	res, err := c.sendTokensReferenceNumberDelete(ctx, params)
	return res, err
}

func (c *Client) sendTokensReferenceNumberDelete(ctx context.Context, params TokensReferenceNumberDeleteParams) (res TokensReferenceNumberDeleteRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/tokens/"
	{
		// Encode "referenceNumber" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "referenceNumber",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.ReferenceNumber); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearer(ctx, TokensReferenceNumberDeleteOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTokensReferenceNumberDeleteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TokensReferenceNumberGet invokes GET /tokens/{referenceNumber} operation.
//
// Pobranie statusu tokena.
//
// GET /tokens/{referenceNumber}
func (c *Client) TokensReferenceNumberGet(ctx context.Context, params TokensReferenceNumberGetParams) (TokensReferenceNumberGetRes, error) {
	res, err := c.sendTokensReferenceNumberGet(ctx, params)
	return res, err
}

func (c *Client) sendTokensReferenceNumberGet(ctx context.Context, params TokensReferenceNumberGetParams) (res TokensReferenceNumberGetRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/tokens/"
	{
		// Encode "referenceNumber" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "referenceNumber",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.ReferenceNumber); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearer(ctx, TokensReferenceNumberGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTokensReferenceNumberGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}
